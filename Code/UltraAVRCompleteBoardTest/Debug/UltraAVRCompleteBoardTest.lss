
UltraAVRCompleteBoardTest.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000016e0  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000392  00800060  000016e0  00001774  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000019  008003f2  008003f2  00001b06  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00001b06  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00001b38  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000002c8  00000000  00000000  00001b74  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00002fe5  00000000  00000000  00001e3c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000e67  00000000  00000000  00004e21  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000ee8  00000000  00000000  00005c88  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000874  00000000  00000000  00006b70  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000bbf  00000000  00000000  000073e4  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00002f4e  00000000  00000000  00007fa3  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000002a8  00000000  00000000  0000aef1  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 32 00 	jmp	0x64	; 0x64 <__ctors_end>
       4:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>
       8:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>
       c:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>
      10:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>
      14:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>
      18:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>
      1c:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>
      20:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>
      24:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>
      28:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>
      2c:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>
      30:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>
      34:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>
      38:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>
      3c:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>
      40:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>
      44:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>
      48:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>
      4c:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>
      50:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>
      54:	7d 09       	sbc	r23, r13
      56:	7f 09       	sbc	r23, r15
      58:	81 09       	sbc	r24, r1
      5a:	83 09       	sbc	r24, r3
      5c:	85 09       	sbc	r24, r5
      5e:	87 09       	sbc	r24, r7
      60:	89 09       	sbc	r24, r9
      62:	8b 09       	sbc	r24, r11

00000064 <__ctors_end>:
      64:	11 24       	eor	r1, r1
      66:	1f be       	out	0x3f, r1	; 63
      68:	cf e5       	ldi	r28, 0x5F	; 95
      6a:	d8 e0       	ldi	r29, 0x08	; 8
      6c:	de bf       	out	0x3e, r29	; 62
      6e:	cd bf       	out	0x3d, r28	; 61

00000070 <__do_copy_data>:
      70:	13 e0       	ldi	r17, 0x03	; 3
      72:	a0 e6       	ldi	r26, 0x60	; 96
      74:	b0 e0       	ldi	r27, 0x00	; 0
      76:	e0 ee       	ldi	r30, 0xE0	; 224
      78:	f6 e1       	ldi	r31, 0x16	; 22
      7a:	02 c0       	rjmp	.+4      	; 0x80 <__do_copy_data+0x10>
      7c:	05 90       	lpm	r0, Z+
      7e:	0d 92       	st	X+, r0
      80:	a2 3f       	cpi	r26, 0xF2	; 242
      82:	b1 07       	cpc	r27, r17
      84:	d9 f7       	brne	.-10     	; 0x7c <__do_copy_data+0xc>

00000086 <__do_clear_bss>:
      86:	24 e0       	ldi	r18, 0x04	; 4
      88:	a2 ef       	ldi	r26, 0xF2	; 242
      8a:	b3 e0       	ldi	r27, 0x03	; 3
      8c:	01 c0       	rjmp	.+2      	; 0x90 <.do_clear_bss_start>

0000008e <.do_clear_bss_loop>:
      8e:	1d 92       	st	X+, r1

00000090 <.do_clear_bss_start>:
      90:	ab 30       	cpi	r26, 0x0B	; 11
      92:	b2 07       	cpc	r27, r18
      94:	e1 f7       	brne	.-8      	; 0x8e <.do_clear_bss_loop>
      96:	0e 94 61 09 	call	0x12c2	; 0x12c2 <main>
      9a:	0c 94 6e 0b 	jmp	0x16dc	; 0x16dc <_exit>

0000009e <__bad_interrupt>:
      9e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000a2 <ADC_Init>:
 * description :This function initializes the ADC module.

***************************************************************************************************/
void ADC_Init()
 {
   ADCSRA=(1<<ADEN) | (1<<ADPS0); /* Enable ADC , sampling freq=osc_freq/2 */
      a2:	81 e8       	ldi	r24, 0x81	; 129
      a4:	86 b9       	out	0x06, r24	; 6
   ADMUX=0x00;                    /* Result right justified, select channel zero */
      a6:	17 b8       	out	0x07, r1	; 7
      a8:	08 95       	ret

000000aa <ADC_GetAdcValue>:
				 For AVR/PIC(10-bit adc) the adc value per lsb will be 5/1023=0048v
***************************************************************************************************/				 
uint16_t ADC_GetAdcValue(uint8_t v_adcChannel_u8)
 {
   
   ADMUX = v_adcChannel_u8;               /* Select the required channel */
      aa:	87 b9       	out	0x07, r24	; 7
   DELAY_us(10);                          /* Wait for some time for the channel to get selected */
      ac:	8a e0       	ldi	r24, 0x0A	; 10
      ae:	90 e0       	ldi	r25, 0x00	; 0
      b0:	0e 94 60 00 	call	0xc0	; 0xc0 <DELAY_us>
   util_BitSet(ADCSRA,ADSC);              /* Start the ADC conversion by setting ADSC bit */
      b4:	36 9a       	sbi	0x06, 6	; 6
   
   while(util_IsBitCleared(ADCSRA,ADIF)); /* Wait till the conversion is over */
      b6:	34 9b       	sbis	0x06, 4	; 6
      b8:	fe cf       	rjmp	.-4      	; 0xb6 <ADC_GetAdcValue+0xc>
                                          /* ADIF will be set once ADC conversion is complete */
     return(ADCW);                        /* Return the 10-bit result */
      ba:	84 b1       	in	r24, 0x04	; 4
      bc:	95 b1       	in	r25, 0x05	; 5
 }
      be:	08 95       	ret

000000c0 <DELAY_us>:
         if 5000 is passed as the argument then it generates a delay of 5ms.		  

 ***************************************************************************************************/
void DELAY_us(uint16_t us_count) 
{
    while (us_count != 0) 
      c0:	00 97       	sbiw	r24, 0x00	; 0
      c2:	31 f0       	breq	.+12     	; 0xd0 <DELAY_us+0x10>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
      c4:	25 e0       	ldi	r18, 0x05	; 5
      c6:	2a 95       	dec	r18
      c8:	f1 f7       	brne	.-4      	; 0xc6 <DELAY_us+0x6>
      ca:	00 00       	nop
    {
        _delay_us(1);
		us_count--;
      cc:	01 97       	sbiw	r24, 0x01	; 1
      ce:	f8 cf       	rjmp	.-16     	; 0xc0 <DELAY_us>
    }
}
      d0:	08 95       	ret

000000d2 <DELAY_ms>:
     It generates a delay of 1ms for each count,
     if 1000 is passed as the argument then it generates delay of 1000ms(1sec)
 ***************************************************************************************************/
void DELAY_ms(uint16_t ms_count) 
{
    while (ms_count != 0) 
      d2:	00 97       	sbiw	r24, 0x00	; 0
      d4:	41 f0       	breq	.+16     	; 0xe6 <DELAY_ms+0x14>
      d6:	ef e9       	ldi	r30, 0x9F	; 159
      d8:	ff e0       	ldi	r31, 0x0F	; 15
      da:	31 97       	sbiw	r30, 0x01	; 1
      dc:	f1 f7       	brne	.-4      	; 0xda <DELAY_ms+0x8>
      de:	00 c0       	rjmp	.+0      	; 0xe0 <DELAY_ms+0xe>
      e0:	00 00       	nop
    {
        _delay_us(1000); //DELAY_us is called to generate 1ms delay
        ms_count--;
      e2:	01 97       	sbiw	r24, 0x01	; 1
      e4:	f6 cf       	rjmp	.-20     	; 0xd2 <DELAY_ms>
    }
}
      e6:	08 95       	ret

000000e8 <EEPROM_WriteByte>:
 * description: This function is used to write the data at specified EEPROM_address..

 **************************************************************************************************/
void EEPROM_WriteByte(uint16_t v_eepromAddress_u16, uint8_t v_eepromData_u8)
{
	while(util_IsBitSet(EECR,EEWE)); // Wait for completion of previous write.
      e8:	e1 99       	sbic	0x1c, 1	; 28
      ea:	fe cf       	rjmp	.-4      	; 0xe8 <EEPROM_WriteByte>
	                                 // EEWE will be cleared by hardware once Eeprom write is completed.

	EEAR = v_eepromAddress_u16;  //Load the eeprom address and data
      ec:	9f bb       	out	0x1f, r25	; 31
      ee:	8e bb       	out	0x1e, r24	; 30
	EEDR = v_eepromData_u8;
      f0:	6d bb       	out	0x1d, r22	; 29

	util_BitSet(EECR,EEMWE);    // Eeprom Master Write Enable
      f2:	e2 9a       	sbi	0x1c, 2	; 28
	util_BitSet(EECR,EEWE);     // Start eeprom write by setting EEWE
      f4:	e1 9a       	sbi	0x1c, 1	; 28
      f6:	08 95       	ret

000000f8 <EEPROM_ReadByte>:

 * description: This function is used to read the data from specified EEPROM_address.        
 ***************************************************************************************************/
uint8_t EEPROM_ReadByte(uint16_t v_eepromAddress_u16)
{
	while(util_IsBitSet(EECR,EEWE));  //Wait for completion of previous write if any.
      f8:	e1 99       	sbic	0x1c, 1	; 28
      fa:	fe cf       	rjmp	.-4      	; 0xf8 <EEPROM_ReadByte>

	EEAR = v_eepromAddress_u16;    //Load the address from where the data needs to be read.
      fc:	9f bb       	out	0x1f, r25	; 31
      fe:	8e bb       	out	0x1e, r24	; 30
	util_BitSet(EECR,EERE);   // start eeprom read by setting EERE
     100:	e0 9a       	sbi	0x1c, 0	; 28

	return EEDR;             // Return data from data register
     102:	8d b3       	in	r24, 0x1d	; 29
}
     104:	08 95       	ret

00000106 <GPIO_PinDirection>:

    uint8_t v_portNumber_u8;


    v_portNumber_u8 =  (enm_pinNumber>>3);  // Divide the pin number by 8 go get the PORT number
    enm_pinNumber  =   enm_pinNumber & 0x07;  // lower 3-bits contains the bit number of a byte 
     106:	98 2f       	mov	r25, r24
     108:	97 70       	andi	r25, 0x07	; 7
{

    uint8_t v_portNumber_u8;


    v_portNumber_u8 =  (enm_pinNumber>>3);  // Divide the pin number by 8 go get the PORT number
     10a:	86 95       	lsr	r24
     10c:	86 95       	lsr	r24
     10e:	86 95       	lsr	r24
    enm_pinNumber  =   enm_pinNumber & 0x07;  // lower 3-bits contains the bit number of a byte 

    /* Go to particular port after decoding from the pin number and 
        set the direction as specified*/
    switch(v_portNumber_u8)
     110:	81 30       	cpi	r24, 0x01	; 1
     112:	01 f1       	breq	.+64     	; 0x154 <GPIO_PinDirection+0x4e>
     114:	30 f0       	brcs	.+12     	; 0x122 <GPIO_PinDirection+0x1c>
     116:	82 30       	cpi	r24, 0x02	; 2
     118:	b1 f1       	breq	.+108    	; 0x186 <GPIO_PinDirection+0x80>
     11a:	83 30       	cpi	r24, 0x03	; 3
     11c:	09 f4       	brne	.+2      	; 0x120 <GPIO_PinDirection+0x1a>
     11e:	4c c0       	rjmp	.+152    	; 0x1b8 <GPIO_PinDirection+0xb2>
     120:	08 95       	ret
    {
#ifdef DDRA        
    case 0:
        util_UpdateBit(DDRA,enm_pinNumber,v_pinDirn_u8);
     122:	4a b3       	in	r20, 0x1a	; 26
     124:	21 e0       	ldi	r18, 0x01	; 1
     126:	30 e0       	ldi	r19, 0x00	; 0
     128:	66 23       	and	r22, r22
     12a:	49 f0       	breq	.+18     	; 0x13e <GPIO_PinDirection+0x38>
     12c:	b9 01       	movw	r22, r18
     12e:	02 c0       	rjmp	.+4      	; 0x134 <GPIO_PinDirection+0x2e>
     130:	66 0f       	add	r22, r22
     132:	77 1f       	adc	r23, r23
     134:	9a 95       	dec	r25
     136:	e2 f7       	brpl	.-8      	; 0x130 <GPIO_PinDirection+0x2a>
     138:	cb 01       	movw	r24, r22
     13a:	84 2b       	or	r24, r20
     13c:	09 c0       	rjmp	.+18     	; 0x150 <GPIO_PinDirection+0x4a>
     13e:	b9 01       	movw	r22, r18
     140:	02 c0       	rjmp	.+4      	; 0x146 <GPIO_PinDirection+0x40>
     142:	66 0f       	add	r22, r22
     144:	77 1f       	adc	r23, r23
     146:	9a 95       	dec	r25
     148:	e2 f7       	brpl	.-8      	; 0x142 <GPIO_PinDirection+0x3c>
     14a:	cb 01       	movw	r24, r22
     14c:	80 95       	com	r24
     14e:	84 23       	and	r24, r20
     150:	8a bb       	out	0x1a, r24	; 26
     152:	08 95       	ret
#endif        


#ifdef DDRB
    case 1:
        util_UpdateBit(DDRB,enm_pinNumber,v_pinDirn_u8);
     154:	47 b3       	in	r20, 0x17	; 23
     156:	21 e0       	ldi	r18, 0x01	; 1
     158:	30 e0       	ldi	r19, 0x00	; 0
     15a:	66 23       	and	r22, r22
     15c:	49 f0       	breq	.+18     	; 0x170 <GPIO_PinDirection+0x6a>
     15e:	b9 01       	movw	r22, r18
     160:	02 c0       	rjmp	.+4      	; 0x166 <GPIO_PinDirection+0x60>
     162:	66 0f       	add	r22, r22
     164:	77 1f       	adc	r23, r23
     166:	9a 95       	dec	r25
     168:	e2 f7       	brpl	.-8      	; 0x162 <GPIO_PinDirection+0x5c>
     16a:	cb 01       	movw	r24, r22
     16c:	84 2b       	or	r24, r20
     16e:	09 c0       	rjmp	.+18     	; 0x182 <GPIO_PinDirection+0x7c>
     170:	b9 01       	movw	r22, r18
     172:	02 c0       	rjmp	.+4      	; 0x178 <GPIO_PinDirection+0x72>
     174:	66 0f       	add	r22, r22
     176:	77 1f       	adc	r23, r23
     178:	9a 95       	dec	r25
     17a:	e2 f7       	brpl	.-8      	; 0x174 <GPIO_PinDirection+0x6e>
     17c:	cb 01       	movw	r24, r22
     17e:	80 95       	com	r24
     180:	84 23       	and	r24, r20
     182:	87 bb       	out	0x17, r24	; 23
     184:	08 95       	ret
#endif 

        
#ifdef DDRC
    case 2:
        util_UpdateBit(DDRC,enm_pinNumber,v_pinDirn_u8);
     186:	44 b3       	in	r20, 0x14	; 20
     188:	21 e0       	ldi	r18, 0x01	; 1
     18a:	30 e0       	ldi	r19, 0x00	; 0
     18c:	66 23       	and	r22, r22
     18e:	49 f0       	breq	.+18     	; 0x1a2 <GPIO_PinDirection+0x9c>
     190:	b9 01       	movw	r22, r18
     192:	02 c0       	rjmp	.+4      	; 0x198 <GPIO_PinDirection+0x92>
     194:	66 0f       	add	r22, r22
     196:	77 1f       	adc	r23, r23
     198:	9a 95       	dec	r25
     19a:	e2 f7       	brpl	.-8      	; 0x194 <GPIO_PinDirection+0x8e>
     19c:	cb 01       	movw	r24, r22
     19e:	84 2b       	or	r24, r20
     1a0:	09 c0       	rjmp	.+18     	; 0x1b4 <GPIO_PinDirection+0xae>
     1a2:	b9 01       	movw	r22, r18
     1a4:	02 c0       	rjmp	.+4      	; 0x1aa <GPIO_PinDirection+0xa4>
     1a6:	66 0f       	add	r22, r22
     1a8:	77 1f       	adc	r23, r23
     1aa:	9a 95       	dec	r25
     1ac:	e2 f7       	brpl	.-8      	; 0x1a6 <GPIO_PinDirection+0xa0>
     1ae:	cb 01       	movw	r24, r22
     1b0:	80 95       	com	r24
     1b2:	84 23       	and	r24, r20
     1b4:	84 bb       	out	0x14, r24	; 20
     1b6:	08 95       	ret
#endif 

        
#ifdef DDRD        
    case 3:
        util_UpdateBit(DDRD,enm_pinNumber,v_pinDirn_u8);
     1b8:	41 b3       	in	r20, 0x11	; 17
     1ba:	21 e0       	ldi	r18, 0x01	; 1
     1bc:	30 e0       	ldi	r19, 0x00	; 0
     1be:	66 23       	and	r22, r22
     1c0:	49 f0       	breq	.+18     	; 0x1d4 <GPIO_PinDirection+0xce>
     1c2:	b9 01       	movw	r22, r18
     1c4:	02 c0       	rjmp	.+4      	; 0x1ca <GPIO_PinDirection+0xc4>
     1c6:	66 0f       	add	r22, r22
     1c8:	77 1f       	adc	r23, r23
     1ca:	9a 95       	dec	r25
     1cc:	e2 f7       	brpl	.-8      	; 0x1c6 <GPIO_PinDirection+0xc0>
     1ce:	cb 01       	movw	r24, r22
     1d0:	84 2b       	or	r24, r20
     1d2:	09 c0       	rjmp	.+18     	; 0x1e6 <GPIO_PinDirection+0xe0>
     1d4:	b9 01       	movw	r22, r18
     1d6:	02 c0       	rjmp	.+4      	; 0x1dc <GPIO_PinDirection+0xd6>
     1d8:	66 0f       	add	r22, r22
     1da:	77 1f       	adc	r23, r23
     1dc:	9a 95       	dec	r25
     1de:	e2 f7       	brpl	.-8      	; 0x1d8 <GPIO_PinDirection+0xd2>
     1e0:	cb 01       	movw	r24, r22
     1e2:	80 95       	com	r24
     1e4:	84 23       	and	r24, r20
     1e6:	81 bb       	out	0x11, r24	; 17
     1e8:	08 95       	ret

000001ea <GPIO_PinWrite>:

    uint8_t v_portNumber_u8;


    v_portNumber_u8 =  (enm_pinNumber>>3);  // Divide the pin number by 8 go get the PORT number
    enm_pinNumber  =   enm_pinNumber & 0x07;  // lower 3-bits contains the bit number of a byte 
     1ea:	98 2f       	mov	r25, r24
     1ec:	97 70       	andi	r25, 0x07	; 7
{

    uint8_t v_portNumber_u8;


    v_portNumber_u8 =  (enm_pinNumber>>3);  // Divide the pin number by 8 go get the PORT number
     1ee:	86 95       	lsr	r24
     1f0:	86 95       	lsr	r24
     1f2:	86 95       	lsr	r24
    enm_pinNumber  =   enm_pinNumber & 0x07;  // lower 3-bits contains the bit number of a byte 

    /* Go to particular port after decoding from the pin number and 
        update the value of the specified pin*/
    switch(v_portNumber_u8)
     1f4:	81 30       	cpi	r24, 0x01	; 1
     1f6:	01 f1       	breq	.+64     	; 0x238 <GPIO_PinWrite+0x4e>
     1f8:	30 f0       	brcs	.+12     	; 0x206 <GPIO_PinWrite+0x1c>
     1fa:	82 30       	cpi	r24, 0x02	; 2
     1fc:	b1 f1       	breq	.+108    	; 0x26a <GPIO_PinWrite+0x80>
     1fe:	83 30       	cpi	r24, 0x03	; 3
     200:	09 f4       	brne	.+2      	; 0x204 <GPIO_PinWrite+0x1a>
     202:	4c c0       	rjmp	.+152    	; 0x29c <GPIO_PinWrite+0xb2>
     204:	08 95       	ret
    {
#ifdef PORTA        
    case 0:
        util_UpdateBit(PORTA,enm_pinNumber,v_pinValue_u8);
     206:	4b b3       	in	r20, 0x1b	; 27
     208:	21 e0       	ldi	r18, 0x01	; 1
     20a:	30 e0       	ldi	r19, 0x00	; 0
     20c:	66 23       	and	r22, r22
     20e:	49 f0       	breq	.+18     	; 0x222 <GPIO_PinWrite+0x38>
     210:	b9 01       	movw	r22, r18
     212:	02 c0       	rjmp	.+4      	; 0x218 <GPIO_PinWrite+0x2e>
     214:	66 0f       	add	r22, r22
     216:	77 1f       	adc	r23, r23
     218:	9a 95       	dec	r25
     21a:	e2 f7       	brpl	.-8      	; 0x214 <GPIO_PinWrite+0x2a>
     21c:	cb 01       	movw	r24, r22
     21e:	84 2b       	or	r24, r20
     220:	09 c0       	rjmp	.+18     	; 0x234 <GPIO_PinWrite+0x4a>
     222:	b9 01       	movw	r22, r18
     224:	02 c0       	rjmp	.+4      	; 0x22a <GPIO_PinWrite+0x40>
     226:	66 0f       	add	r22, r22
     228:	77 1f       	adc	r23, r23
     22a:	9a 95       	dec	r25
     22c:	e2 f7       	brpl	.-8      	; 0x226 <GPIO_PinWrite+0x3c>
     22e:	cb 01       	movw	r24, r22
     230:	80 95       	com	r24
     232:	84 23       	and	r24, r20
     234:	8b bb       	out	0x1b, r24	; 27
     236:	08 95       	ret
#endif        

        
#ifdef PORTB
    case 1:
        util_UpdateBit(PORTB,enm_pinNumber,v_pinValue_u8);
     238:	48 b3       	in	r20, 0x18	; 24
     23a:	21 e0       	ldi	r18, 0x01	; 1
     23c:	30 e0       	ldi	r19, 0x00	; 0
     23e:	66 23       	and	r22, r22
     240:	49 f0       	breq	.+18     	; 0x254 <GPIO_PinWrite+0x6a>
     242:	b9 01       	movw	r22, r18
     244:	02 c0       	rjmp	.+4      	; 0x24a <GPIO_PinWrite+0x60>
     246:	66 0f       	add	r22, r22
     248:	77 1f       	adc	r23, r23
     24a:	9a 95       	dec	r25
     24c:	e2 f7       	brpl	.-8      	; 0x246 <GPIO_PinWrite+0x5c>
     24e:	cb 01       	movw	r24, r22
     250:	84 2b       	or	r24, r20
     252:	09 c0       	rjmp	.+18     	; 0x266 <GPIO_PinWrite+0x7c>
     254:	b9 01       	movw	r22, r18
     256:	02 c0       	rjmp	.+4      	; 0x25c <GPIO_PinWrite+0x72>
     258:	66 0f       	add	r22, r22
     25a:	77 1f       	adc	r23, r23
     25c:	9a 95       	dec	r25
     25e:	e2 f7       	brpl	.-8      	; 0x258 <GPIO_PinWrite+0x6e>
     260:	cb 01       	movw	r24, r22
     262:	80 95       	com	r24
     264:	84 23       	and	r24, r20
     266:	88 bb       	out	0x18, r24	; 24
     268:	08 95       	ret
#endif        

        
#ifdef PORTC        
    case 2:
        util_UpdateBit(PORTC,enm_pinNumber,v_pinValue_u8);
     26a:	45 b3       	in	r20, 0x15	; 21
     26c:	21 e0       	ldi	r18, 0x01	; 1
     26e:	30 e0       	ldi	r19, 0x00	; 0
     270:	66 23       	and	r22, r22
     272:	49 f0       	breq	.+18     	; 0x286 <GPIO_PinWrite+0x9c>
     274:	b9 01       	movw	r22, r18
     276:	02 c0       	rjmp	.+4      	; 0x27c <GPIO_PinWrite+0x92>
     278:	66 0f       	add	r22, r22
     27a:	77 1f       	adc	r23, r23
     27c:	9a 95       	dec	r25
     27e:	e2 f7       	brpl	.-8      	; 0x278 <GPIO_PinWrite+0x8e>
     280:	cb 01       	movw	r24, r22
     282:	84 2b       	or	r24, r20
     284:	09 c0       	rjmp	.+18     	; 0x298 <GPIO_PinWrite+0xae>
     286:	b9 01       	movw	r22, r18
     288:	02 c0       	rjmp	.+4      	; 0x28e <GPIO_PinWrite+0xa4>
     28a:	66 0f       	add	r22, r22
     28c:	77 1f       	adc	r23, r23
     28e:	9a 95       	dec	r25
     290:	e2 f7       	brpl	.-8      	; 0x28a <GPIO_PinWrite+0xa0>
     292:	cb 01       	movw	r24, r22
     294:	80 95       	com	r24
     296:	84 23       	and	r24, r20
     298:	85 bb       	out	0x15, r24	; 21
     29a:	08 95       	ret
#endif        

        
#ifdef PORTD        
    case 3:
        util_UpdateBit(PORTD,enm_pinNumber,v_pinValue_u8);
     29c:	42 b3       	in	r20, 0x12	; 18
     29e:	21 e0       	ldi	r18, 0x01	; 1
     2a0:	30 e0       	ldi	r19, 0x00	; 0
     2a2:	66 23       	and	r22, r22
     2a4:	49 f0       	breq	.+18     	; 0x2b8 <GPIO_PinWrite+0xce>
     2a6:	b9 01       	movw	r22, r18
     2a8:	02 c0       	rjmp	.+4      	; 0x2ae <GPIO_PinWrite+0xc4>
     2aa:	66 0f       	add	r22, r22
     2ac:	77 1f       	adc	r23, r23
     2ae:	9a 95       	dec	r25
     2b0:	e2 f7       	brpl	.-8      	; 0x2aa <GPIO_PinWrite+0xc0>
     2b2:	cb 01       	movw	r24, r22
     2b4:	84 2b       	or	r24, r20
     2b6:	09 c0       	rjmp	.+18     	; 0x2ca <GPIO_PinWrite+0xe0>
     2b8:	b9 01       	movw	r22, r18
     2ba:	02 c0       	rjmp	.+4      	; 0x2c0 <GPIO_PinWrite+0xd6>
     2bc:	66 0f       	add	r22, r22
     2be:	77 1f       	adc	r23, r23
     2c0:	9a 95       	dec	r25
     2c2:	e2 f7       	brpl	.-8      	; 0x2bc <GPIO_PinWrite+0xd2>
     2c4:	cb 01       	movw	r24, r22
     2c6:	80 95       	com	r24
     2c8:	84 23       	and	r24, r20
     2ca:	82 bb       	out	0x12, r24	; 18
     2cc:	08 95       	ret

000002ce <GPIO_PinRead>:
{
    uint8_t v_portNumber_u8;
    uint8_t returnStatus = 0;

    v_portNumber_u8 =  (enm_pinNumber>>3); // Divide the pin number by 8 go get the PORT number
    enm_pinNumber  =     enm_pinNumber & 0x07; // lower 3-bits contains the bit number of a byte 
     2ce:	28 2f       	mov	r18, r24
     2d0:	27 70       	andi	r18, 0x07	; 7
uint8_t GPIO_PinRead(gpioPins_et enm_pinNumber)
{
    uint8_t v_portNumber_u8;
    uint8_t returnStatus = 0;

    v_portNumber_u8 =  (enm_pinNumber>>3); // Divide the pin number by 8 go get the PORT number
     2d2:	86 95       	lsr	r24
     2d4:	86 95       	lsr	r24
     2d6:	86 95       	lsr	r24
    enm_pinNumber  =     enm_pinNumber & 0x07; // lower 3-bits contains the bit number of a byte 

    /* Go to particular port after decoding from the pin number and read the pins status */
    switch(v_portNumber_u8)     
     2d8:	81 30       	cpi	r24, 0x01	; 1
     2da:	49 f0       	breq	.+18     	; 0x2ee <GPIO_PinRead+0x20>
     2dc:	30 f0       	brcs	.+12     	; 0x2ea <GPIO_PinRead+0x1c>
     2de:	82 30       	cpi	r24, 0x02	; 2
     2e0:	41 f0       	breq	.+16     	; 0x2f2 <GPIO_PinRead+0x24>
     2e2:	83 30       	cpi	r24, 0x03	; 3
     2e4:	79 f4       	brne	.+30     	; 0x304 <GPIO_PinRead+0x36>
#endif        
        
        
#ifdef PIND
    case 3:
        returnStatus = util_IsBitSet(PIND,enm_pinNumber);
     2e6:	80 b3       	in	r24, 0x10	; 16
     2e8:	05 c0       	rjmp	.+10     	; 0x2f4 <GPIO_PinRead+0x26>
    /* Go to particular port after decoding from the pin number and read the pins status */
    switch(v_portNumber_u8)     
    { 
#ifdef PINA    
    case 0: 
        returnStatus = util_IsBitSet(PINA,enm_pinNumber);
     2ea:	89 b3       	in	r24, 0x19	; 25
     2ec:	03 c0       	rjmp	.+6      	; 0x2f4 <GPIO_PinRead+0x26>
        break;
#endif        

#ifdef PINB
    case 1:
        returnStatus = util_IsBitSet(PINB,enm_pinNumber);
     2ee:	86 b3       	in	r24, 0x16	; 22
     2f0:	01 c0       	rjmp	.+2      	; 0x2f4 <GPIO_PinRead+0x26>
        break;
#endif          

#ifdef PINC
    case 2:
        returnStatus = util_IsBitSet(PINC,enm_pinNumber);
     2f2:	83 b3       	in	r24, 0x13	; 19
#endif        
        
        
#ifdef PIND
    case 3:
        returnStatus = util_IsBitSet(PIND,enm_pinNumber);
     2f4:	90 e0       	ldi	r25, 0x00	; 0
     2f6:	02 c0       	rjmp	.+4      	; 0x2fc <GPIO_PinRead+0x2e>
     2f8:	95 95       	asr	r25
     2fa:	87 95       	ror	r24
     2fc:	2a 95       	dec	r18
     2fe:	e2 f7       	brpl	.-8      	; 0x2f8 <GPIO_PinRead+0x2a>
     300:	81 70       	andi	r24, 0x01	; 1
        break;
     302:	08 95       	ret
                Before reading the pins status, the pin should be configured as INPUT 
 ***************************************************************************************************/
uint8_t GPIO_PinRead(gpioPins_et enm_pinNumber)
{
    uint8_t v_portNumber_u8;
    uint8_t returnStatus = 0;
     304:	80 e0       	ldi	r24, 0x00	; 0
        returnStatus = util_IsBitSet(PING,enm_pinNumber);
        break;
#endif             
    }                         
    return returnStatus;
}
     306:	08 95       	ret

00000308 <I2C_Init>:

 * description :This function is used to initialize the I2C module
------------------------------------------------------------------------------------*/
void I2C_Init()
{
    TWSR=0x00; //set presca1er bits to zero
     308:	11 b8       	out	0x01, r1	; 1
    TWBR=0x46; //SCL frequency is 50K for 16Mhz
     30a:	86 e4       	ldi	r24, 0x46	; 70
     30c:	80 b9       	out	0x00, r24	; 0
    TWCR=0x04; //enab1e TWI module
     30e:	84 e0       	ldi	r24, 0x04	; 4
     310:	86 bf       	out	0x36, r24	; 54
     312:	08 95       	ret

00000314 <I2C_Start>:
                      ____|         |____________

 ***************************************************************************************************/
void I2C_Start()
{
    TWCR = ((1<<TWINT) | (1<<TWSTA) | (1<<TWEN));
     314:	84 ea       	ldi	r24, 0xA4	; 164
     316:	86 bf       	out	0x36, r24	; 54
    while (!(TWCR & (1<<TWINT)));
     318:	06 b6       	in	r0, 0x36	; 54
     31a:	07 fe       	sbrs	r0, 7
     31c:	fd cf       	rjmp	.-6      	; 0x318 <I2C_Start+0x4>
}
     31e:	08 95       	ret

00000320 <I2C_Stop>:

 ***************************************************************************************************/

void I2C_Stop(void)
{
    TWCR = ((1<< TWINT) | (1<<TWEN) | (1<<TWSTO));
     320:	84 e9       	ldi	r24, 0x94	; 148
     322:	86 bf       	out	0x36, r24	; 54
    DELAY_us(100) ; //wait for a short time
     324:	84 e6       	ldi	r24, 0x64	; 100
     326:	90 e0       	ldi	r25, 0x00	; 0
     328:	0c 94 60 00 	jmp	0xc0	; 0xc0 <DELAY_us>

0000032c <I2C_Write>:


 ***************************************************************************************************/
void I2C_Write(uint8_t v_i2cData_u8)
{
    TWDR = v_i2cData_u8 ;
     32c:	83 b9       	out	0x03, r24	; 3
    TWCR = ((1<< TWINT) | (1<<TWEN));
     32e:	84 e8       	ldi	r24, 0x84	; 132
     330:	86 bf       	out	0x36, r24	; 54
    while (!(TWCR & (1 <<TWINT)));
     332:	06 b6       	in	r0, 0x36	; 54
     334:	07 fe       	sbrs	r0, 7
     336:	fd cf       	rjmp	.-6      	; 0x332 <I2C_Write+0x6>
}
     338:	08 95       	ret

0000033a <I2C_Read>:


***************************************************************************************************/
uint8_t I2C_Read(uint8_t v_ackOption_u8)
{
    TWCR = ((1<< TWINT) | (1<<TWEN) | (v_ackOption_u8<<TWEA));
     33a:	20 e4       	ldi	r18, 0x40	; 64
     33c:	82 9f       	mul	r24, r18
     33e:	c0 01       	movw	r24, r0
     340:	11 24       	eor	r1, r1
     342:	84 68       	ori	r24, 0x84	; 132
     344:	86 bf       	out	0x36, r24	; 54
    while ( !(TWCR & (1 <<TWINT)));
     346:	06 b6       	in	r0, 0x36	; 54
     348:	07 fe       	sbrs	r0, 7
     34a:	fd cf       	rjmp	.-6      	; 0x346 <I2C_Read+0xc>
    return TWDR;
     34c:	83 b1       	in	r24, 0x03	; 3
}
     34e:	08 95       	ret

00000350 <KEYPAD_Init>:
        gpioPins_et row_3, 
        gpioPins_et col_0,
        gpioPins_et col_1, 
        gpioPins_et col_2,
        gpioPins_et col_3 )
{
     350:	af 92       	push	r10
     352:	cf 92       	push	r12
     354:	ef 92       	push	r14
     356:	0f 93       	push	r16
     358:	1f 93       	push	r17
     35a:	cf 93       	push	r28
     35c:	df 93       	push	r29
    uint8_t i;

    A_RowsPins_U8[0] = row_0;
     35e:	80 93 f6 03 	sts	0x03F6, r24
    A_RowsPins_U8[1] = row_1;
     362:	60 93 f7 03 	sts	0x03F7, r22
    A_RowsPins_U8[2] = row_2;
     366:	40 93 f8 03 	sts	0x03F8, r20
    A_RowsPins_U8[3] = row_3;
     36a:	20 93 f9 03 	sts	0x03F9, r18

    A_ColsPins_U8[0] = col_0;
     36e:	00 93 f2 03 	sts	0x03F2, r16
    A_ColsPins_U8[1] = col_1;
     372:	e0 92 f3 03 	sts	0x03F3, r14
    A_ColsPins_U8[2] = col_2;
     376:	c0 92 f4 03 	sts	0x03F4, r12
    A_ColsPins_U8[3] = col_3;
     37a:	a0 92 f5 03 	sts	0x03F5, r10
     37e:	c6 ef       	ldi	r28, 0xF6	; 246
     380:	d3 e0       	ldi	r29, 0x03	; 3
     382:	1c 2f       	mov	r17, r28
     384:	1c 5f       	subi	r17, 0xFC	; 252

    for(i=0;i<C_MaxRows_U8;i++)
    {
        GPIO_PinDirection(A_RowsPins_U8[i],OUTPUT);
     386:	61 e0       	ldi	r22, 0x01	; 1
     388:	89 91       	ld	r24, Y+
     38a:	0e 94 83 00 	call	0x106	; 0x106 <GPIO_PinDirection>
    A_ColsPins_U8[0] = col_0;
    A_ColsPins_U8[1] = col_1;
    A_ColsPins_U8[2] = col_2;
    A_ColsPins_U8[3] = col_3;

    for(i=0;i<C_MaxRows_U8;i++)
     38e:	1c 13       	cpse	r17, r28
     390:	fa cf       	rjmp	.-12     	; 0x386 <KEYPAD_Init+0x36>
     392:	c2 ef       	ldi	r28, 0xF2	; 242
     394:	d3 e0       	ldi	r29, 0x03	; 3
     396:	1c 2f       	mov	r17, r28
     398:	1c 5f       	subi	r17, 0xFC	; 252
        GPIO_PinDirection(A_RowsPins_U8[i],OUTPUT);
    }

    for(i=0;i<C_MaxCols_U8;i++)
    {
        GPIO_PinDirection(A_ColsPins_U8[i],INPUT);
     39a:	60 e0       	ldi	r22, 0x00	; 0
     39c:	89 91       	ld	r24, Y+
     39e:	0e 94 83 00 	call	0x106	; 0x106 <GPIO_PinDirection>
    for(i=0;i<C_MaxRows_U8;i++)
    {
        GPIO_PinDirection(A_RowsPins_U8[i],OUTPUT);
    }

    for(i=0;i<C_MaxCols_U8;i++)
     3a2:	1c 13       	cpse	r17, r28
     3a4:	fa cf       	rjmp	.-12     	; 0x39a <KEYPAD_Init+0x4a>
    {
        GPIO_PinDirection(A_ColsPins_U8[i],INPUT);
    }
}
     3a6:	df 91       	pop	r29
     3a8:	cf 91       	pop	r28
     3aa:	1f 91       	pop	r17
     3ac:	0f 91       	pop	r16
     3ae:	ef 90       	pop	r14
     3b0:	cf 90       	pop	r12
     3b2:	af 90       	pop	r10
     3b4:	08 95       	ret

000003b6 <KEYPAD_GetKey>:
				3.Scan all the rows one at a time for the pressed key.
				4.Decodes the key pressed depending on ROW-COL combination and returns its
				  ASCII value.
 ***************************************************************************************************/
uint8_t KEYPAD_GetKey(void)
{
     3b6:	af 92       	push	r10
     3b8:	bf 92       	push	r11
     3ba:	cf 92       	push	r12
     3bc:	df 92       	push	r13
     3be:	ef 92       	push	r14
     3c0:	ff 92       	push	r15
     3c2:	0f 93       	push	r16
     3c4:	1f 93       	push	r17
     3c6:	cf 93       	push	r28
     3c8:	df 93       	push	r29
     3ca:	76 ef       	ldi	r23, 0xF6	; 246
     3cc:	e7 2e       	mov	r14, r23
     3ce:	73 e0       	ldi	r23, 0x03	; 3
     3d0:	f7 2e       	mov	r15, r23
     3d2:	e7 01       	movw	r28, r14
     3d4:	14 e0       	ldi	r17, 0x04	; 4
     3d6:	1e 0d       	add	r17, r14

    uint8_t i,v_keyStatus_u8;

    for (i=0;i<C_MaxRows_U8;i++)
    {
        GPIO_PinWrite(A_RowsPins_U8[i],LOW); 
     3d8:	60 e0       	ldi	r22, 0x00	; 0
     3da:	89 91       	ld	r24, Y+
     3dc:	0e 94 f5 00 	call	0x1ea	; 0x1ea <GPIO_PinWrite>
static void keypad_WaitForKeyRelease(void)
{

    uint8_t i,v_keyStatus_u8;

    for (i=0;i<C_MaxRows_U8;i++)
     3e0:	1c 13       	cpse	r17, r28
     3e2:	fa cf       	rjmp	.-12     	; 0x3d8 <KEYPAD_GetKey+0x22>
     3e4:	82 ef       	ldi	r24, 0xF2	; 242
     3e6:	93 e0       	ldi	r25, 0x03	; 3
     3e8:	d4 e0       	ldi	r29, 0x04	; 4
     3ea:	d8 0f       	add	r29, r24
     3ec:	cd 2f       	mov	r28, r29
				3.Scan all the rows one at a time for the pressed key.
				4.Decodes the key pressed depending on ROW-COL combination and returns its
				  ASCII value.
 ***************************************************************************************************/
uint8_t KEYPAD_GetKey(void)
{
     3ee:	62 ef       	ldi	r22, 0xF2	; 242
     3f0:	c6 2e       	mov	r12, r22
     3f2:	63 e0       	ldi	r22, 0x03	; 3
     3f4:	d6 2e       	mov	r13, r22

    do
    {
        do
        {
            v_keyStatus_u8 = 1;
     3f6:	01 e0       	ldi	r16, 0x01	; 1
            for(i=0; i<C_MaxCols_U8; i++)
            {
                v_keyStatus_u8 &= GPIO_PinRead(A_ColsPins_U8[i]);
     3f8:	f6 01       	movw	r30, r12
     3fa:	81 91       	ld	r24, Z+
     3fc:	6f 01       	movw	r12, r30
     3fe:	0e 94 67 01 	call	0x2ce	; 0x2ce <GPIO_PinRead>
     402:	08 23       	and	r16, r24
    do
    {
        do
        {
            v_keyStatus_u8 = 1;
            for(i=0; i<C_MaxCols_U8; i++)
     404:	dc 11       	cpse	r29, r12
     406:	f8 cf       	rjmp	.-16     	; 0x3f8 <KEYPAD_GetKey+0x42>
            {
                v_keyStatus_u8 &= GPIO_PinRead(A_ColsPins_U8[i]);
            } 
        }while(v_keyStatus_u8 == 0);
     408:	91 f3       	breq	.-28     	; 0x3ee <KEYPAD_GetKey+0x38>

        DELAY_us(C_DebounceTimeInMicroSecond_U16);
     40a:	8a e0       	ldi	r24, 0x0A	; 10
     40c:	90 e0       	ldi	r25, 0x00	; 0
     40e:	0e 94 60 00 	call	0xc0	; 0xc0 <DELAY_us>
     412:	52 ef       	ldi	r21, 0xF2	; 242
     414:	c5 2e       	mov	r12, r21
     416:	53 e0       	ldi	r21, 0x03	; 3
     418:	d5 2e       	mov	r13, r21

        v_keyStatus_u8 = 1;
     41a:	01 e0       	ldi	r16, 0x01	; 1
        for(i=0; i<C_MaxCols_U8; i++)
        {
            v_keyStatus_u8 &= GPIO_PinRead(A_ColsPins_U8[i]);
     41c:	f6 01       	movw	r30, r12
     41e:	81 91       	ld	r24, Z+
     420:	6f 01       	movw	r12, r30
     422:	0e 94 67 01 	call	0x2ce	; 0x2ce <GPIO_PinRead>
     426:	08 23       	and	r16, r24
        }while(v_keyStatus_u8 == 0);

        DELAY_us(C_DebounceTimeInMicroSecond_U16);

        v_keyStatus_u8 = 1;
        for(i=0; i<C_MaxCols_U8; i++)
     428:	cc 11       	cpse	r28, r12
     42a:	f8 cf       	rjmp	.-16     	; 0x41c <KEYPAD_GetKey+0x66>
        {
            v_keyStatus_u8 &= GPIO_PinRead(A_ColsPins_U8[i]);
        } 
    }while(v_keyStatus_u8 == 0);
     42c:	01 f3       	breq	.-64     	; 0x3ee <KEYPAD_GetKey+0x38>
     42e:	46 ef       	ldi	r20, 0xF6	; 246
     430:	c4 2e       	mov	r12, r20
     432:	43 e0       	ldi	r20, 0x03	; 3
     434:	d4 2e       	mov	r13, r20
{
    uint8_t i,v_keyStatus_u8;

    for (i=0;i<C_MaxRows_U8;i++)
    {
        GPIO_PinWrite(A_RowsPins_U8[i],LOW); 
     436:	60 e0       	ldi	r22, 0x00	; 0
     438:	f6 01       	movw	r30, r12
     43a:	81 91       	ld	r24, Z+
     43c:	6f 01       	movw	r12, r30
     43e:	0e 94 f5 00 	call	0x1ea	; 0x1ea <GPIO_PinWrite>
 ***************************************************************************************************/
static void keypad_WaitForKeyPress(void)
{
    uint8_t i,v_keyStatus_u8;

    for (i=0;i<C_MaxRows_U8;i++)
     442:	1c 11       	cpse	r17, r12
     444:	f8 cf       	rjmp	.-16     	; 0x436 <KEYPAD_GetKey+0x80>
        v_keyStatus_u8 = 1;
        for(i=0; i<C_MaxCols_U8; i++)
        {
            v_keyStatus_u8 &= GPIO_PinRead(A_ColsPins_U8[i]);
        } 
    }while(v_keyStatus_u8 == 0);
     446:	32 ef       	ldi	r19, 0xF2	; 242
     448:	c3 2e       	mov	r12, r19
     44a:	33 e0       	ldi	r19, 0x03	; 3
     44c:	d3 2e       	mov	r13, r19

    do
    {
        do
        {
            v_keyStatus_u8 = 1;
     44e:	c1 e0       	ldi	r28, 0x01	; 1
            for(i=0; i<C_MaxCols_U8; i++)
            {
                v_keyStatus_u8 &= GPIO_PinRead(A_ColsPins_U8[i]);
     450:	f6 01       	movw	r30, r12
     452:	81 91       	ld	r24, Z+
     454:	6f 01       	movw	r12, r30
     456:	0e 94 67 01 	call	0x2ce	; 0x2ce <GPIO_PinRead>
     45a:	c8 23       	and	r28, r24
    do
    {
        do
        {
            v_keyStatus_u8 = 1;
            for(i=0; i<C_MaxCols_U8; i++)
     45c:	dc 11       	cpse	r29, r12
     45e:	f8 cf       	rjmp	.-16     	; 0x450 <KEYPAD_GetKey+0x9a>
            {
                v_keyStatus_u8 &= GPIO_PinRead(A_ColsPins_U8[i]);
            } 
        }while(v_keyStatus_u8 != 0);
     460:	91 f7       	brne	.-28     	; 0x446 <KEYPAD_GetKey+0x90>


        DELAY_us(C_DebounceTimeInMicroSecond_U16);
     462:	8a e0       	ldi	r24, 0x0A	; 10
     464:	90 e0       	ldi	r25, 0x00	; 0
     466:	0e 94 60 00 	call	0xc0	; 0xc0 <DELAY_us>
     46a:	22 ef       	ldi	r18, 0xF2	; 242
     46c:	c2 2e       	mov	r12, r18
     46e:	23 e0       	ldi	r18, 0x03	; 3
     470:	d2 2e       	mov	r13, r18

        v_keyStatus_u8 = 1;
     472:	c1 e0       	ldi	r28, 0x01	; 1
        for(i=0; i<C_MaxCols_U8; i++)
        {
            v_keyStatus_u8 &= GPIO_PinRead(A_ColsPins_U8[i]);
     474:	f6 01       	movw	r30, r12
     476:	81 91       	ld	r24, Z+
     478:	6f 01       	movw	r12, r30
     47a:	0e 94 67 01 	call	0x2ce	; 0x2ce <GPIO_PinRead>
     47e:	c8 23       	and	r28, r24


        DELAY_us(C_DebounceTimeInMicroSecond_U16);

        v_keyStatus_u8 = 1;
        for(i=0; i<C_MaxCols_U8; i++)
     480:	dc 11       	cpse	r29, r12
     482:	f8 cf       	rjmp	.-16     	; 0x474 <KEYPAD_GetKey+0xbe>
        {
            v_keyStatus_u8 &= GPIO_PinRead(A_ColsPins_U8[i]);
        } 
    }while(v_keyStatus_u8 != 0);
     484:	01 f7       	brne	.-64     	; 0x446 <KEYPAD_GetKey+0x90>
     486:	c6 ef       	ldi	r28, 0xF6	; 246
     488:	d3 e0       	ldi	r29, 0x03	; 3
    keypad_WaitForKeyRelease();
    keypad_WaitForKeyPress();

    for (i=0;i<C_MaxRows_U8;i++)
    {
        GPIO_PinWrite(A_RowsPins_U8[i],HIGH); 
     48a:	61 e0       	ldi	r22, 0x01	; 1
     48c:	89 91       	ld	r24, Y+
     48e:	0e 94 f5 00 	call	0x1ea	; 0x1ea <GPIO_PinWrite>


    keypad_WaitForKeyRelease();
    keypad_WaitForKeyPress();

    for (i=0;i<C_MaxRows_U8;i++)
     492:	1c 13       	cpse	r17, r28
     494:	fa cf       	rjmp	.-12     	; 0x48a <KEYPAD_GetKey+0xd4>
     496:	00 e0       	ldi	r16, 0x00	; 0
     498:	10 e0       	ldi	r17, 0x00	; 0
     49a:	57 01       	movw	r10, r14
        GPIO_PinWrite(A_RowsPins_U8[i],HIGH); 
    }

    for (i=0;(i<C_MaxRows_U8);i++)
    {
        GPIO_PinWrite(A_RowsPins_U8[i],LOW);
     49c:	60 e0       	ldi	r22, 0x00	; 0
     49e:	f7 01       	movw	r30, r14
     4a0:	80 81       	ld	r24, Z
     4a2:	0e 94 f5 00 	call	0x1ea	; 0x1ea <GPIO_PinWrite>
     4a6:	92 ef       	ldi	r25, 0xF2	; 242
     4a8:	c9 2e       	mov	r12, r25
     4aa:	93 e0       	ldi	r25, 0x03	; 3
     4ac:	d9 2e       	mov	r13, r25
     4ae:	c0 e0       	ldi	r28, 0x00	; 0
     4b0:	d0 e0       	ldi	r29, 0x00	; 0

        for(j=0; (j<C_MaxCols_U8); j++)
        {
            if(GPIO_PinRead(A_ColsPins_U8[j]) == 0)
     4b2:	f6 01       	movw	r30, r12
     4b4:	81 91       	ld	r24, Z+
     4b6:	6f 01       	movw	r12, r30
     4b8:	0e 94 67 01 	call	0x2ce	; 0x2ce <GPIO_PinRead>
     4bc:	88 23       	and	r24, r24
     4be:	99 f0       	breq	.+38     	; 0x4e6 <KEYPAD_GetKey+0x130>
     4c0:	21 96       	adiw	r28, 0x01	; 1

    for (i=0;(i<C_MaxRows_U8);i++)
    {
        GPIO_PinWrite(A_RowsPins_U8[i],LOW);

        for(j=0; (j<C_MaxCols_U8); j++)
     4c2:	c4 30       	cpi	r28, 0x04	; 4
     4c4:	d1 05       	cpc	r29, r1
     4c6:	a9 f7       	brne	.-22     	; 0x4b2 <KEYPAD_GetKey+0xfc>
     4c8:	ff ef       	ldi	r31, 0xFF	; 255
     4ca:	ef 1a       	sub	r14, r31
     4cc:	ff 0a       	sbc	r15, r31
        if(v_KeyPressed_u8 ==1)
        {
            break;
        }

        GPIO_PinWrite(A_RowsPins_U8[i],HIGH);
     4ce:	61 e0       	ldi	r22, 0x01	; 1
     4d0:	f5 01       	movw	r30, r10
     4d2:	80 81       	ld	r24, Z
     4d4:	0e 94 f5 00 	call	0x1ea	; 0x1ea <GPIO_PinWrite>
     4d8:	0f 5f       	subi	r16, 0xFF	; 255
     4da:	1f 4f       	sbci	r17, 0xFF	; 255
    for (i=0;i<C_MaxRows_U8;i++)
    {
        GPIO_PinWrite(A_RowsPins_U8[i],HIGH); 
    }

    for (i=0;(i<C_MaxRows_U8);i++)
     4dc:	04 30       	cpi	r16, 0x04	; 4
     4de:	11 05       	cpc	r17, r1
     4e0:	e1 f6       	brne	.-72     	; 0x49a <KEYPAD_GetKey+0xe4>
    }

    if(i<C_MaxRows_U8)
        v_KeyPressed_u8 = A_KeyLookUptable_U8[i][j];
    else
        v_KeyPressed_u8 = C_DefaultKey_U8;
     4e2:	88 e7       	ldi	r24, 0x78	; 120
     4e4:	09 c0       	rjmp	.+18     	; 0x4f8 <KEYPAD_GetKey+0x142>

        GPIO_PinWrite(A_RowsPins_U8[i],HIGH);
    }

    if(i<C_MaxRows_U8)
        v_KeyPressed_u8 = A_KeyLookUptable_U8[i][j];
     4e6:	00 0f       	add	r16, r16
     4e8:	11 1f       	adc	r17, r17
     4ea:	00 0f       	add	r16, r16
     4ec:	11 1f       	adc	r17, r17
     4ee:	c0 0f       	add	r28, r16
     4f0:	d1 1f       	adc	r29, r17
     4f2:	c0 5a       	subi	r28, 0xA0	; 160
     4f4:	df 4f       	sbci	r29, 0xFF	; 255
     4f6:	88 81       	ld	r24, Y
    else
        v_KeyPressed_u8 = C_DefaultKey_U8;


    return v_KeyPressed_u8;
}
     4f8:	df 91       	pop	r29
     4fa:	cf 91       	pop	r28
     4fc:	1f 91       	pop	r17
     4fe:	0f 91       	pop	r16
     500:	ff 90       	pop	r15
     502:	ef 90       	pop	r14
     504:	df 90       	pop	r13
     506:	cf 90       	pop	r12
     508:	bf 90       	pop	r11
     50a:	af 90       	pop	r10
     50c:	08 95       	ret

0000050e <lcd_SendHigherNibble>:
 * Return value    : none

 * description : This functions is used to send the higher nibble of the data to LCD in 4-bit mode
**************************************************************************************************/
static void lcd_SendHigherNibble(uint8_t dataByte)
{
     50e:	0f 93       	push	r16
     510:	1f 93       	push	r17
     512:	cf 93       	push	r28
     514:	c8 2f       	mov	r28, r24
    GPIO_PinWrite(LCDConfig.D4,util_IsBitSet(dataByte,4));
     516:	84 fb       	bst	r24, 4
     518:	66 27       	eor	r22, r22
     51a:	60 f9       	bld	r22, 0
     51c:	0a ef       	ldi	r16, 0xFA	; 250
     51e:	13 e0       	ldi	r17, 0x03	; 3
     520:	f8 01       	movw	r30, r16
     522:	82 85       	ldd	r24, Z+10	; 0x0a
     524:	0e 94 f5 00 	call	0x1ea	; 0x1ea <GPIO_PinWrite>
    GPIO_PinWrite(LCDConfig.D5,util_IsBitSet(dataByte,5));
     528:	c5 fb       	bst	r28, 5
     52a:	66 27       	eor	r22, r22
     52c:	60 f9       	bld	r22, 0
     52e:	f8 01       	movw	r30, r16
     530:	83 85       	ldd	r24, Z+11	; 0x0b
     532:	0e 94 f5 00 	call	0x1ea	; 0x1ea <GPIO_PinWrite>
    GPIO_PinWrite(LCDConfig.D6,util_IsBitSet(dataByte,6));
     536:	c6 fb       	bst	r28, 6
     538:	66 27       	eor	r22, r22
     53a:	60 f9       	bld	r22, 0
     53c:	f8 01       	movw	r30, r16
     53e:	84 85       	ldd	r24, Z+12	; 0x0c
     540:	0e 94 f5 00 	call	0x1ea	; 0x1ea <GPIO_PinWrite>
    GPIO_PinWrite(LCDConfig.D7,util_IsBitSet(dataByte,7));
     544:	6c 2f       	mov	r22, r28
     546:	66 1f       	adc	r22, r22
     548:	66 27       	eor	r22, r22
     54a:	66 1f       	adc	r22, r22
     54c:	f8 01       	movw	r30, r16
     54e:	85 85       	ldd	r24, Z+13	; 0x0d
}
     550:	cf 91       	pop	r28
     552:	1f 91       	pop	r17
     554:	0f 91       	pop	r16
static void lcd_SendHigherNibble(uint8_t dataByte)
{
    GPIO_PinWrite(LCDConfig.D4,util_IsBitSet(dataByte,4));
    GPIO_PinWrite(LCDConfig.D5,util_IsBitSet(dataByte,5));
    GPIO_PinWrite(LCDConfig.D6,util_IsBitSet(dataByte,6));
    GPIO_PinWrite(LCDConfig.D7,util_IsBitSet(dataByte,7));
     556:	0c 94 f5 00 	jmp	0x1ea	; 0x1ea <GPIO_PinWrite>

0000055a <lcd_SendCmdSignals>:
 * Return value    : none

 * description : This functions generates the signals for sending the v_lcdCmd_u8 to LCD
**************************************************************************************************/
static void lcd_SendCmdSignals(void)
{
     55a:	cf 93       	push	r28
     55c:	df 93       	push	r29
     GPIO_PinWrite(LCDConfig.RS,0);
     55e:	ca ef       	ldi	r28, 0xFA	; 250
     560:	d3 e0       	ldi	r29, 0x03	; 3
     562:	60 e0       	ldi	r22, 0x00	; 0
     564:	8b 81       	ldd	r24, Y+3	; 0x03
     566:	0e 94 f5 00 	call	0x1ea	; 0x1ea <GPIO_PinWrite>
     GPIO_PinWrite(LCDConfig.RW,0);
     56a:	60 e0       	ldi	r22, 0x00	; 0
     56c:	8c 81       	ldd	r24, Y+4	; 0x04
     56e:	0e 94 f5 00 	call	0x1ea	; 0x1ea <GPIO_PinWrite>
     GPIO_PinWrite(LCDConfig.EN,1);
     572:	61 e0       	ldi	r22, 0x01	; 1
     574:	8d 81       	ldd	r24, Y+5	; 0x05
     576:	0e 94 f5 00 	call	0x1ea	; 0x1ea <GPIO_PinWrite>
     DELAY_us(10);
     57a:	8a e0       	ldi	r24, 0x0A	; 10
     57c:	90 e0       	ldi	r25, 0x00	; 0
     57e:	0e 94 60 00 	call	0xc0	; 0xc0 <DELAY_us>
     GPIO_PinWrite(LCDConfig.EN,0);
     582:	60 e0       	ldi	r22, 0x00	; 0
     584:	8d 81       	ldd	r24, Y+5	; 0x05
  
}
     586:	df 91       	pop	r29
     588:	cf 91       	pop	r28
{
     GPIO_PinWrite(LCDConfig.RS,0);
     GPIO_PinWrite(LCDConfig.RW,0);
     GPIO_PinWrite(LCDConfig.EN,1);
     DELAY_us(10);
     GPIO_PinWrite(LCDConfig.EN,0);
     58a:	0c 94 f5 00 	jmp	0x1ea	; 0x1ea <GPIO_PinWrite>

0000058e <lcd_SendLowerNibble>:
 * Return value    : none

 * description : This functions is used to send the lower nibble of the data to LCD
**************************************************************************************************/
static void lcd_SendLowerNibble(uint8_t dataByte)
{
     58e:	0f 93       	push	r16
     590:	1f 93       	push	r17
     592:	cf 93       	push	r28
     594:	c8 2f       	mov	r28, r24
    GPIO_PinWrite(LCDConfig.D0,util_IsBitSet(dataByte,0));
     596:	68 2f       	mov	r22, r24
     598:	61 70       	andi	r22, 0x01	; 1
     59a:	0a ef       	ldi	r16, 0xFA	; 250
     59c:	13 e0       	ldi	r17, 0x03	; 3
     59e:	f8 01       	movw	r30, r16
     5a0:	86 81       	ldd	r24, Z+6	; 0x06
     5a2:	0e 94 f5 00 	call	0x1ea	; 0x1ea <GPIO_PinWrite>
    GPIO_PinWrite(LCDConfig.D1,util_IsBitSet(dataByte,1));
     5a6:	c1 fb       	bst	r28, 1
     5a8:	66 27       	eor	r22, r22
     5aa:	60 f9       	bld	r22, 0
     5ac:	f8 01       	movw	r30, r16
     5ae:	87 81       	ldd	r24, Z+7	; 0x07
     5b0:	0e 94 f5 00 	call	0x1ea	; 0x1ea <GPIO_PinWrite>
    GPIO_PinWrite(LCDConfig.D2,util_IsBitSet(dataByte,2));
     5b4:	c2 fb       	bst	r28, 2
     5b6:	66 27       	eor	r22, r22
     5b8:	60 f9       	bld	r22, 0
     5ba:	f8 01       	movw	r30, r16
     5bc:	80 85       	ldd	r24, Z+8	; 0x08
     5be:	0e 94 f5 00 	call	0x1ea	; 0x1ea <GPIO_PinWrite>
    GPIO_PinWrite(LCDConfig.D3,util_IsBitSet(dataByte,3));
     5c2:	c3 fb       	bst	r28, 3
     5c4:	66 27       	eor	r22, r22
     5c6:	60 f9       	bld	r22, 0
     5c8:	f8 01       	movw	r30, r16
     5ca:	81 85       	ldd	r24, Z+9	; 0x09
}
     5cc:	cf 91       	pop	r28
     5ce:	1f 91       	pop	r17
     5d0:	0f 91       	pop	r16
static void lcd_SendLowerNibble(uint8_t dataByte)
{
    GPIO_PinWrite(LCDConfig.D0,util_IsBitSet(dataByte,0));
    GPIO_PinWrite(LCDConfig.D1,util_IsBitSet(dataByte,1));
    GPIO_PinWrite(LCDConfig.D2,util_IsBitSet(dataByte,2));
    GPIO_PinWrite(LCDConfig.D3,util_IsBitSet(dataByte,3));
     5d2:	0c 94 f5 00 	jmp	0x1ea	; 0x1ea <GPIO_PinWrite>

000005d6 <lcd_SendDataSignals>:
 * Return value    : none

 * description : This functions generates the signals for sending the Data to LCD
**************************************************************************************************/
static void lcd_SendDataSignals(void)
{
     5d6:	cf 93       	push	r28
     5d8:	df 93       	push	r29
     GPIO_PinWrite(LCDConfig.RS,1);
     5da:	ca ef       	ldi	r28, 0xFA	; 250
     5dc:	d3 e0       	ldi	r29, 0x03	; 3
     5de:	61 e0       	ldi	r22, 0x01	; 1
     5e0:	8b 81       	ldd	r24, Y+3	; 0x03
     5e2:	0e 94 f5 00 	call	0x1ea	; 0x1ea <GPIO_PinWrite>
     GPIO_PinWrite(LCDConfig.RW,0);
     5e6:	60 e0       	ldi	r22, 0x00	; 0
     5e8:	8c 81       	ldd	r24, Y+4	; 0x04
     5ea:	0e 94 f5 00 	call	0x1ea	; 0x1ea <GPIO_PinWrite>
     GPIO_PinWrite(LCDConfig.EN,1);
     5ee:	61 e0       	ldi	r22, 0x01	; 1
     5f0:	8d 81       	ldd	r24, Y+5	; 0x05
     5f2:	0e 94 f5 00 	call	0x1ea	; 0x1ea <GPIO_PinWrite>
     DELAY_us(10);
     5f6:	8a e0       	ldi	r24, 0x0A	; 10
     5f8:	90 e0       	ldi	r25, 0x00	; 0
     5fa:	0e 94 60 00 	call	0xc0	; 0xc0 <DELAY_us>
     GPIO_PinWrite(LCDConfig.EN,0);
     5fe:	60 e0       	ldi	r22, 0x00	; 0
     600:	8d 81       	ldd	r24, Y+5	; 0x05
}
     602:	df 91       	pop	r29
     604:	cf 91       	pop	r28
{
     GPIO_PinWrite(LCDConfig.RS,1);
     GPIO_PinWrite(LCDConfig.RW,0);
     GPIO_PinWrite(LCDConfig.EN,1);
     DELAY_us(10);
     GPIO_PinWrite(LCDConfig.EN,0);
     606:	0c 94 f5 00 	jmp	0x1ea	; 0x1ea <GPIO_PinWrite>

0000060a <lcd_BusyCheck>:
 * description : This functions is used check whether LCD is busy.
                 It waits till the LCD is busy by polling the LCD busy flag.
                 After completing the previous operation, LCDs clears its internal busy flag.
**************************************************************************************************/
static void lcd_BusyCheck(void)
{
     60a:	cf 93       	push	r28
    uint8_t busyflag;
 
  if(LCDConfig.RW != P_NC)                         //Perform Busy check if RW pin is used
     60c:	80 91 fe 03 	lds	r24, 0x03FE
     610:	8f 3f       	cpi	r24, 0xFF	; 255
     612:	09 f4       	brne	.+2      	; 0x616 <lcd_BusyCheck+0xc>
     614:	44 c0       	rjmp	.+136    	; 0x69e <lcd_BusyCheck+0x94>
   {
    GPIO_PinDirection(LCDConfig.D7,INPUT); // Configure busy pin as input
     616:	60 e0       	ldi	r22, 0x00	; 0
     618:	80 91 07 04 	lds	r24, 0x0407
     61c:	0e 94 83 00 	call	0x106	; 0x106 <GPIO_PinDirection>
    GPIO_PinWrite(LCDConfig.RS,0);           // Select the Command Register by pulling RS LOW
     620:	60 e0       	ldi	r22, 0x00	; 0
     622:	80 91 fd 03 	lds	r24, 0x03FD
     626:	0e 94 f5 00 	call	0x1ea	; 0x1ea <GPIO_PinWrite>
    GPIO_PinWrite(LCDConfig.RW,1);           // Select the Read Operation for busy flag by setting RW
     62a:	61 e0       	ldi	r22, 0x01	; 1
     62c:	80 91 fe 03 	lds	r24, 0x03FE
     630:	0e 94 f5 00 	call	0x1ea	; 0x1ea <GPIO_PinWrite>
    do
    {

        GPIO_PinWrite(LCDConfig.EN,0);
     634:	60 e0       	ldi	r22, 0x00	; 0
     636:	80 91 ff 03 	lds	r24, 0x03FF
     63a:	0e 94 f5 00 	call	0x1ea	; 0x1ea <GPIO_PinWrite>
        DELAY_us(10);
     63e:	8a e0       	ldi	r24, 0x0A	; 10
     640:	90 e0       	ldi	r25, 0x00	; 0
     642:	0e 94 60 00 	call	0xc0	; 0xc0 <DELAY_us>
        GPIO_PinWrite(LCDConfig.EN,1); 
     646:	61 e0       	ldi	r22, 0x01	; 1
     648:	80 91 ff 03 	lds	r24, 0x03FF
     64c:	0e 94 f5 00 	call	0x1ea	; 0x1ea <GPIO_PinWrite>
        DELAY_us(10);
     650:	8a e0       	ldi	r24, 0x0A	; 10
     652:	90 e0       	ldi	r25, 0x00	; 0
     654:	0e 94 60 00 	call	0xc0	; 0xc0 <DELAY_us>
        busyflag = GPIO_PinRead(LCDConfig.D7);
     658:	80 91 07 04 	lds	r24, 0x0407
     65c:	0e 94 67 01 	call	0x2ce	; 0x2ce <GPIO_PinRead>
     660:	c8 2f       	mov	r28, r24


        if(LCDConfig.v_LcdMode_U8 == 4)
     662:	80 91 fc 03 	lds	r24, 0x03FC
     666:	84 30       	cpi	r24, 0x04	; 4
     668:	91 f4       	brne	.+36     	; 0x68e <lcd_BusyCheck+0x84>
        {
            /* Perform extra dummy read for 4-bit */            
            GPIO_PinWrite(LCDConfig.EN,0);
     66a:	60 e0       	ldi	r22, 0x00	; 0
     66c:	80 91 ff 03 	lds	r24, 0x03FF
     670:	0e 94 f5 00 	call	0x1ea	; 0x1ea <GPIO_PinWrite>
            DELAY_us(10);
     674:	8a e0       	ldi	r24, 0x0A	; 10
     676:	90 e0       	ldi	r25, 0x00	; 0
     678:	0e 94 60 00 	call	0xc0	; 0xc0 <DELAY_us>
            GPIO_PinWrite(LCDConfig.EN,1); 
     67c:	61 e0       	ldi	r22, 0x01	; 1
     67e:	80 91 ff 03 	lds	r24, 0x03FF
     682:	0e 94 f5 00 	call	0x1ea	; 0x1ea <GPIO_PinWrite>
            DELAY_us(10);
     686:	8a e0       	ldi	r24, 0x0A	; 10
     688:	90 e0       	ldi	r25, 0x00	; 0
     68a:	0e 94 60 00 	call	0xc0	; 0xc0 <DELAY_us>
        }    
    }while(busyflag!=0);
     68e:	c1 11       	cpse	r28, r1
     690:	d1 cf       	rjmp	.-94     	; 0x634 <lcd_BusyCheck+0x2a>

    GPIO_PinDirection(LCDConfig.D7,OUTPUT); // Configure busy pin as Output
     692:	61 e0       	ldi	r22, 0x01	; 1
     694:	80 91 07 04 	lds	r24, 0x0407
 {
    /* Busy flag cannot be read as RW is not available hence Extra delay of 1ms is added 
      to ensure the LCD completes previous operation and ready to receive new commands/data */
    DELAY_ms(1);  
 }
}
     698:	cf 91       	pop	r28
            GPIO_PinWrite(LCDConfig.EN,1); 
            DELAY_us(10);
        }    
    }while(busyflag!=0);

    GPIO_PinDirection(LCDConfig.D7,OUTPUT); // Configure busy pin as Output
     69a:	0c 94 83 00 	jmp	0x106	; 0x106 <GPIO_PinDirection>
  }
else
 {
    /* Busy flag cannot be read as RW is not available hence Extra delay of 1ms is added 
      to ensure the LCD completes previous operation and ready to receive new commands/data */
    DELAY_ms(1);  
     69e:	81 e0       	ldi	r24, 0x01	; 1
     6a0:	90 e0       	ldi	r25, 0x00	; 0
 }
}
     6a2:	cf 91       	pop	r28
  }
else
 {
    /* Busy flag cannot be read as RW is not available hence Extra delay of 1ms is added 
      to ensure the LCD completes previous operation and ready to receive new commands/data */
    DELAY_ms(1);  
     6a4:	0c 94 69 00 	jmp	0xd2	; 0xd2 <DELAY_ms>

000006a8 <LCD_SetUp>:
               gpioPins_et D3,
               gpioPins_et D4,
               gpioPins_et D5,
               gpioPins_et D6,
               gpioPins_et D7 )
{
     6a8:	8f 92       	push	r8
     6aa:	9f 92       	push	r9
     6ac:	af 92       	push	r10
     6ae:	bf 92       	push	r11
     6b0:	cf 92       	push	r12
     6b2:	df 92       	push	r13
     6b4:	ef 92       	push	r14
     6b6:	ff 92       	push	r15
     6b8:	0f 93       	push	r16
     6ba:	1f 93       	push	r17
     6bc:	cf 93       	push	r28
     6be:	df 93       	push	r29
     6c0:	cd b7       	in	r28, 0x3d	; 61
     6c2:	de b7       	in	r29, 0x3e	; 62
     6c4:	98 2e       	mov	r9, r24
     6c6:	b6 2e       	mov	r11, r22
     6c8:	d4 2e       	mov	r13, r20
     6ca:	ff 84       	ldd	r15, Y+15	; 0x0f
     6cc:	18 89       	ldd	r17, Y+16	; 0x10
  /* Copy the PIN numbers where the LCD is connected */
    LCDConfig.RS = RS;
     6ce:	80 93 fd 03 	sts	0x03FD, r24
    LCDConfig.RW = RW;
     6d2:	60 93 fe 03 	sts	0x03FE, r22
    LCDConfig.EN = EN;
     6d6:	40 93 ff 03 	sts	0x03FF, r20

    LCDConfig.D0 = D0;
     6da:	20 93 00 04 	sts	0x0400, r18
    LCDConfig.D1 = D1;
     6de:	00 93 01 04 	sts	0x0401, r16
    LCDConfig.D2 = D2;
     6e2:	e0 92 02 04 	sts	0x0402, r14
    LCDConfig.D3 = D3;
     6e6:	c0 92 03 04 	sts	0x0403, r12
    LCDConfig.D4 = D4;
     6ea:	a0 92 04 04 	sts	0x0404, r10
    LCDConfig.D5 = D5;
     6ee:	80 92 05 04 	sts	0x0405, r8
    LCDConfig.D6 = D6;
     6f2:	f0 92 06 04 	sts	0x0406, r15
    LCDConfig.D7 = D7;
     6f6:	10 93 07 04 	sts	0x0407, r17


    if((D0 == P_NC) || (D1 == P_NC) || (D2 == P_NC) || (D3 == P_NC))
     6fa:	2f 3f       	cpi	r18, 0xFF	; 255
     6fc:	39 f0       	breq	.+14     	; 0x70c <LCD_SetUp+0x64>
     6fe:	0f 3f       	cpi	r16, 0xFF	; 255
     700:	29 f0       	breq	.+10     	; 0x70c <LCD_SetUp+0x64>
     702:	8f ef       	ldi	r24, 0xFF	; 255
     704:	e8 16       	cp	r14, r24
     706:	11 f0       	breq	.+4      	; 0x70c <LCD_SetUp+0x64>
     708:	c8 12       	cpse	r12, r24
     70a:	04 c0       	rjmp	.+8      	; 0x714 <LCD_SetUp+0x6c>
    {
        LCDConfig.v_LcdMode_U8 = 4; // Select 4-bit mode as D0-D3 are not used(P_NC)
     70c:	84 e0       	ldi	r24, 0x04	; 4
     70e:	80 93 fc 03 	sts	0x03FC, r24
     712:	13 c0       	rjmp	.+38     	; 0x73a <LCD_SetUp+0x92>
    }
    else
    {
        LCDConfig.v_LcdMode_U8 = 8; // 8-bit mode configure D0-D3 as output.      
     714:	88 e0       	ldi	r24, 0x08	; 8
     716:	80 93 fc 03 	sts	0x03FC, r24
        GPIO_PinDirection(D0,OUTPUT);
     71a:	61 e0       	ldi	r22, 0x01	; 1
     71c:	82 2f       	mov	r24, r18
     71e:	0e 94 83 00 	call	0x106	; 0x106 <GPIO_PinDirection>
        GPIO_PinDirection(D1,OUTPUT);
     722:	61 e0       	ldi	r22, 0x01	; 1
     724:	80 2f       	mov	r24, r16
     726:	0e 94 83 00 	call	0x106	; 0x106 <GPIO_PinDirection>
        GPIO_PinDirection(D2,OUTPUT);
     72a:	61 e0       	ldi	r22, 0x01	; 1
     72c:	8e 2d       	mov	r24, r14
     72e:	0e 94 83 00 	call	0x106	; 0x106 <GPIO_PinDirection>
        GPIO_PinDirection(D3,OUTPUT);
     732:	61 e0       	ldi	r22, 0x01	; 1
     734:	8c 2d       	mov	r24, r12
     736:	0e 94 83 00 	call	0x106	; 0x106 <GPIO_PinDirection>
    }

    /* Configure RS,RW,EN, D4-D7 as Output for both 4/8-bit mode.*/
    GPIO_PinDirection(RS,OUTPUT);
     73a:	61 e0       	ldi	r22, 0x01	; 1
     73c:	89 2d       	mov	r24, r9
     73e:	0e 94 83 00 	call	0x106	; 0x106 <GPIO_PinDirection>
    GPIO_PinDirection(RW,OUTPUT);
     742:	61 e0       	ldi	r22, 0x01	; 1
     744:	8b 2d       	mov	r24, r11
     746:	0e 94 83 00 	call	0x106	; 0x106 <GPIO_PinDirection>
    GPIO_PinDirection(EN,OUTPUT);
     74a:	61 e0       	ldi	r22, 0x01	; 1
     74c:	8d 2d       	mov	r24, r13
     74e:	0e 94 83 00 	call	0x106	; 0x106 <GPIO_PinDirection>

    GPIO_PinDirection(D4,OUTPUT);
     752:	61 e0       	ldi	r22, 0x01	; 1
     754:	8a 2d       	mov	r24, r10
     756:	0e 94 83 00 	call	0x106	; 0x106 <GPIO_PinDirection>
    GPIO_PinDirection(D5,OUTPUT);
     75a:	61 e0       	ldi	r22, 0x01	; 1
     75c:	88 2d       	mov	r24, r8
     75e:	0e 94 83 00 	call	0x106	; 0x106 <GPIO_PinDirection>
    GPIO_PinDirection(D6,OUTPUT);
     762:	61 e0       	ldi	r22, 0x01	; 1
     764:	8f 2d       	mov	r24, r15
     766:	0e 94 83 00 	call	0x106	; 0x106 <GPIO_PinDirection>
    GPIO_PinDirection(D7,OUTPUT);  
     76a:	61 e0       	ldi	r22, 0x01	; 1
     76c:	81 2f       	mov	r24, r17
}
     76e:	df 91       	pop	r29
     770:	cf 91       	pop	r28
     772:	1f 91       	pop	r17
     774:	0f 91       	pop	r16
     776:	ff 90       	pop	r15
     778:	ef 90       	pop	r14
     77a:	df 90       	pop	r13
     77c:	cf 90       	pop	r12
     77e:	bf 90       	pop	r11
     780:	af 90       	pop	r10
     782:	9f 90       	pop	r9
     784:	8f 90       	pop	r8
    GPIO_PinDirection(EN,OUTPUT);

    GPIO_PinDirection(D4,OUTPUT);
    GPIO_PinDirection(D5,OUTPUT);
    GPIO_PinDirection(D6,OUTPUT);
    GPIO_PinDirection(D7,OUTPUT);  
     786:	0c 94 83 00 	jmp	0x106	; 0x106 <GPIO_PinDirection>

0000078a <LCD_CmdWrite>:
                Some of the commonly used commands are defined in lcd.h.
                For more commands refer the data sheet and send the supported command.                
                The behaviour is undefined if unsupported commands are sent.    
****************************************************************************************************/
void LCD_CmdWrite( uint8_t v_lcdCmd_u8)
{
     78a:	cf 93       	push	r28
     78c:	c8 2f       	mov	r28, r24
    lcd_BusyCheck();
     78e:	0e 94 05 03 	call	0x60a	; 0x60a <lcd_BusyCheck>
    if(LCDConfig.v_LcdMode_U8 == C_EightBitMode_U8)
     792:	80 91 fc 03 	lds	r24, 0x03FC
     796:	88 30       	cpi	r24, 0x08	; 8
     798:	21 f4       	brne	.+8      	; 0x7a2 <LCD_CmdWrite+0x18>
     {
         lcd_SendLowerNibble(v_lcdCmd_u8);
     79a:	8c 2f       	mov	r24, r28
     79c:	0e 94 c7 02 	call	0x58e	; 0x58e <lcd_SendLowerNibble>
     7a0:	07 c0       	rjmp	.+14     	; 0x7b0 <LCD_CmdWrite+0x26>
     }
     else
     {
         lcd_SendHigherNibble(v_lcdCmd_u8);
     7a2:	8c 2f       	mov	r24, r28
     7a4:	0e 94 87 02 	call	0x50e	; 0x50e <lcd_SendHigherNibble>
         lcd_SendCmdSignals();
     7a8:	0e 94 ad 02 	call	0x55a	; 0x55a <lcd_SendCmdSignals>
         v_lcdCmd_u8 = v_lcdCmd_u8 << 4;
     7ac:	c2 95       	swap	r28
     7ae:	c0 7f       	andi	r28, 0xF0	; 240
     }

     lcd_SendHigherNibble(v_lcdCmd_u8);
     7b0:	8c 2f       	mov	r24, r28
     7b2:	0e 94 87 02 	call	0x50e	; 0x50e <lcd_SendHigherNibble>
     lcd_SendCmdSignals();
}
     7b6:	cf 91       	pop	r28
         lcd_SendCmdSignals();
         v_lcdCmd_u8 = v_lcdCmd_u8 << 4;
     }

     lcd_SendHigherNibble(v_lcdCmd_u8);
     lcd_SendCmdSignals();
     7b8:	0c 94 ad 02 	jmp	0x55a	; 0x55a <lcd_SendCmdSignals>

000007bc <LCD_GoToLine>:
           C_LcdLineThree,

****************************************************************************************************/
void LCD_GoToLine(uint8_t v_lineNumber_u8)
{
    if(v_lineNumber_u8 < LCDConfig.v_MaxSupportedLines_U8)
     7bc:	90 91 fa 03 	lds	r25, 0x03FA
     7c0:	89 17       	cp	r24, r25
     7c2:	58 f4       	brcc	.+22     	; 0x7da <LCD_GoToLine+0x1e>
    {
        /* If the line number is within range then
           Move the Cursor to beginning of the specified line */
        v_LcdTrackCursorPos_U8 = 0x00;
     7c4:	10 92 08 04 	sts	0x0408, r1
        v_LcdTrackLineNum_U8 = v_lineNumber_u8;
     7c8:	80 93 09 04 	sts	0x0409, r24
        LCD_CmdWrite(ARR_LcdLineNumAddress_U8[v_lineNumber_u8]);
     7cc:	e8 2f       	mov	r30, r24
     7ce:	f0 e0       	ldi	r31, 0x00	; 0
     7d0:	e0 59       	subi	r30, 0x90	; 144
     7d2:	ff 4f       	sbci	r31, 0xFF	; 255
     7d4:	80 81       	ld	r24, Z
     7d6:	0c 94 c5 03 	jmp	0x78a	; 0x78a <LCD_CmdWrite>
     7da:	08 95       	ret

000007dc <LCD_Clear>:

 * description  :This function clears the LCD and moves the cursor to beginning of first line
****************************************************************************************************/
void LCD_Clear()
{
    LCD_CmdWrite(CMD_LCD_CLEAR);    // Clear the LCD and go to First line First Position
     7dc:	81 e0       	ldi	r24, 0x01	; 1
     7de:	0e 94 c5 03 	call	0x78a	; 0x78a <LCD_CmdWrite>
    LCD_GoToLine(C_LcdLineZero);
     7e2:	80 e0       	ldi	r24, 0x00	; 0
     7e4:	0c 94 de 03 	jmp	0x7bc	; 0x7bc <LCD_GoToLine>

000007e8 <LCD_Init>:
**************************************************************************************************/
void LCD_Init(uint8_t v_lcdNoOfLines_u8, uint8_t v_MaxCharsPerLine_u8)
{


    LCDConfig.v_MaxSupportedChars_U8 = v_MaxCharsPerLine_u8; //Maintaian the LCD type
     7e8:	60 93 fb 03 	sts	0x03FB, r22
    LCDConfig.v_MaxSupportedLines_U8 = v_lcdNoOfLines_u8;
     7ec:	80 93 fa 03 	sts	0x03FA, r24
    if(v_lcdNoOfLines_u8 > C_LcdLineTwo)
     7f0:	83 30       	cpi	r24, 0x03	; 3
     7f2:	40 f0       	brcs	.+16     	; 0x804 <LCD_Init+0x1c>
    {
        ARR_LcdLineNumAddress_U8[C_LcdLineTwo] =  0x90 + (v_MaxCharsPerLine_u8 & 0x0fu);
     7f4:	6f 70       	andi	r22, 0x0F	; 15
     7f6:	80 e9       	ldi	r24, 0x90	; 144
     7f8:	86 0f       	add	r24, r22
     7fa:	80 93 72 00 	sts	0x0072, r24
        ARR_LcdLineNumAddress_U8[C_LcdLineThree] =  0xd0 + (v_MaxCharsPerLine_u8 & 0x0fu);
     7fe:	60 53       	subi	r22, 0x30	; 48
     800:	60 93 73 00 	sts	0x0073, r22
    }

    DELAY_ms(100);
     804:	84 e6       	ldi	r24, 0x64	; 100
     806:	90 e0       	ldi	r25, 0x00	; 0
     808:	0e 94 69 00 	call	0xd2	; 0xd2 <DELAY_ms>

    if(LCDConfig.v_LcdMode_U8 == C_EightBitMode_U8)
     80c:	80 91 fc 03 	lds	r24, 0x03FC
     810:	88 30       	cpi	r24, 0x08	; 8
     812:	11 f4       	brne	.+4      	; 0x818 <LCD_Init+0x30>
    {
        LCD_CmdWrite(CMD_LCD_EIGHT_BIT_MODE); // Initialize the LCD for 8-bit 5x7 matrix type
     814:	88 e3       	ldi	r24, 0x38	; 56
     816:	27 c0       	rjmp	.+78     	; 0x866 <__stack+0x7>
    }
    else if(LCDConfig.v_LcdMode_U8 == C_FourBitMode_U8)
     818:	84 30       	cpi	r24, 0x04	; 4
     81a:	39 f5       	brne	.+78     	; 0x86a <__stack+0xb>
                 This is used only in 4-bit mode as the LCD by default boots in 8-Bit mode.
----------------------------------------------------------------------------------*/
static void lcd_Reset(void)
{
    /* LCD reset sequence for 4-bit mode, refer data sheet for more info */
    lcd_SendHigherNibble(0x30);
     81c:	80 e3       	ldi	r24, 0x30	; 48
     81e:	0e 94 87 02 	call	0x50e	; 0x50e <lcd_SendHigherNibble>
    lcd_SendCmdSignals();
     822:	0e 94 ad 02 	call	0x55a	; 0x55a <lcd_SendCmdSignals>
    DELAY_ms(100);
     826:	84 e6       	ldi	r24, 0x64	; 100
     828:	90 e0       	ldi	r25, 0x00	; 0
     82a:	0e 94 69 00 	call	0xd2	; 0xd2 <DELAY_ms>
    lcd_SendHigherNibble(0x30);
     82e:	80 e3       	ldi	r24, 0x30	; 48
     830:	0e 94 87 02 	call	0x50e	; 0x50e <lcd_SendHigherNibble>
    lcd_SendCmdSignals();
     834:	0e 94 ad 02 	call	0x55a	; 0x55a <lcd_SendCmdSignals>
    DELAY_us(200);
     838:	88 ec       	ldi	r24, 0xC8	; 200
     83a:	90 e0       	ldi	r25, 0x00	; 0
     83c:	0e 94 60 00 	call	0xc0	; 0xc0 <DELAY_us>
    lcd_SendHigherNibble(0x30);
     840:	80 e3       	ldi	r24, 0x30	; 48
     842:	0e 94 87 02 	call	0x50e	; 0x50e <lcd_SendHigherNibble>
    lcd_SendCmdSignals();
     846:	0e 94 ad 02 	call	0x55a	; 0x55a <lcd_SendCmdSignals>
    DELAY_us(200);
     84a:	88 ec       	ldi	r24, 0xC8	; 200
     84c:	90 e0       	ldi	r25, 0x00	; 0
     84e:	0e 94 60 00 	call	0xc0	; 0xc0 <DELAY_us>
    lcd_SendHigherNibble(0x20);
     852:	80 e2       	ldi	r24, 0x20	; 32
     854:	0e 94 87 02 	call	0x50e	; 0x50e <lcd_SendHigherNibble>
    lcd_SendCmdSignals();
     858:	0e 94 ad 02 	call	0x55a	; 0x55a <lcd_SendCmdSignals>
    DELAY_us(200);
     85c:	88 ec       	ldi	r24, 0xC8	; 200
     85e:	90 e0       	ldi	r25, 0x00	; 0
     860:	0e 94 60 00 	call	0xc0	; 0xc0 <DELAY_us>
        LCD_CmdWrite(CMD_LCD_EIGHT_BIT_MODE); // Initialize the LCD for 8-bit 5x7 matrix type
    }
    else if(LCDConfig.v_LcdMode_U8 == C_FourBitMode_U8)
    {
        lcd_Reset();
        LCD_CmdWrite(CMD_LCD_FOUR_BIT_MODE); // Initialize the LCD for 4-bit 5x7 matrix type 
     864:	88 e2       	ldi	r24, 0x28	; 40
     866:	0e 94 c5 03 	call	0x78a	; 0x78a <LCD_CmdWrite>
    }

    LCD_CmdWrite(CMD_DISPLAY_ON_CURSOR_ON);     // Display ON cursor ON
     86a:	8e e0       	ldi	r24, 0x0E	; 14
     86c:	0e 94 c5 03 	call	0x78a	; 0x78a <LCD_CmdWrite>
    LCD_Clear();                             // Clear the LCD and go to First line First Position
     870:	0c 94 ee 03 	jmp	0x7dc	; 0x7dc <LCD_Clear>

00000874 <LCD_GoToNextLine>:
****************************************************************************************************/
void  LCD_GoToNextLine(void)
{
    /*Increment the current line number.
      In case it exceeds the limit, rool it back to first line */
    v_LcdTrackLineNum_U8++;
     874:	80 91 09 04 	lds	r24, 0x0409
     878:	8f 5f       	subi	r24, 0xFF	; 255
     87a:	80 93 09 04 	sts	0x0409, r24
    v_LcdTrackCursorPos_U8 = 0x00;
     87e:	10 92 08 04 	sts	0x0408, r1
    if(v_LcdTrackLineNum_U8 >= LCDConfig.v_MaxSupportedLines_U8)
     882:	90 91 fa 03 	lds	r25, 0x03FA
     886:	89 17       	cp	r24, r25
     888:	10 f0       	brcs	.+4      	; 0x88e <LCD_GoToNextLine+0x1a>
        v_LcdTrackLineNum_U8 = C_LcdLineZero;
     88a:	10 92 09 04 	sts	0x0409, r1
    LCD_CmdWrite(ARR_LcdLineNumAddress_U8[v_LcdTrackLineNum_U8]);
     88e:	e0 91 09 04 	lds	r30, 0x0409
     892:	f0 e0       	ldi	r31, 0x00	; 0
     894:	e0 59       	subi	r30, 0x90	; 144
     896:	ff 4f       	sbci	r31, 0xFF	; 255
     898:	80 81       	ld	r24, Z
     89a:	0c 94 c5 03 	jmp	0x78a	; 0x78a <LCD_CmdWrite>

0000089e <LCD_DisplayChar>:
 * description  : This function sends a character to be displayed on LCD.
                  Any valid ascii value can be passed to display respective character

****************************************************************************************************/
void LCD_DisplayChar(char v_lcdData_u8)
{
     89e:	cf 93       	push	r28
     8a0:	c8 2f       	mov	r28, r24
    if((v_LcdTrackCursorPos_U8>=LCDConfig.v_MaxSupportedChars_U8) || (v_lcdData_u8=='\n'))
     8a2:	90 91 08 04 	lds	r25, 0x0408
     8a6:	80 91 fb 03 	lds	r24, 0x03FB
     8aa:	98 17       	cp	r25, r24
     8ac:	60 f4       	brcc	.+24     	; 0x8c6 <LCD_DisplayChar+0x28>
     8ae:	ca 30       	cpi	r28, 0x0A	; 10
     8b0:	51 f0       	breq	.+20     	; 0x8c6 <LCD_DisplayChar+0x28>

 * description : This functions is used to send a byte of data to LCD.                 .    
**************************************************************************************************/
static void lcd_DataWrite( uint8_t dataByte)
{
    lcd_BusyCheck();
     8b2:	0e 94 05 03 	call	0x60a	; 0x60a <lcd_BusyCheck>
    if(LCDConfig.v_LcdMode_U8 == C_EightBitMode_U8)
     8b6:	80 91 fc 03 	lds	r24, 0x03FC
     8ba:	88 30       	cpi	r24, 0x08	; 8
     8bc:	49 f4       	brne	.+18     	; 0x8d0 <LCD_DisplayChar+0x32>
     {
         lcd_SendLowerNibble(dataByte);
     8be:	8c 2f       	mov	r24, r28
     8c0:	0e 94 c7 02 	call	0x58e	; 0x58e <lcd_SendLowerNibble>
     8c4:	0c c0       	rjmp	.+24     	; 0x8de <LCD_DisplayChar+0x40>
{
    if((v_LcdTrackCursorPos_U8>=LCDConfig.v_MaxSupportedChars_U8) || (v_lcdData_u8=='\n'))
    {
        /* If the cursor has reached to end of line on page1
        OR NewLine command is issued Then Move the cursor to next line */
        LCD_GoToNextLine();
     8c6:	0e 94 3a 04 	call	0x874	; 0x874 <LCD_GoToNextLine>
    }
    if(v_lcdData_u8!='\n') /* Display the character if its not newLine Char */
     8ca:	ca 30       	cpi	r28, 0x0A	; 10
     8cc:	91 f0       	breq	.+36     	; 0x8f2 <LCD_DisplayChar+0x54>
     8ce:	f1 cf       	rjmp	.-30     	; 0x8b2 <LCD_DisplayChar+0x14>
     {
         lcd_SendLowerNibble(dataByte);
     }
     else
     {
         lcd_SendHigherNibble(dataByte);
     8d0:	8c 2f       	mov	r24, r28
     8d2:	0e 94 87 02 	call	0x50e	; 0x50e <lcd_SendHigherNibble>
         lcd_SendDataSignals();
     8d6:	0e 94 eb 02 	call	0x5d6	; 0x5d6 <lcd_SendDataSignals>
         dataByte = dataByte << 4;
     8da:	c2 95       	swap	r28
     8dc:	c0 7f       	andi	r28, 0xF0	; 240
     }

     lcd_SendHigherNibble(dataByte);
     8de:	8c 2f       	mov	r24, r28
     8e0:	0e 94 87 02 	call	0x50e	; 0x50e <lcd_SendHigherNibble>
     lcd_SendDataSignals();
     8e4:	0e 94 eb 02 	call	0x5d6	; 0x5d6 <lcd_SendDataSignals>
    }
    if(v_lcdData_u8!='\n') /* Display the character if its not newLine Char */
    {

        lcd_DataWrite(v_lcdData_u8); /* Display the data and keep track of cursor */
        v_LcdTrackCursorPos_U8++;
     8e8:	80 91 08 04 	lds	r24, 0x0408
     8ec:	8f 5f       	subi	r24, 0xFF	; 255
     8ee:	80 93 08 04 	sts	0x0408, r24
    }
}
     8f2:	cf 91       	pop	r28
     8f4:	08 95       	ret

000008f6 <LCD_DisplayString>:
                    and traverses till the end(NULL CHAR)and displays a char each time.

****************************************************************************************************/
#if (Enable_LCD_DisplayString==1)
void LCD_DisplayString(const char *ptr_stringPointer_u8)
{
     8f6:	cf 93       	push	r28
     8f8:	df 93       	push	r29
     8fa:	ec 01       	movw	r28, r24
    while((*ptr_stringPointer_u8)!=0)
     8fc:	89 91       	ld	r24, Y+
     8fe:	88 23       	and	r24, r24
     900:	19 f0       	breq	.+6      	; 0x908 <LCD_DisplayString+0x12>
        LCD_DisplayChar(*ptr_stringPointer_u8++); // Loop through the string and display char by char
     902:	0e 94 4f 04 	call	0x89e	; 0x89e <LCD_DisplayChar>
     906:	fa cf       	rjmp	.-12     	; 0x8fc <LCD_DisplayString+0x6>
}
     908:	df 91       	pop	r29
     90a:	cf 91       	pop	r28
     90c:	08 95       	ret

0000090e <RTC_Init>:

 * description :This function is used to Initialize the Ds1307 RTC.
***************************************************************************************************/
void RTC_Init(void)
{
    I2C_Init();                             // Initialize the I2c module.
     90e:	0e 94 84 01 	call	0x308	; 0x308 <I2C_Init>
    I2C_Start();                            // Start I2C communication
     912:	0e 94 8a 01 	call	0x314	; 0x314 <I2C_Start>

    I2C_Write(C_Ds1307WriteMode_U8);        // Connect to DS1307 by sending its ID on I2c Bus
     916:	80 ed       	ldi	r24, 0xD0	; 208
     918:	0e 94 96 01 	call	0x32c	; 0x32c <I2C_Write>
    I2C_Write(C_Ds1307ControlRegAddress_U8);// Select the Ds1307 ControlRegister to configure Ds1307
     91c:	87 e0       	ldi	r24, 0x07	; 7
     91e:	0e 94 96 01 	call	0x32c	; 0x32c <I2C_Write>

    I2C_Write(0x00);                        // Write 0x00 to Control register to disable SQW-Out
     922:	80 e0       	ldi	r24, 0x00	; 0
     924:	0e 94 96 01 	call	0x32c	; 0x32c <I2C_Write>

    I2C_Stop();                             // Stop I2C communication after initializing DS1307
     928:	0c 94 90 01 	jmp	0x320	; 0x320 <I2C_Stop>

0000092c <RTC_SetDateTime>:
        Note: The date and time should be of BCD format, 
             like 0x12,0x39,0x26 for 12hr,39min and 26sec.    
                  0x15,0x08,0x47 for 15th day,8th month and 47th year.                 
***************************************************************************************************/
void RTC_SetDateTime(rtc_t *rtc)
{
     92c:	cf 93       	push	r28
     92e:	df 93       	push	r29
     930:	ec 01       	movw	r28, r24
    I2C_Start();                          // Start I2C communication
     932:	0e 94 8a 01 	call	0x314	; 0x314 <I2C_Start>

    I2C_Write(C_Ds1307WriteMode_U8);      // connect to DS1307 by sending its ID on I2c Bus
     936:	80 ed       	ldi	r24, 0xD0	; 208
     938:	0e 94 96 01 	call	0x32c	; 0x32c <I2C_Write>
    I2C_Write(C_Ds1307SecondRegAddress_U8); // Request sec RAM address at 00H
     93c:	80 e0       	ldi	r24, 0x00	; 0
     93e:	0e 94 96 01 	call	0x32c	; 0x32c <I2C_Write>

    I2C_Write(rtc->sec);                    // Write sec from RAM address 00H
     942:	88 81       	ld	r24, Y
     944:	0e 94 96 01 	call	0x32c	; 0x32c <I2C_Write>
    I2C_Write(rtc->min);                    // Write min from RAM address 01H
     948:	89 81       	ldd	r24, Y+1	; 0x01
     94a:	0e 94 96 01 	call	0x32c	; 0x32c <I2C_Write>
    I2C_Write(rtc->hour);                    // Write hour from RAM address 02H
     94e:	8a 81       	ldd	r24, Y+2	; 0x02
     950:	0e 94 96 01 	call	0x32c	; 0x32c <I2C_Write>
    I2C_Write(rtc->weekDay);                // Write weekDay on RAM address 03H
     954:	8b 81       	ldd	r24, Y+3	; 0x03
     956:	0e 94 96 01 	call	0x32c	; 0x32c <I2C_Write>
    I2C_Write(rtc->date);                    // Write date on RAM address 04H
     95a:	8c 81       	ldd	r24, Y+4	; 0x04
     95c:	0e 94 96 01 	call	0x32c	; 0x32c <I2C_Write>
    I2C_Write(rtc->month);                    // Write month on RAM address 05H
     960:	8d 81       	ldd	r24, Y+5	; 0x05
     962:	0e 94 96 01 	call	0x32c	; 0x32c <I2C_Write>
    I2C_Write(rtc->year);                    // Write year on RAM address 06h
     966:	8e 81       	ldd	r24, Y+6	; 0x06
     968:	0e 94 96 01 	call	0x32c	; 0x32c <I2C_Write>

    I2C_Stop();                              // Stop I2C communication after Setting the Date
}
     96c:	df 91       	pop	r29
     96e:	cf 91       	pop	r28
    I2C_Write(rtc->weekDay);                // Write weekDay on RAM address 03H
    I2C_Write(rtc->date);                    // Write date on RAM address 04H
    I2C_Write(rtc->month);                    // Write month on RAM address 05H
    I2C_Write(rtc->year);                    // Write year on RAM address 06h

    I2C_Stop();                              // Stop I2C communication after Setting the Date
     970:	0c 94 90 01 	jmp	0x320	; 0x320 <I2C_Stop>

00000974 <RTC_GetDateTime>:
    Note: The date and time read from Ds1307 will be of BCD format, 
          like 0x12,0x39,0x26 for 12hr,39min and 26sec.    
               0x15,0x08,0x47 for 15th day,8th month and 47th year.              
***************************************************************************************************/
void RTC_GetDateTime(rtc_t *rtc)
{
     974:	cf 93       	push	r28
     976:	df 93       	push	r29
     978:	ec 01       	movw	r28, r24
    I2C_Start();                            // Start I2C communication
     97a:	0e 94 8a 01 	call	0x314	; 0x314 <I2C_Start>

    I2C_Write(C_Ds1307WriteMode_U8);        // connect to DS1307 by sending its ID on I2c Bus
     97e:	80 ed       	ldi	r24, 0xD0	; 208
     980:	0e 94 96 01 	call	0x32c	; 0x32c <I2C_Write>
    I2C_Write(C_Ds1307SecondRegAddress_U8); // Request Sec RAM address at 00H
     984:	80 e0       	ldi	r24, 0x00	; 0
     986:	0e 94 96 01 	call	0x32c	; 0x32c <I2C_Write>

    I2C_Stop();                                // Stop I2C communication after selecting Sec Register
     98a:	0e 94 90 01 	call	0x320	; 0x320 <I2C_Stop>

    I2C_Start();                            // Start I2C communication
     98e:	0e 94 8a 01 	call	0x314	; 0x314 <I2C_Start>
    I2C_Write(C_Ds1307ReadMode_U8);            // connect to DS1307(Read mode) by sending its ID
     992:	81 ed       	ldi	r24, 0xD1	; 209
     994:	0e 94 96 01 	call	0x32c	; 0x32c <I2C_Write>

    rtc->sec = I2C_Read(1);                // read second and return Positive ACK
     998:	81 e0       	ldi	r24, 0x01	; 1
     99a:	0e 94 9d 01 	call	0x33a	; 0x33a <I2C_Read>
     99e:	88 83       	st	Y, r24
    rtc->min = I2C_Read(1);                 // read minute and return Positive ACK
     9a0:	81 e0       	ldi	r24, 0x01	; 1
     9a2:	0e 94 9d 01 	call	0x33a	; 0x33a <I2C_Read>
     9a6:	89 83       	std	Y+1, r24	; 0x01
    rtc->hour= I2C_Read(1);               // read hour and return Negative/No ACK
     9a8:	81 e0       	ldi	r24, 0x01	; 1
     9aa:	0e 94 9d 01 	call	0x33a	; 0x33a <I2C_Read>
     9ae:	8a 83       	std	Y+2, r24	; 0x02
    rtc->weekDay = I2C_Read(1);           // read weekDay and return Positive ACK
     9b0:	81 e0       	ldi	r24, 0x01	; 1
     9b2:	0e 94 9d 01 	call	0x33a	; 0x33a <I2C_Read>
     9b6:	8b 83       	std	Y+3, r24	; 0x03
    rtc->date= I2C_Read(1);              // read Date and return Positive ACK
     9b8:	81 e0       	ldi	r24, 0x01	; 1
     9ba:	0e 94 9d 01 	call	0x33a	; 0x33a <I2C_Read>
     9be:	8c 83       	std	Y+4, r24	; 0x04
    rtc->month=I2C_Read(1);            // read Month and return Positive ACK
     9c0:	81 e0       	ldi	r24, 0x01	; 1
     9c2:	0e 94 9d 01 	call	0x33a	; 0x33a <I2C_Read>
     9c6:	8d 83       	std	Y+5, r24	; 0x05
    rtc->year =I2C_Read(0);             // read Year and return Negative/No ACK
     9c8:	80 e0       	ldi	r24, 0x00	; 0
     9ca:	0e 94 9d 01 	call	0x33a	; 0x33a <I2C_Read>
     9ce:	8e 83       	std	Y+6, r24	; 0x06

    I2C_Stop();                              // Stop I2C communication after reading the Date
}
     9d0:	df 91       	pop	r29
     9d2:	cf 91       	pop	r28
    rtc->weekDay = I2C_Read(1);           // read weekDay and return Positive ACK
    rtc->date= I2C_Read(1);              // read Date and return Positive ACK
    rtc->month=I2C_Read(1);            // read Month and return Positive ACK
    rtc->year =I2C_Read(0);             // read Year and return Negative/No ACK

    I2C_Stop();                              // Stop I2C communication after reading the Date
     9d4:	0c 94 90 01 	jmp	0x320	; 0x320 <I2C_Stop>

000009d8 <UART_SetBaudRate>:
                 the default baudrate of 9600 is set.

		    Refer uart.h file for Supported range of baud rates.
***************************************************************************************************/
void UART_SetBaudRate(uint32_t v_baudRate_u32)
{
     9d8:	cf 92       	push	r12
     9da:	df 92       	push	r13
     9dc:	ef 92       	push	r14
     9de:	ff 92       	push	r15
     9e0:	6b 01       	movw	r12, r22
     9e2:	7c 01       	movw	r14, r24
	uint16_t RegValue;

	if((v_baudRate_u32 >= C_MinBaudRate_U32) && (v_baudRate_u32<=C_MaxBaudRate_U32))
     9e4:	dc 01       	movw	r26, r24
     9e6:	cb 01       	movw	r24, r22
     9e8:	80 56       	subi	r24, 0x60	; 96
     9ea:	99 40       	sbci	r25, 0x09	; 9
     9ec:	a1 09       	sbc	r26, r1
     9ee:	b1 09       	sbc	r27, r1
     9f0:	81 3a       	cpi	r24, 0xA1	; 161
     9f2:	98 4b       	sbci	r25, 0xB8	; 184
     9f4:	a1 40       	sbci	r26, 0x01	; 1
     9f6:	b1 05       	cpc	r27, r1
     9f8:	98 f4       	brcc	.+38     	; 0xa20 <UART_SetBaudRate+0x48>
	{
		/* Check if the requested baudate is within range,
	     If yes then calculate the value to be loaded into baud rate generator. */
		RegValue = M_GetBaudRateGeneratorValue(v_baudRate_u32);
     9fa:	a8 ef       	ldi	r26, 0xF8	; 248
     9fc:	bf ef       	ldi	r27, 0xFF	; 255
     9fe:	a7 01       	movw	r20, r14
     a00:	96 01       	movw	r18, r12
     a02:	0e 94 4f 0b 	call	0x169e	; 0x169e <__mulohisi3>
     a06:	7c 5d       	subi	r23, 0xDC	; 220
     a08:	8b 40       	sbci	r24, 0x0B	; 11
     a0a:	9f 4f       	sbci	r25, 0xFF	; 255
     a0c:	e4 e0       	ldi	r30, 0x04	; 4
     a0e:	22 0f       	add	r18, r18
     a10:	33 1f       	adc	r19, r19
     a12:	44 1f       	adc	r20, r20
     a14:	55 1f       	adc	r21, r21
     a16:	ea 95       	dec	r30
     a18:	d1 f7       	brne	.-12     	; 0xa0e <UART_SetBaudRate+0x36>
     a1a:	0e 94 24 0b 	call	0x1648	; 0x1648 <__udivmodsi4>
     a1e:	02 c0       	rjmp	.+4      	; 0xa24 <UART_SetBaudRate+0x4c>
	}
	else
	{
		/*	 Invalid baudrate requested, hence set it to default baudrate of 9600 */
		RegValue = M_GetBaudRateGeneratorValue(9600);
     a20:	27 e6       	ldi	r18, 0x67	; 103
     a22:	30 e0       	ldi	r19, 0x00	; 0
	}

	UBRRL = util_ExtractByte0to8(RegValue);
     a24:	29 b9       	out	0x09, r18	; 9
	UBRRH = util_ExtractByte8to16(RegValue);
     a26:	30 bd       	out	0x20, r19	; 32
}
     a28:	ff 90       	pop	r15
     a2a:	ef 90       	pop	r14
     a2c:	df 90       	pop	r13
     a2e:	cf 90       	pop	r12
     a30:	08 95       	ret

00000a32 <UART_Init>:

		    Refer uart.h file for Supported(range) baud rates.		
***************************************************************************************************/
void UART_Init(uint32_t v_baudRate_u32)
{
	UCSRB= (1<<RXEN) | (1<<TXEN);                  // Enable Receiver and Transmitter
     a32:	28 e1       	ldi	r18, 0x18	; 24
     a34:	2a b9       	out	0x0a, r18	; 10
	UCSRC= (1<<URSEL) | (1<<UCSZ1) | (1<<UCSZ0);   // Asynchronous mode 8-bit data and 1-stop bit
     a36:	26 e8       	ldi	r18, 0x86	; 134
     a38:	20 bd       	out	0x20, r18	; 32
	UCSRA= 0x00;                                   // Clear the UASRT status register
     a3a:	1b b8       	out	0x0b, r1	; 11
	UART_SetBaudRate(v_baudRate_u32);
     a3c:	0c 94 ec 04 	jmp	0x9d8	; 0x9d8 <UART_SetBaudRate>

00000a40 <UART_RxChar>:
 * description :This function is used to receive a char from UART module.
                It waits till a char is received and returns it after reception.
***************************************************************************************************/
char UART_RxChar(void)
{
	while(util_IsBitCleared(UCSRA,RXC));  // Wait till the data is received
     a40:	5f 9b       	sbis	0x0b, 7	; 11
     a42:	fe cf       	rjmp	.-4      	; 0xa40 <UART_RxChar>
	return(UDR);                          // return the received char
     a44:	8c b1       	in	r24, 0x0c	; 12
}
     a46:	08 95       	ret

00000a48 <UART_TxChar>:

 * description  :This function is used to transmit a char through UART module.
***************************************************************************************************/
void UART_TxChar(char v_uartData_u8)
{
	while(util_IsBitCleared(UCSRA,UDRE)); // Wait till Transmitter(UDR) register becomes Empty
     a48:	5d 9b       	sbis	0x0b, 5	; 11
     a4a:	fe cf       	rjmp	.-4      	; 0xa48 <UART_TxChar>
	UDR =v_uartData_u8;                              // Load the data to be transmitted
     a4c:	8c b9       	out	0x0c, r24	; 12
     a4e:	08 95       	ret

00000a50 <UART_TxNumber.part.0>:
                7.(0x12AB,3) then 3-digits ie. 2AB will be transmitted
                8.(0x12AB,6) then 6-digits ie. 0012AB will be transmitted
                9.(0x12AB,C_DefaultDigitsToTransmit_U8) then 12AB will be transmitted.    
 ***************************************************************************************************/
#if ((Enable_UART_TxNumber==1) || (Enable_UART_TxFloatNumber==1) || (Enable_UART_Printf == 1))
void UART_TxNumber(uint8_t v_numericSystem_u8, uint32_t v_number_u32, uint8_t v_numOfDigitsToTransmit_u8)
     a50:	af 92       	push	r10
     a52:	bf 92       	push	r11
     a54:	cf 92       	push	r12
     a56:	df 92       	push	r13
     a58:	ef 92       	push	r14
     a5a:	ff 92       	push	r15
     a5c:	0f 93       	push	r16
     a5e:	1f 93       	push	r17
     a60:	cf 93       	push	r28
     a62:	df 93       	push	r29
     a64:	1f 92       	push	r1
     a66:	cd b7       	in	r28, 0x3d	; 61
     a68:	de b7       	in	r29, 0x3e	; 62
     a6a:	6b 01       	movw	r12, r22
     a6c:	7c 01       	movw	r14, r24
    {
        while(v_numOfDigitsToTransmit_u8!=0)
        {
            /* Start Extracting the bits from the specified bit positions.
             Get the Acsii values of the bits and transmit */
            i = util_GetBitStatus(v_number_u32,(v_numOfDigitsToTransmit_u8-1));
     a6e:	aa 24       	eor	r10, r10
     a70:	a3 94       	inc	r10
     a72:	b1 2c       	mov	r11, r1
{
    uint8_t i=0,a[10];

    if(C_BINARY_U8 == v_numericSystem_u8)
    {
        while(v_numOfDigitsToTransmit_u8!=0)
     a74:	44 23       	and	r20, r20
     a76:	e9 f0       	breq	.+58     	; 0xab2 <UART_TxNumber.part.0+0x62>
        {
            /* Start Extracting the bits from the specified bit positions.
             Get the Acsii values of the bits and transmit */
            i = util_GetBitStatus(v_number_u32,(v_numOfDigitsToTransmit_u8-1));
     a78:	8f ef       	ldi	r24, 0xFF	; 255
     a7a:	84 0f       	add	r24, r20
     a7c:	85 01       	movw	r16, r10
     a7e:	02 c0       	rjmp	.+4      	; 0xa84 <UART_TxNumber.part.0+0x34>
     a80:	00 0f       	add	r16, r16
     a82:	11 1f       	adc	r17, r17
     a84:	8a 95       	dec	r24
     a86:	e2 f7       	brpl	.-8      	; 0xa80 <UART_TxNumber.part.0+0x30>
     a88:	01 2e       	mov	r0, r17
     a8a:	00 0c       	add	r0, r0
     a8c:	22 0b       	sbc	r18, r18
     a8e:	33 0b       	sbc	r19, r19
     a90:	0c 21       	and	r16, r12
     a92:	1d 21       	and	r17, r13
     a94:	2e 21       	and	r18, r14
     a96:	3f 21       	and	r19, r15
     a98:	81 e0       	ldi	r24, 0x01	; 1
     a9a:	01 2b       	or	r16, r17
     a9c:	02 2b       	or	r16, r18
     a9e:	03 2b       	or	r16, r19
     aa0:	09 f4       	brne	.+2      	; 0xaa4 <UART_TxNumber.part.0+0x54>
     aa2:	80 e0       	ldi	r24, 0x00	; 0
            UART_TxChar(util_Dec2Ascii(i));
     aa4:	80 5d       	subi	r24, 0xD0	; 208
     aa6:	49 83       	std	Y+1, r20	; 0x01
     aa8:	0e 94 24 05 	call	0xa48	; 0xa48 <UART_TxChar>
            v_numOfDigitsToTransmit_u8--;
     aac:	49 81       	ldd	r20, Y+1	; 0x01
     aae:	41 50       	subi	r20, 0x01	; 1
     ab0:	e1 cf       	rjmp	.-62     	; 0xa74 <UART_TxNumber.part.0+0x24>
            i--;
        }
    }


}
     ab2:	0f 90       	pop	r0
     ab4:	df 91       	pop	r29
     ab6:	cf 91       	pop	r28
     ab8:	1f 91       	pop	r17
     aba:	0f 91       	pop	r16
     abc:	ff 90       	pop	r15
     abe:	ef 90       	pop	r14
     ac0:	df 90       	pop	r13
     ac2:	cf 90       	pop	r12
     ac4:	bf 90       	pop	r11
     ac6:	af 90       	pop	r10
     ac8:	08 95       	ret

00000aca <UART_TxString>:
               1.The ptr_string points to the first char of the string
                    and traverses till the end(NULL CHAR) and transmits a char each time
***************************************************************************************************/
#if ((Enable_UART_TxString==1)|| (Enable_UART_Printf == 1))
void UART_TxString(char *ptr_string)
{
     aca:	cf 93       	push	r28
     acc:	df 93       	push	r29
     ace:	ec 01       	movw	r28, r24
	while(*ptr_string)
     ad0:	89 91       	ld	r24, Y+
     ad2:	88 23       	and	r24, r24
     ad4:	19 f0       	breq	.+6      	; 0xadc <UART_TxString+0x12>
		UART_TxChar(*ptr_string++);// Loop through the string and transmit char by char
     ad6:	0e 94 24 05 	call	0xa48	; 0xa48 <UART_TxChar>
     ada:	fa cf       	rjmp	.-12     	; 0xad0 <UART_TxString+0x6>
}
     adc:	df 91       	pop	r29
     ade:	cf 91       	pop	r28
     ae0:	08 95       	ret

00000ae2 <UART_TxNumber>:
                8.(0x12AB,6) then 6-digits ie. 0012AB will be transmitted
                9.(0x12AB,C_DefaultDigitsToTransmit_U8) then 12AB will be transmitted.    
 ***************************************************************************************************/
#if ((Enable_UART_TxNumber==1) || (Enable_UART_TxFloatNumber==1) || (Enable_UART_Printf == 1))
void UART_TxNumber(uint8_t v_numericSystem_u8, uint32_t v_number_u32, uint8_t v_numOfDigitsToTransmit_u8)
{
     ae2:	4f 92       	push	r4
     ae4:	5f 92       	push	r5
     ae6:	6f 92       	push	r6
     ae8:	7f 92       	push	r7
     aea:	bf 92       	push	r11
     aec:	cf 92       	push	r12
     aee:	df 92       	push	r13
     af0:	ef 92       	push	r14
     af2:	ff 92       	push	r15
     af4:	0f 93       	push	r16
     af6:	1f 93       	push	r17
     af8:	cf 93       	push	r28
     afa:	df 93       	push	r29
     afc:	cd b7       	in	r28, 0x3d	; 61
     afe:	de b7       	in	r29, 0x3e	; 62
     b00:	2a 97       	sbiw	r28, 0x0a	; 10
     b02:	0f b6       	in	r0, 0x3f	; 63
     b04:	f8 94       	cli
     b06:	de bf       	out	0x3e, r29	; 62
     b08:	0f be       	out	0x3f, r0	; 63
     b0a:	cd bf       	out	0x3d, r28	; 61
     b0c:	b8 2e       	mov	r11, r24
     b0e:	cb 01       	movw	r24, r22
     b10:	ba 01       	movw	r22, r20
     b12:	02 2f       	mov	r16, r18
    uint8_t i=0,a[10];

    if(C_BINARY_U8 == v_numericSystem_u8)
     b14:	22 e0       	ldi	r18, 0x02	; 2
     b16:	b2 12       	cpse	r11, r18
     b18:	16 c0       	rjmp	.+44     	; 0xb46 <UART_TxNumber+0x64>
     b1a:	40 2f       	mov	r20, r16
            i--;
        }
    }


}
     b1c:	2a 96       	adiw	r28, 0x0a	; 10
     b1e:	0f b6       	in	r0, 0x3f	; 63
     b20:	f8 94       	cli
     b22:	de bf       	out	0x3e, r29	; 62
     b24:	0f be       	out	0x3f, r0	; 63
     b26:	cd bf       	out	0x3d, r28	; 61
     b28:	df 91       	pop	r29
     b2a:	cf 91       	pop	r28
     b2c:	1f 91       	pop	r17
     b2e:	0f 91       	pop	r16
     b30:	ff 90       	pop	r15
     b32:	ef 90       	pop	r14
     b34:	df 90       	pop	r13
     b36:	cf 90       	pop	r12
     b38:	bf 90       	pop	r11
     b3a:	7f 90       	pop	r7
     b3c:	6f 90       	pop	r6
     b3e:	5f 90       	pop	r5
     b40:	4f 90       	pop	r4
     b42:	0c 94 28 05 	jmp	0xa50	; 0xa50 <UART_TxNumber.part.0>
            i = util_GetBitStatus(v_number_u32,(v_numOfDigitsToTransmit_u8-1));
            UART_TxChar(util_Dec2Ascii(i));
            v_numOfDigitsToTransmit_u8--;
        }    
    }     
    else if(v_number_u32==0)
     b46:	61 15       	cp	r22, r1
     b48:	71 05       	cpc	r23, r1
     b4a:	81 05       	cpc	r24, r1
     b4c:	91 05       	cpc	r25, r1
     b4e:	49 f0       	breq	.+18     	; 0xb62 <UART_TxNumber+0x80>
     b50:	fe 01       	movw	r30, r28
     b52:	31 96       	adiw	r30, 0x01	; 1
     b54:	6f 01       	movw	r12, r30
     b56:	7f 01       	movw	r14, r30
                First get the remainder and divide the number by 10 each time.

                example for Decimal number:
                If v_number_u32 = 123 then extracted remainder will be 3 and number will be 12.
                The process continues till it becomes zero or max digits reached*/
                a[i]=util_GetMod32(v_number_u32,v_numericSystem_u8);
     b58:	4b 2c       	mov	r4, r11
     b5a:	51 2c       	mov	r5, r1
     b5c:	61 2c       	mov	r6, r1
     b5e:	71 2c       	mov	r7, r1
     b60:	1e c0       	rjmp	.+60     	; 0xb9e <UART_TxNumber+0xbc>
     b62:	10 e0       	ldi	r17, 0x00	; 0
        }    
    }     
    else if(v_number_u32==0)
    {
        /* If the number is zero then update the array with the same for transmitting */
        for(i=0;((i<v_numOfDigitsToTransmit_u8) && (i<C_MaxDigitsToTransmit_U8)) ;i++)
     b64:	10 17       	cp	r17, r16
     b66:	a1 f1       	breq	.+104    	; 0xbd0 <UART_TxNumber+0xee>
     b68:	1a 30       	cpi	r17, 0x0A	; 10
     b6a:	91 f1       	breq	.+100    	; 0xbd0 <UART_TxNumber+0xee>
            UART_TxChar('0');
     b6c:	80 e3       	ldi	r24, 0x30	; 48
     b6e:	0e 94 24 05 	call	0xa48	; 0xa48 <UART_TxChar>
        }    
    }     
    else if(v_number_u32==0)
    {
        /* If the number is zero then update the array with the same for transmitting */
        for(i=0;((i<v_numOfDigitsToTransmit_u8) && (i<C_MaxDigitsToTransmit_U8)) ;i++)
     b72:	1f 5f       	subi	r17, 0xFF	; 255
     b74:	f7 cf       	rjmp	.-18     	; 0xb64 <UART_TxNumber+0x82>
    {
        for(i=0;i<v_numOfDigitsToTransmit_u8;i++)
        {
            /* Continue extracting the digits from right side
               till the Specified v_numOfDigitsToTransmit_u8 */
            if(v_number_u32!=0)
     b76:	61 15       	cp	r22, r1
     b78:	71 05       	cpc	r23, r1
     b7a:	81 05       	cpc	r24, r1
     b7c:	91 05       	cpc	r25, r1
     b7e:	a1 f0       	breq	.+40     	; 0xba8 <UART_TxNumber+0xc6>
                First get the remainder and divide the number by 10 each time.

                example for Decimal number:
                If v_number_u32 = 123 then extracted remainder will be 3 and number will be 12.
                The process continues till it becomes zero or max digits reached*/
                a[i]=util_GetMod32(v_number_u32,v_numericSystem_u8);
     b80:	16 2f       	mov	r17, r22
     b82:	a3 01       	movw	r20, r6
     b84:	92 01       	movw	r18, r4
     b86:	0e 94 24 0b 	call	0x1648	; 0x1648 <__udivmodsi4>
     b8a:	ca 01       	movw	r24, r20
     b8c:	b9 01       	movw	r22, r18
     b8e:	b2 9e       	mul	r11, r18
     b90:	10 19       	sub	r17, r0
     b92:	11 24       	eor	r1, r1
     b94:	f7 01       	movw	r30, r14
     b96:	10 83       	st	Z, r17
     b98:	ff ef       	ldi	r31, 0xFF	; 255
     b9a:	ef 1a       	sub	r14, r31
     b9c:	ff 0a       	sbc	r15, r31
     b9e:	1e 2d       	mov	r17, r14
     ba0:	1c 19       	sub	r17, r12
        for(i=0;((i<v_numOfDigitsToTransmit_u8) && (i<C_MaxDigitsToTransmit_U8)) ;i++)
            UART_TxChar('0');
    }
    else
    {
        for(i=0;i<v_numOfDigitsToTransmit_u8;i++)
     ba2:	10 17       	cp	r17, r16
     ba4:	40 f3       	brcs	.-48     	; 0xb76 <UART_TxNumber+0x94>
     ba6:	0f c0       	rjmp	.+30     	; 0xbc6 <UART_TxNumber+0xe4>
                If v_number_u32 = 123 then extracted remainder will be 3 and number will be 12.
                The process continues till it becomes zero or max digits reached*/
                a[i]=util_GetMod32(v_number_u32,v_numericSystem_u8);
                v_number_u32=v_number_u32/v_numericSystem_u8;
            }
            else if( (v_numOfDigitsToTransmit_u8 == C_DefaultDigitsToTransmit_U8) ||
     ba8:	0b 30       	cpi	r16, 0x0B	; 11
     baa:	68 f4       	brcc	.+26     	; 0xbc6 <UART_TxNumber+0xe4>
            else
            {
                /*In case user expects more digits to be transmitted than the actual digits in number,
                  then update the remaining digits with zero.
                Ex: v_number_u32 is 123 and user wants five digits then 00123 has to be transmitted */
                a[i]=0;
     bac:	f7 01       	movw	r30, r14
     bae:	10 82       	st	Z, r1
     bb0:	f3 cf       	rjmp	.-26     	; 0xb98 <UART_TxNumber+0xb6>
        }

        while(i)
        { 
            /* Finally get the ascii values of the digits and transmit*/
            UART_TxChar(util_Hex2Ascii(a[i-1]));
     bb2:	fe 01       	movw	r30, r28
     bb4:	e1 0f       	add	r30, r17
     bb6:	f1 1d       	adc	r31, r1
     bb8:	80 81       	ld	r24, Z
     bba:	8a 30       	cpi	r24, 0x0A	; 10
     bbc:	38 f0       	brcs	.+14     	; 0xbcc <UART_TxNumber+0xea>
     bbe:	89 5c       	subi	r24, 0xC9	; 201
     bc0:	0e 94 24 05 	call	0xa48	; 0xa48 <UART_TxChar>
            i--;
     bc4:	11 50       	subi	r17, 0x01	; 1
                Ex: v_number_u32 is 123 and user wants five digits then 00123 has to be transmitted */
                a[i]=0;
            }
        }

        while(i)
     bc6:	11 11       	cpse	r17, r1
     bc8:	f4 cf       	rjmp	.-24     	; 0xbb2 <UART_TxNumber+0xd0>
     bca:	02 c0       	rjmp	.+4      	; 0xbd0 <UART_TxNumber+0xee>
        { 
            /* Finally get the ascii values of the digits and transmit*/
            UART_TxChar(util_Hex2Ascii(a[i-1]));
     bcc:	80 5d       	subi	r24, 0xD0	; 208
     bce:	f8 cf       	rjmp	.-16     	; 0xbc0 <UART_TxNumber+0xde>
            i--;
        }
    }


}
     bd0:	2a 96       	adiw	r28, 0x0a	; 10
     bd2:	0f b6       	in	r0, 0x3f	; 63
     bd4:	f8 94       	cli
     bd6:	de bf       	out	0x3e, r29	; 62
     bd8:	0f be       	out	0x3f, r0	; 63
     bda:	cd bf       	out	0x3d, r28	; 61
     bdc:	df 91       	pop	r29
     bde:	cf 91       	pop	r28
     be0:	1f 91       	pop	r17
     be2:	0f 91       	pop	r16
     be4:	ff 90       	pop	r15
     be6:	ef 90       	pop	r14
     be8:	df 90       	pop	r13
     bea:	cf 90       	pop	r12
     bec:	bf 90       	pop	r11
     bee:	7f 90       	pop	r7
     bf0:	6f 90       	pop	r6
     bf2:	5f 90       	pop	r5
     bf4:	4f 90       	pop	r4
     bf6:	08 95       	ret

00000bf8 <UART_TxFloatNumber>:
         Float will be disabled by default as it takes huge controller resources
	     It can be enabled by changing value of Enable_UART_TxFloatNumber to 1 in uart.h	 
 ***************************************************************************************************/
#if (Enable_UART_TxFloatNumber==1)
void UART_TxFloatNumber(float v_floatNumber_f32)
{
     bf8:	8f 92       	push	r8
     bfa:	9f 92       	push	r9
     bfc:	af 92       	push	r10
     bfe:	bf 92       	push	r11
     c00:	cf 92       	push	r12
     c02:	df 92       	push	r13
     c04:	ef 92       	push	r14
     c06:	ff 92       	push	r15
     c08:	6b 01       	movw	r12, r22
     c0a:	7c 01       	movw	r14, r24
      1.Type cast the number to int to get the integer part.
	  2.transmit the extracted integer part followed by a decimal point(.).
	  3.Later the integer part is made zero by subtracting with the extracted integer value.
	  4.Finally the fractional part is multiplied by 100000 to support 6-digit precision */

	v_tempNumber_u32 = (uint32_t) v_floatNumber_f32;
     c0c:	0e 94 fa 09 	call	0x13f4	; 0x13f4 <__fixunssfsi>
     c10:	4b 01       	movw	r8, r22
     c12:	5c 01       	movw	r10, r24
	UART_TxNumber(C_DECIMAL_U8,v_tempNumber_u32,C_DefaultDigitsToTransmit_U8);
     c14:	2f ef       	ldi	r18, 0xFF	; 255
     c16:	ab 01       	movw	r20, r22
     c18:	bc 01       	movw	r22, r24
     c1a:	8a e0       	ldi	r24, 0x0A	; 10
     c1c:	0e 94 71 05 	call	0xae2	; 0xae2 <UART_TxNumber>

	UART_TxChar('.');
     c20:	8e e2       	ldi	r24, 0x2E	; 46
     c22:	0e 94 24 05 	call	0xa48	; 0xa48 <UART_TxChar>

	v_floatNumber_f32 = v_floatNumber_f32 - v_tempNumber_u32;
     c26:	c5 01       	movw	r24, r10
     c28:	b4 01       	movw	r22, r8
     c2a:	0e 94 29 0a 	call	0x1452	; 0x1452 <__floatunsisf>
     c2e:	9b 01       	movw	r18, r22
     c30:	ac 01       	movw	r20, r24
     c32:	c7 01       	movw	r24, r14
     c34:	b6 01       	movw	r22, r12
     c36:	0e 94 8d 09 	call	0x131a	; 0x131a <__subsf3>
	v_tempNumber_u32 = v_floatNumber_f32 * 1000000;
     c3a:	20 e0       	ldi	r18, 0x00	; 0
     c3c:	34 e2       	ldi	r19, 0x24	; 36
     c3e:	44 e7       	ldi	r20, 0x74	; 116
     c40:	59 e4       	ldi	r21, 0x49	; 73
     c42:	0e 94 b7 0a 	call	0x156e	; 0x156e <__mulsf3>
     c46:	0e 94 fa 09 	call	0x13f4	; 0x13f4 <__fixunssfsi>
     c4a:	ab 01       	movw	r20, r22
     c4c:	bc 01       	movw	r22, r24
	UART_TxNumber(C_DECIMAL_U8,v_tempNumber_u32,C_DefaultDigitsToTransmit_U8);
     c4e:	2f ef       	ldi	r18, 0xFF	; 255
     c50:	8a e0       	ldi	r24, 0x0A	; 10
}
     c52:	ff 90       	pop	r15
     c54:	ef 90       	pop	r14
     c56:	df 90       	pop	r13
     c58:	cf 90       	pop	r12
     c5a:	bf 90       	pop	r11
     c5c:	af 90       	pop	r10
     c5e:	9f 90       	pop	r9
     c60:	8f 90       	pop	r8

	UART_TxChar('.');

	v_floatNumber_f32 = v_floatNumber_f32 - v_tempNumber_u32;
	v_tempNumber_u32 = v_floatNumber_f32 * 1000000;
	UART_TxNumber(C_DECIMAL_U8,v_tempNumber_u32,C_DefaultDigitsToTransmit_U8);
     c62:	0c 94 71 05 	jmp	0xae2	; 0xae2 <UART_TxNumber>

00000c66 <UART_Printf>:
        uint8_t v_Num_u8;
		UART_Printf("num1:%u",(uint16_t)v_Num_u8); 		 
***************************************************************************************************/
#if ( Enable_UART_Printf   == 1 ) 
void UART_Printf(const char *argList, ...)
{
     c66:	cf 92       	push	r12
     c68:	df 92       	push	r13
     c6a:	ef 92       	push	r14
     c6c:	ff 92       	push	r15
     c6e:	0f 93       	push	r16
     c70:	1f 93       	push	r17
     c72:	cf 93       	push	r28
     c74:	df 93       	push	r29
     c76:	00 d0       	rcall	.+0      	; 0xc78 <UART_Printf+0x12>
     c78:	00 d0       	rcall	.+0      	; 0xc7a <UART_Printf+0x14>
     c7a:	1f 92       	push	r1
     c7c:	cd b7       	in	r28, 0x3d	; 61
     c7e:	de b7       	in	r29, 0x3e	; 62
     c80:	fe 01       	movw	r30, r28
     c82:	70 96       	adiw	r30, 0x10	; 16
     c84:	c1 90       	ld	r12, Z+
     c86:	d1 90       	ld	r13, Z+
#if (Enable_UART_TxFloatNumber==1)
	double v_floatNum_f32;
#endif	


	va_start(argp, argList);
     c88:	8f 01       	movw	r16, r30

	/* Loop through the list to extract all the input arguments */
	for(ptr = argList; *ptr != '\0'; ptr++)
     c8a:	f6 01       	movw	r30, r12
     c8c:	80 81       	ld	r24, Z
     c8e:	88 23       	and	r24, r24
     c90:	09 f4       	brne	.+2      	; 0xc94 <UART_Printf+0x2e>
     c92:	2c c1       	rjmp	.+600    	; 0xeec <UART_Printf+0x286>
	{

		ch= *ptr;
		if(ch == '%')         /*Check for '%' as there will be format specifier after it */
     c94:	85 32       	cpi	r24, 0x25	; 37
     c96:	09 f0       	breq	.+2      	; 0xc9a <UART_Printf+0x34>
     c98:	0e c1       	rjmp	.+540    	; 0xeb6 <UART_Printf+0x250>
		{
		    ptr++;
     c9a:	76 01       	movw	r14, r12
     c9c:	8f ef       	ldi	r24, 0xFF	; 255
     c9e:	e8 1a       	sub	r14, r24
     ca0:	f8 0a       	sbc	r15, r24
		    ch = *ptr;
     ca2:	f6 01       	movw	r30, r12
     ca4:	81 81       	ldd	r24, Z+1	; 0x01
		   if((ch>=0x30) && (ch<=0x39))
     ca6:	90 ed       	ldi	r25, 0xD0	; 208
     ca8:	98 0f       	add	r25, r24
     caa:	9a 30       	cpi	r25, 0x0A	; 10
     cac:	08 f0       	brcs	.+2      	; 0xcb0 <UART_Printf+0x4a>
     cae:	b7 c0       	rjmp	.+366    	; 0xe1e <UART_Printf+0x1b8>
     cb0:	20 e0       	ldi	r18, 0x00	; 0
			{
			   v_numOfDigitsToTransmit_u8 = 0;
			   while((ch>=0x30) && (ch<=0x39))
     cb2:	90 ed       	ldi	r25, 0xD0	; 208
     cb4:	98 0f       	add	r25, r24
     cb6:	9a 30       	cpi	r25, 0x0A	; 10
     cb8:	58 f4       	brcc	.+22     	; 0xcd0 <UART_Printf+0x6a>
			    {
				   v_numOfDigitsToTransmit_u8 = (v_numOfDigitsToTransmit_u8 * 10) + (ch-0x30);
     cba:	fa e0       	ldi	r31, 0x0A	; 10
     cbc:	2f 9f       	mul	r18, r31
     cbe:	90 0d       	add	r25, r0
     cc0:	11 24       	eor	r1, r1
     cc2:	29 2f       	mov	r18, r25
				   ptr++;
     cc4:	8f ef       	ldi	r24, 0xFF	; 255
     cc6:	e8 1a       	sub	r14, r24
     cc8:	f8 0a       	sbc	r15, r24
				   ch = *ptr;
     cca:	f7 01       	movw	r30, r14
     ccc:	80 81       	ld	r24, Z
     cce:	f1 cf       	rjmp	.-30     	; 0xcb2 <UART_Printf+0x4c>
			{
			  v_numOfDigitsToTransmit_u8 = C_MaxDigitsToTransmitUsingPrintf_U8;
			}				


			switch(ch)       /* Decode the type of the argument */
     cd0:	88 35       	cpi	r24, 0x58	; 88
     cd2:	09 f4       	brne	.+2      	; 0xcd6 <UART_Printf+0x70>
     cd4:	a8 c0       	rjmp	.+336    	; 0xe26 <UART_Printf+0x1c0>
     cd6:	70 f4       	brcc	.+28     	; 0xcf4 <UART_Printf+0x8e>
     cd8:	84 34       	cpi	r24, 0x44	; 68
     cda:	09 f4       	brne	.+2      	; 0xcde <UART_Printf+0x78>
     cdc:	50 c0       	rjmp	.+160    	; 0xd7e <UART_Printf+0x118>
     cde:	18 f4       	brcc	.+6      	; 0xce6 <UART_Printf+0x80>
     ce0:	82 34       	cpi	r24, 0x42	; 66
     ce2:	d9 f4       	brne	.+54     	; 0xd1a <UART_Printf+0xb4>
     ce4:	bd c0       	rjmp	.+378    	; 0xe60 <UART_Printf+0x1fa>
     ce6:	83 35       	cpi	r24, 0x53	; 83
     ce8:	09 f4       	brne	.+2      	; 0xcec <UART_Printf+0x86>
     cea:	da c0       	rjmp	.+436    	; 0xea0 <UART_Printf+0x23a>
     cec:	85 35       	cpi	r24, 0x55	; 85
     cee:	09 f4       	brne	.+2      	; 0xcf2 <UART_Printf+0x8c>
     cf0:	7d c0       	rjmp	.+250    	; 0xdec <UART_Printf+0x186>
     cf2:	c6 c0       	rjmp	.+396    	; 0xe80 <UART_Printf+0x21a>
     cf4:	86 36       	cpi	r24, 0x66	; 102
     cf6:	09 f4       	brne	.+2      	; 0xcfa <UART_Printf+0x94>
     cf8:	c5 c0       	rjmp	.+394    	; 0xe84 <UART_Printf+0x21e>
     cfa:	40 f4       	brcc	.+16     	; 0xd0c <UART_Printf+0xa6>
     cfc:	83 36       	cpi	r24, 0x63	; 99
     cfe:	81 f0       	breq	.+32     	; 0xd20 <UART_Printf+0xba>
     d00:	84 36       	cpi	r24, 0x64	; 100
     d02:	21 f1       	breq	.+72     	; 0xd4c <UART_Printf+0xe6>
     d04:	82 36       	cpi	r24, 0x62	; 98
     d06:	09 f0       	breq	.+2      	; 0xd0a <UART_Printf+0xa4>
     d08:	d9 c0       	rjmp	.+434    	; 0xebc <UART_Printf+0x256>
     d0a:	9d c0       	rjmp	.+314    	; 0xe46 <UART_Printf+0x1e0>
     d0c:	85 37       	cpi	r24, 0x75	; 117
     d0e:	09 f4       	brne	.+2      	; 0xd12 <UART_Printf+0xac>
     d10:	59 c0       	rjmp	.+178    	; 0xdc4 <UART_Printf+0x15e>
     d12:	88 37       	cpi	r24, 0x78	; 120
     d14:	09 f4       	brne	.+2      	; 0xd18 <UART_Printf+0xb2>
     d16:	79 c0       	rjmp	.+242    	; 0xe0a <UART_Printf+0x1a4>
     d18:	c1 c0       	rjmp	.+386    	; 0xe9c <UART_Printf+0x236>
     d1a:	83 34       	cpi	r24, 0x43	; 67
     d1c:	08 f4       	brcc	.+2      	; 0xd20 <UART_Printf+0xba>
     d1e:	e0 c0       	rjmp	.+448    	; 0xee0 <UART_Printf+0x27a>
			{
			case 'C':
			case 'c':     /* Argument type is of char, hence read char data from the argp */
				ch = va_arg(argp, int);
     d20:	68 01       	movw	r12, r16
     d22:	f2 e0       	ldi	r31, 0x02	; 2
     d24:	cf 0e       	add	r12, r31
     d26:	d1 1c       	adc	r13, r1
				UART_TxChar(ch);
     d28:	f8 01       	movw	r30, r16
     d2a:	80 81       	ld	r24, Z
     d2c:	0e 94 24 05 	call	0xa48	; 0xa48 <UART_TxChar>
     d30:	c0 c0       	rjmp	.+384    	; 0xeb2 <UART_Printf+0x24c>
			{
			  v_numOfDigitsToTransmit_u8 = C_MaxDigitsToTransmitUsingPrintf_U8;
			}				


			switch(ch)       /* Decode the type of the argument */
     d32:	89 35       	cpi	r24, 0x59	; 89
     d34:	08 f1       	brcs	.+66     	; 0xd78 <UART_Printf+0x112>
     d36:	86 36       	cpi	r24, 0x66	; 102
     d38:	09 f4       	brne	.+2      	; 0xd3c <UART_Printf+0xd6>
     d3a:	a4 c0       	rjmp	.+328    	; 0xe84 <UART_Printf+0x21e>
     d3c:	08 f0       	brcs	.+2      	; 0xd40 <UART_Printf+0xda>
     d3e:	3f c0       	rjmp	.+126    	; 0xdbe <UART_Printf+0x158>
     d40:	83 36       	cpi	r24, 0x63	; 99
     d42:	71 f3       	breq	.-36     	; 0xd20 <UART_Printf+0xba>
     d44:	84 36       	cpi	r24, 0x64	; 100
     d46:	09 f0       	breq	.+2      	; 0xd4a <UART_Printf+0xe4>
     d48:	7b c0       	rjmp	.+246    	; 0xe40 <UART_Printf+0x1da>
				   ch = *ptr;
				}
			}
			else
			{
			  v_numOfDigitsToTransmit_u8 = C_MaxDigitsToTransmitUsingPrintf_U8;
     d4a:	2f ef       	ldi	r18, 0xFF	; 255
				ch = va_arg(argp, int);
				UART_TxChar(ch);
				break;

			case 'd':    /* Argument type is of signed integer, hence read 16bit data from the argp */
				v_num_s16 = va_arg(argp, sint16_t);
     d4c:	68 01       	movw	r12, r16
     d4e:	f2 e0       	ldi	r31, 0x02	; 2
     d50:	cf 0e       	add	r12, r31
     d52:	d1 1c       	adc	r13, r1
     d54:	f8 01       	movw	r30, r16
     d56:	00 81       	ld	r16, Z
     d58:	11 81       	ldd	r17, Z+1	; 0x01
				if(v_num_s16<0)
     d5a:	17 ff       	sbrs	r17, 7
     d5c:	08 c0       	rjmp	.+16     	; 0xd6e <UART_Printf+0x108>
				 { /* If the number is -ve then display the 2's complement along with '-' sign */ 
				   v_num_s16 = -v_num_s16;
     d5e:	11 95       	neg	r17
     d60:	01 95       	neg	r16
     d62:	11 09       	sbc	r17, r1
				   UART_TxChar('-');
     d64:	8d e2       	ldi	r24, 0x2D	; 45
     d66:	2d 83       	std	Y+5, r18	; 0x05
     d68:	0e 94 24 05 	call	0xa48	; 0xa48 <UART_TxChar>
     d6c:	2d 81       	ldd	r18, Y+5	; 0x05
				 }
				UART_TxNumber(C_DECIMAL_U8,v_num_s16,v_numOfDigitsToTransmit_u8);
     d6e:	a8 01       	movw	r20, r16
     d70:	11 0f       	add	r17, r17
     d72:	66 0b       	sbc	r22, r22
     d74:	77 0b       	sbc	r23, r23
     d76:	43 c0       	rjmp	.+134    	; 0xdfe <UART_Printf+0x198>
			{
			  v_numOfDigitsToTransmit_u8 = C_MaxDigitsToTransmitUsingPrintf_U8;
			}				


			switch(ch)       /* Decode the type of the argument */
     d78:	84 34       	cpi	r24, 0x44	; 68
     d7a:	71 f5       	brne	.+92     	; 0xdd8 <UART_Printf+0x172>
				   ch = *ptr;
				}
			}
			else
			{
			  v_numOfDigitsToTransmit_u8 = C_MaxDigitsToTransmitUsingPrintf_U8;
     d7c:	2f ef       	ldi	r18, 0xFF	; 255
				 }
				UART_TxNumber(C_DECIMAL_U8,v_num_s16,v_numOfDigitsToTransmit_u8);
				break;
				
			case 'D':    /* Argument type is of integer, hence read 16bit data from the argp */
				v_num_s32 = va_arg(argp, sint32_t);				
     d7e:	68 01       	movw	r12, r16
     d80:	f4 e0       	ldi	r31, 0x04	; 4
     d82:	cf 0e       	add	r12, r31
     d84:	d1 1c       	adc	r13, r1
     d86:	f8 01       	movw	r30, r16
     d88:	40 81       	ld	r20, Z
     d8a:	51 81       	ldd	r21, Z+1	; 0x01
     d8c:	62 81       	ldd	r22, Z+2	; 0x02
     d8e:	73 81       	ldd	r23, Z+3	; 0x03
				if(v_num_s32<0)
     d90:	77 ff       	sbrs	r23, 7
     d92:	35 c0       	rjmp	.+106    	; 0xdfe <UART_Printf+0x198>
				 { /* If the number is -ve then display the 2's complement along with '-' sign */
				   v_num_s32 = -v_num_s32;
     d94:	70 95       	com	r23
     d96:	60 95       	com	r22
     d98:	50 95       	com	r21
     d9a:	41 95       	neg	r20
     d9c:	5f 4f       	sbci	r21, 0xFF	; 255
     d9e:	6f 4f       	sbci	r22, 0xFF	; 255
     da0:	7f 4f       	sbci	r23, 0xFF	; 255
				   UART_TxChar('-');
     da2:	8d e2       	ldi	r24, 0x2D	; 45
     da4:	2d 83       	std	Y+5, r18	; 0x05
     da6:	49 83       	std	Y+1, r20	; 0x01
     da8:	5a 83       	std	Y+2, r21	; 0x02
     daa:	6b 83       	std	Y+3, r22	; 0x03
     dac:	7c 83       	std	Y+4, r23	; 0x04
     dae:	0e 94 24 05 	call	0xa48	; 0xa48 <UART_TxChar>
     db2:	7c 81       	ldd	r23, Y+4	; 0x04
     db4:	6b 81       	ldd	r22, Y+3	; 0x03
     db6:	5a 81       	ldd	r21, Y+2	; 0x02
     db8:	49 81       	ldd	r20, Y+1	; 0x01
     dba:	2d 81       	ldd	r18, Y+5	; 0x05
     dbc:	20 c0       	rjmp	.+64     	; 0xdfe <UART_Printf+0x198>
			{
			  v_numOfDigitsToTransmit_u8 = C_MaxDigitsToTransmitUsingPrintf_U8;
			}				


			switch(ch)       /* Decode the type of the argument */
     dbe:	85 37       	cpi	r24, 0x75	; 117
     dc0:	01 f5       	brne	.+64     	; 0xe02 <UART_Printf+0x19c>
				   ch = *ptr;
				}
			}
			else
			{
			  v_numOfDigitsToTransmit_u8 = C_MaxDigitsToTransmitUsingPrintf_U8;
     dc2:	2f ef       	ldi	r18, 0xFF	; 255
				 }
				UART_TxNumber(C_DECIMAL_U8,v_num_s32,v_numOfDigitsToTransmit_u8);			
				break;	

			case 'u':    /* Argument type is of unsigned integer, hence read 16bit unsigned data */
				v_num_u16 = va_arg(argp, uint16_t);			
     dc4:	68 01       	movw	r12, r16
     dc6:	f2 e0       	ldi	r31, 0x02	; 2
     dc8:	cf 0e       	add	r12, r31
     dca:	d1 1c       	adc	r13, r1
				UART_TxNumber(C_DECIMAL_U8,v_num_u16,v_numOfDigitsToTransmit_u8);				
     dcc:	f8 01       	movw	r30, r16
     dce:	40 81       	ld	r20, Z
     dd0:	51 81       	ldd	r21, Z+1	; 0x01
     dd2:	60 e0       	ldi	r22, 0x00	; 0
     dd4:	70 e0       	ldi	r23, 0x00	; 0
     dd6:	13 c0       	rjmp	.+38     	; 0xdfe <UART_Printf+0x198>
			{
			  v_numOfDigitsToTransmit_u8 = C_MaxDigitsToTransmitUsingPrintf_U8;
			}				


			switch(ch)       /* Decode the type of the argument */
     dd8:	85 34       	cpi	r24, 0x45	; 69
     dda:	08 f4       	brcc	.+2      	; 0xdde <UART_Printf+0x178>
     ddc:	74 c0       	rjmp	.+232    	; 0xec6 <UART_Printf+0x260>
     dde:	83 35       	cpi	r24, 0x53	; 83
     de0:	09 f4       	brne	.+2      	; 0xde4 <UART_Printf+0x17e>
     de2:	5e c0       	rjmp	.+188    	; 0xea0 <UART_Printf+0x23a>
     de4:	85 35       	cpi	r24, 0x55	; 85
     de6:	09 f0       	breq	.+2      	; 0xdea <UART_Printf+0x184>
     de8:	4b c0       	rjmp	.+150    	; 0xe80 <UART_Printf+0x21a>
				   ch = *ptr;
				}
			}
			else
			{
			  v_numOfDigitsToTransmit_u8 = C_MaxDigitsToTransmitUsingPrintf_U8;
     dea:	2f ef       	ldi	r18, 0xFF	; 255
				v_num_u16 = va_arg(argp, uint16_t);			
				UART_TxNumber(C_DECIMAL_U8,v_num_u16,v_numOfDigitsToTransmit_u8);				
				break;
			
			case 'U':    /* Argument type is of integer, hence read 32bit unsigend data */
				v_num_u32 = va_arg(argp, uint32_t);			
     dec:	68 01       	movw	r12, r16
     dee:	f4 e0       	ldi	r31, 0x04	; 4
     df0:	cf 0e       	add	r12, r31
     df2:	d1 1c       	adc	r13, r1
				UART_TxNumber(C_DECIMAL_U8,v_num_u32,v_numOfDigitsToTransmit_u8);				
     df4:	f8 01       	movw	r30, r16
     df6:	40 81       	ld	r20, Z
     df8:	51 81       	ldd	r21, Z+1	; 0x01
     dfa:	62 81       	ldd	r22, Z+2	; 0x02
     dfc:	73 81       	ldd	r23, Z+3	; 0x03
     dfe:	8a e0       	ldi	r24, 0x0A	; 10
     e00:	1c c0       	rjmp	.+56     	; 0xe3a <UART_Printf+0x1d4>
			{
			  v_numOfDigitsToTransmit_u8 = C_MaxDigitsToTransmitUsingPrintf_U8;
			}				


			switch(ch)       /* Decode the type of the argument */
     e02:	88 37       	cpi	r24, 0x78	; 120
     e04:	09 f0       	breq	.+2      	; 0xe08 <UART_Printf+0x1a2>
     e06:	4a c0       	rjmp	.+148    	; 0xe9c <UART_Printf+0x236>
				   ch = *ptr;
				}
			}
			else
			{
			  v_numOfDigitsToTransmit_u8 = C_MaxDigitsToTransmitUsingPrintf_U8;
     e08:	2f ef       	ldi	r18, 0xFF	; 255
				v_num_u32 = va_arg(argp, uint32_t);			
				UART_TxNumber(C_DECIMAL_U8,v_num_u32,v_numOfDigitsToTransmit_u8);				
				break;			

			case 'x':  /* Argument type is of hex, hence hexadecimal data from the argp */
				v_num_u16 = va_arg(argp, uint16_t);				
     e0a:	68 01       	movw	r12, r16
     e0c:	f2 e0       	ldi	r31, 0x02	; 2
     e0e:	cf 0e       	add	r12, r31
     e10:	d1 1c       	adc	r13, r1
				UART_TxNumber(C_HEX_U8,v_num_u16,v_numOfDigitsToTransmit_u8);			
     e12:	f8 01       	movw	r30, r16
     e14:	40 81       	ld	r20, Z
     e16:	51 81       	ldd	r21, Z+1	; 0x01
     e18:	60 e0       	ldi	r22, 0x00	; 0
     e1a:	70 e0       	ldi	r23, 0x00	; 0
     e1c:	0d c0       	rjmp	.+26     	; 0xe38 <UART_Printf+0x1d2>
			{
			  v_numOfDigitsToTransmit_u8 = C_MaxDigitsToTransmitUsingPrintf_U8;
			}				


			switch(ch)       /* Decode the type of the argument */
     e1e:	88 35       	cpi	r24, 0x58	; 88
     e20:	09 f0       	breq	.+2      	; 0xe24 <UART_Printf+0x1be>
     e22:	87 cf       	rjmp	.-242    	; 0xd32 <UART_Printf+0xcc>
				   ch = *ptr;
				}
			}
			else
			{
			  v_numOfDigitsToTransmit_u8 = C_MaxDigitsToTransmitUsingPrintf_U8;
     e24:	2f ef       	ldi	r18, 0xFF	; 255
				v_num_u16 = va_arg(argp, uint16_t);				
				UART_TxNumber(C_HEX_U8,v_num_u16,v_numOfDigitsToTransmit_u8);			
				break;

			case 'X':  /* Argument type is of hex, hence hexadecimal data from the argp */
				v_num_u32 = va_arg(argp, uint32_t);						
     e26:	68 01       	movw	r12, r16
     e28:	f4 e0       	ldi	r31, 0x04	; 4
     e2a:	cf 0e       	add	r12, r31
     e2c:	d1 1c       	adc	r13, r1
				UART_TxNumber(C_HEX_U8,v_num_u32,v_numOfDigitsToTransmit_u8);				
     e2e:	f8 01       	movw	r30, r16
     e30:	40 81       	ld	r20, Z
     e32:	51 81       	ldd	r21, Z+1	; 0x01
     e34:	62 81       	ldd	r22, Z+2	; 0x02
     e36:	73 81       	ldd	r23, Z+3	; 0x03
     e38:	80 e1       	ldi	r24, 0x10	; 16
     e3a:	0e 94 71 05 	call	0xae2	; 0xae2 <UART_TxNumber>
     e3e:	39 c0       	rjmp	.+114    	; 0xeb2 <UART_Printf+0x24c>
			{
			  v_numOfDigitsToTransmit_u8 = C_MaxDigitsToTransmitUsingPrintf_U8;
			}				


			switch(ch)       /* Decode the type of the argument */
     e40:	82 36       	cpi	r24, 0x62	; 98
     e42:	e1 f5       	brne	.+120    	; 0xebc <UART_Printf+0x256>
				   ch = *ptr;
				}
			}
			else
			{
			  v_numOfDigitsToTransmit_u8 = C_MaxDigitsToTransmitUsingPrintf_U8;
     e44:	2f ef       	ldi	r18, 0xFF	; 255
				UART_TxNumber(C_HEX_U8,v_num_u32,v_numOfDigitsToTransmit_u8);				
				break;

			
			case 'b':  /* Argument type is of binary,Read int and convert to binary */
				v_num_u16 = va_arg(argp, uint16_t);		
     e46:	68 01       	movw	r12, r16
     e48:	f2 e0       	ldi	r31, 0x02	; 2
     e4a:	cf 0e       	add	r12, r31
     e4c:	d1 1c       	adc	r13, r1
     e4e:	f8 01       	movw	r30, r16
     e50:	60 81       	ld	r22, Z
     e52:	71 81       	ldd	r23, Z+1	; 0x01
				
				if(v_numOfDigitsToTransmit_u8 == C_MaxDigitsToTransmitUsingPrintf_U8)
     e54:	2f 3f       	cpi	r18, 0xFF	; 255
     e56:	09 f4       	brne	.+2      	; 0xe5a <UART_Printf+0x1f4>
				   v_numOfDigitsToTransmit_u8 = 16;
     e58:	20 e1       	ldi	r18, 0x10	; 16
               
				UART_TxNumber(C_BINARY_U8,v_num_u16,v_numOfDigitsToTransmit_u8);			
     e5a:	80 e0       	ldi	r24, 0x00	; 0
     e5c:	90 e0       	ldi	r25, 0x00	; 0
     e5e:	0c c0       	rjmp	.+24     	; 0xe78 <UART_Printf+0x212>
				break;

			case 'B':  /* Argument type is of binary,Read int and convert to binary */
				v_num_u32 = va_arg(argp, uint32_t);			
     e60:	68 01       	movw	r12, r16
     e62:	f4 e0       	ldi	r31, 0x04	; 4
     e64:	cf 0e       	add	r12, r31
     e66:	d1 1c       	adc	r13, r1
     e68:	f8 01       	movw	r30, r16
     e6a:	60 81       	ld	r22, Z
     e6c:	71 81       	ldd	r23, Z+1	; 0x01
     e6e:	82 81       	ldd	r24, Z+2	; 0x02
     e70:	93 81       	ldd	r25, Z+3	; 0x03
                
				if(v_numOfDigitsToTransmit_u8 == C_MaxDigitsToTransmitUsingPrintf_U8)
     e72:	2f 3f       	cpi	r18, 0xFF	; 255
     e74:	09 f4       	brne	.+2      	; 0xe78 <UART_Printf+0x212>
				   v_numOfDigitsToTransmit_u8 = 32;		
     e76:	20 e2       	ldi	r18, 0x20	; 32
     e78:	42 2f       	mov	r20, r18
     e7a:	0e 94 28 05 	call	0xa50	; 0xa50 <UART_TxNumber.part.0>
     e7e:	19 c0       	rjmp	.+50     	; 0xeb2 <UART_Printf+0x24c>
			{
			  v_numOfDigitsToTransmit_u8 = C_MaxDigitsToTransmitUsingPrintf_U8;
			}				


			switch(ch)       /* Decode the type of the argument */
     e80:	86 34       	cpi	r24, 0x46	; 70
     e82:	e1 f4       	brne	.+56     	; 0xebc <UART_Printf+0x256>


			case 'F':
			case 'f': /* Argument type is of float, hence read double data from the argp */
#if (Enable_UART_TxFloatNumber==1)				
				v_floatNum_f32 = va_arg(argp, double);				
     e84:	68 01       	movw	r12, r16
     e86:	f4 e0       	ldi	r31, 0x04	; 4
     e88:	cf 0e       	add	r12, r31
     e8a:	d1 1c       	adc	r13, r1
				UART_TxFloatNumber(v_floatNum_f32);
     e8c:	f8 01       	movw	r30, r16
     e8e:	60 81       	ld	r22, Z
     e90:	71 81       	ldd	r23, Z+1	; 0x01
     e92:	82 81       	ldd	r24, Z+2	; 0x02
     e94:	93 81       	ldd	r25, Z+3	; 0x03
     e96:	0e 94 fc 05 	call	0xbf8	; 0xbf8 <UART_TxFloatNumber>
     e9a:	0b c0       	rjmp	.+22     	; 0xeb2 <UART_Printf+0x24c>
			{
			  v_numOfDigitsToTransmit_u8 = C_MaxDigitsToTransmitUsingPrintf_U8;
			}				


			switch(ch)       /* Decode the type of the argument */
     e9c:	83 37       	cpi	r24, 0x73	; 115
     e9e:	71 f4       	brne	.+28     	; 0xebc <UART_Printf+0x256>
				break;                


			case 'S':
			case 's': /* Argument type is of string, hence get the pointer to sting passed */
				str = va_arg(argp, char *);
     ea0:	68 01       	movw	r12, r16
     ea2:	f2 e0       	ldi	r31, 0x02	; 2
     ea4:	cf 0e       	add	r12, r31
     ea6:	d1 1c       	adc	r13, r1
				UART_TxString(str);			
     ea8:	f8 01       	movw	r30, r16
     eaa:	80 81       	ld	r24, Z
     eac:	91 81       	ldd	r25, Z+1	; 0x01
     eae:	0e 94 65 05 	call	0xaca	; 0xaca <UART_TxString>
				break;                


			case 'S':
			case 's': /* Argument type is of string, hence get the pointer to sting passed */
				str = va_arg(argp, char *);
     eb2:	86 01       	movw	r16, r12
				UART_TxString(str);			
				break;
     eb4:	03 c0       	rjmp	.+6      	; 0xebc <UART_Printf+0x256>
			}
		}
		else
		{
			/* As '%' is not detected transmit the char passed */
			UART_TxChar(ch);
     eb6:	0e 94 24 05 	call	0xa48	; 0xa48 <UART_TxChar>
     eba:	76 01       	movw	r14, r12


	va_start(argp, argList);

	/* Loop through the list to extract all the input arguments */
	for(ptr = argList; *ptr != '\0'; ptr++)
     ebc:	67 01       	movw	r12, r14
     ebe:	ff ef       	ldi	r31, 0xFF	; 255
     ec0:	cf 1a       	sub	r12, r31
     ec2:	df 0a       	sbc	r13, r31
     ec4:	e2 ce       	rjmp	.-572    	; 0xc8a <UART_Printf+0x24>
			{
			  v_numOfDigitsToTransmit_u8 = C_MaxDigitsToTransmitUsingPrintf_U8;
			}				


			switch(ch)       /* Decode the type of the argument */
     ec6:	82 34       	cpi	r24, 0x42	; 66
     ec8:	09 f0       	breq	.+2      	; 0xecc <UART_Printf+0x266>
     eca:	27 cf       	rjmp	.-434    	; 0xd1a <UART_Printf+0xb4>
               
				UART_TxNumber(C_BINARY_U8,v_num_u16,v_numOfDigitsToTransmit_u8);			
				break;

			case 'B':  /* Argument type is of binary,Read int and convert to binary */
				v_num_u32 = va_arg(argp, uint32_t);			
     ecc:	68 01       	movw	r12, r16
     ece:	f4 e0       	ldi	r31, 0x04	; 4
     ed0:	cf 0e       	add	r12, r31
     ed2:	d1 1c       	adc	r13, r1
     ed4:	f8 01       	movw	r30, r16
     ed6:	60 81       	ld	r22, Z
     ed8:	71 81       	ldd	r23, Z+1	; 0x01
     eda:	82 81       	ldd	r24, Z+2	; 0x02
     edc:	93 81       	ldd	r25, Z+3	; 0x03
     ede:	cb cf       	rjmp	.-106    	; 0xe76 <UART_Printf+0x210>
			{
			  v_numOfDigitsToTransmit_u8 = C_MaxDigitsToTransmitUsingPrintf_U8;
			}				


			switch(ch)       /* Decode the type of the argument */
     ee0:	85 32       	cpi	r24, 0x25	; 37
     ee2:	61 f7       	brne	.-40     	; 0xebc <UART_Printf+0x256>
				str = va_arg(argp, char *);
				UART_TxString(str);			
				break;

			case '%':
				UART_TxChar('%');
     ee4:	85 e2       	ldi	r24, 0x25	; 37
     ee6:	0e 94 24 05 	call	0xa48	; 0xa48 <UART_TxChar>
				break;
     eea:	e8 cf       	rjmp	.-48     	; 0xebc <UART_Printf+0x256>
			UART_TxChar(ch);
		}
	}

	va_end(argp);
}
     eec:	0f 90       	pop	r0
     eee:	0f 90       	pop	r0
     ef0:	0f 90       	pop	r0
     ef2:	0f 90       	pop	r0
     ef4:	0f 90       	pop	r0
     ef6:	df 91       	pop	r29
     ef8:	cf 91       	pop	r28
     efa:	1f 91       	pop	r17
     efc:	0f 91       	pop	r16
     efe:	ff 90       	pop	r15
     f00:	ef 90       	pop	r14
     f02:	df 90       	pop	r13
     f04:	cf 90       	pop	r12
     f06:	08 95       	ret

00000f08 <gpio_test>:

void gpio_test()
{   
    uint8_t i;
    
	UART_Printf("\n\rConnect any IO Pins to buzzer, relays, leds ");
     f08:	84 e7       	ldi	r24, 0x74	; 116
     f0a:	90 e0       	ldi	r25, 0x00	; 0
     f0c:	9f 93       	push	r25
     f0e:	8f 93       	push	r24
     f10:	0e 94 33 06 	call	0xc66	; 0xc66 <UART_Printf>
    UART_Printf("\n\rMake connections and hit 'k' to test ");
     f14:	83 ea       	ldi	r24, 0xA3	; 163
     f16:	90 e0       	ldi	r25, 0x00	; 0
     f18:	9f 93       	push	r25
     f1a:	8f 93       	push	r24
     f1c:	0e 94 33 06 	call	0xc66	; 0xc66 <UART_Printf>
    while(UART_RxChar()!='k');
     f20:	0f 90       	pop	r0
     f22:	0f 90       	pop	r0
     f24:	0f 90       	pop	r0
     f26:	0f 90       	pop	r0
     f28:	0e 94 20 05 	call	0xa40	; 0xa40 <UART_RxChar>
     f2c:	8b 36       	cpi	r24, 0x6B	; 107
     f2e:	e1 f7       	brne	.-8      	; 0xf28 <gpio_test+0x20>
	
	DDRA = C_PortOutput_U8;
     f30:	8f ef       	ldi	r24, 0xFF	; 255
     f32:	8a bb       	out	0x1a, r24	; 26
    DDRB = C_PortOutput_U8;
     f34:	87 bb       	out	0x17, r24	; 23
    DDRC = C_PortOutput_U8;
     f36:	84 bb       	out	0x14, r24	; 20
    DDRD = C_PortOutput_U8; 
     f38:	81 bb       	out	0x11, r24	; 17
             
    while(1)
    {
       for(i=0;i<2;i++)
	   {
	    PORTA = 0xff; /* Turn ON all the leds connected to Ports */
     f3a:	cf ef       	ldi	r28, 0xFF	; 255
        DELAY_ms(100);
	   }
	   
	   for(i=0;i<8;i++)
	   {
		 PORTA = 1<<i; /* Turn ON and OFF one LED at a time */
     f3c:	ee 24       	eor	r14, r14
     f3e:	e3 94       	inc	r14
     f40:	f1 2c       	mov	r15, r1
		 DELAY_ms(100);
	   }
	   
	   for(i=0;i<8;i++)
	   	{
		   PORTA = 0x80>>i; /* Turn ON and OFF one LED at a time */
     f42:	90 e8       	ldi	r25, 0x80	; 128
     f44:	c9 2e       	mov	r12, r25
     f46:	d1 2c       	mov	r13, r1
     f48:	12 e0       	ldi	r17, 0x02	; 2
             
    while(1)
    {
       for(i=0;i<2;i++)
	   {
	    PORTA = 0xff; /* Turn ON all the leds connected to Ports */
     f4a:	cb bb       	out	0x1b, r28	; 27
        PORTB = 0xff;
     f4c:	c8 bb       	out	0x18, r28	; 24
        PORTC = 0xff;
     f4e:	c5 bb       	out	0x15, r28	; 21
        PORTD = 0xff;
     f50:	c2 bb       	out	0x12, r28	; 18
        DELAY_ms(100);
     f52:	84 e6       	ldi	r24, 0x64	; 100
     f54:	90 e0       	ldi	r25, 0x00	; 0
     f56:	0e 94 69 00 	call	0xd2	; 0xd2 <DELAY_ms>
        
        PORTA = 0x00; /* Turn OFF all the leds connected to Ports */
     f5a:	1b ba       	out	0x1b, r1	; 27
        PORTB = 0x00;
     f5c:	18 ba       	out	0x18, r1	; 24
        PORTC = 0x00;
     f5e:	15 ba       	out	0x15, r1	; 21
        PORTD = 0x00;
     f60:	12 ba       	out	0x12, r1	; 18
        DELAY_ms(100);
     f62:	84 e6       	ldi	r24, 0x64	; 100
     f64:	90 e0       	ldi	r25, 0x00	; 0
     f66:	0e 94 69 00 	call	0xd2	; 0xd2 <DELAY_ms>
    DDRC = C_PortOutput_U8;
    DDRD = C_PortOutput_U8; 
             
    while(1)
    {
       for(i=0;i<2;i++)
     f6a:	11 30       	cpi	r17, 0x01	; 1
     f6c:	11 f0       	breq	.+4      	; 0xf72 <gpio_test+0x6a>
     f6e:	11 e0       	ldi	r17, 0x01	; 1
     f70:	ec cf       	rjmp	.-40     	; 0xf4a <gpio_test+0x42>
     f72:	00 e0       	ldi	r16, 0x00	; 0
     f74:	10 e0       	ldi	r17, 0x00	; 0
        DELAY_ms(100);
	   }
	   
	   for(i=0;i<8;i++)
	   {
		 PORTA = 1<<i; /* Turn ON and OFF one LED at a time */
     f76:	c7 01       	movw	r24, r14
     f78:	00 2e       	mov	r0, r16
     f7a:	01 c0       	rjmp	.+2      	; 0xf7e <gpio_test+0x76>
     f7c:	88 0f       	add	r24, r24
     f7e:	0a 94       	dec	r0
     f80:	ea f7       	brpl	.-6      	; 0xf7c <gpio_test+0x74>
     f82:	8b bb       	out	0x1b, r24	; 27
         PORTB = 1<<i;
     f84:	88 bb       	out	0x18, r24	; 24
         PORTC = 1<<i;
     f86:	85 bb       	out	0x15, r24	; 21
         PORTD = 1<<i;
     f88:	82 bb       	out	0x12, r24	; 18
		 DELAY_ms(100);
     f8a:	84 e6       	ldi	r24, 0x64	; 100
     f8c:	90 e0       	ldi	r25, 0x00	; 0
     f8e:	0e 94 69 00 	call	0xd2	; 0xd2 <DELAY_ms>
     f92:	0f 5f       	subi	r16, 0xFF	; 255
     f94:	1f 4f       	sbci	r17, 0xFF	; 255
        PORTC = 0x00;
        PORTD = 0x00;
        DELAY_ms(100);
	   }
	   
	   for(i=0;i<8;i++)
     f96:	08 30       	cpi	r16, 0x08	; 8
     f98:	11 05       	cpc	r17, r1
     f9a:	69 f7       	brne	.-38     	; 0xf76 <gpio_test+0x6e>
     f9c:	00 e0       	ldi	r16, 0x00	; 0
     f9e:	10 e0       	ldi	r17, 0x00	; 0
		 DELAY_ms(100);
	   }
	   
	   for(i=0;i<8;i++)
	   	{
		   PORTA = 0x80>>i; /* Turn ON and OFF one LED at a time */
     fa0:	c6 01       	movw	r24, r12
     fa2:	00 2e       	mov	r0, r16
     fa4:	02 c0       	rjmp	.+4      	; 0xfaa <gpio_test+0xa2>
     fa6:	95 95       	asr	r25
     fa8:	87 95       	ror	r24
     faa:	0a 94       	dec	r0
     fac:	e2 f7       	brpl	.-8      	; 0xfa6 <gpio_test+0x9e>
     fae:	8b bb       	out	0x1b, r24	; 27
		   PORTB = 0x80>>i;
     fb0:	88 bb       	out	0x18, r24	; 24
		   PORTC = 0x80>>i;
     fb2:	85 bb       	out	0x15, r24	; 21
		   PORTD = 0x80>>i;
     fb4:	82 bb       	out	0x12, r24	; 18
		  DELAY_ms(100);
     fb6:	84 e6       	ldi	r24, 0x64	; 100
     fb8:	90 e0       	ldi	r25, 0x00	; 0
     fba:	0e 94 69 00 	call	0xd2	; 0xd2 <DELAY_ms>
     fbe:	0f 5f       	subi	r16, 0xFF	; 255
     fc0:	1f 4f       	sbci	r17, 0xFF	; 255
         PORTC = 1<<i;
         PORTD = 1<<i;
		 DELAY_ms(100);
	   }
	   
	   for(i=0;i<8;i++)
     fc2:	08 30       	cpi	r16, 0x08	; 8
     fc4:	11 05       	cpc	r17, r1
     fc6:	61 f7       	brne	.-40     	; 0xfa0 <gpio_test+0x98>
     fc8:	bf cf       	rjmp	.-130    	; 0xf48 <gpio_test+0x40>

00000fca <LCD_8bit_test>:
					On board LCD TEST in 8 bit mode.
 *****************************************************LCD TEST**************************************/

void LCD_8bit_test()
{     
    UART_TxString("\n\r LCD DataBus:PC    RS-PB.0  RW-PB.1  EN-PB.2 ");
     fca:	8b ec       	ldi	r24, 0xCB	; 203
     fcc:	90 e0       	ldi	r25, 0x00	; 0
     fce:	0e 94 65 05 	call	0xaca	; 0xaca <UART_TxString>
    UART_Printf("\n\r Make connections and hit 'k' to test ");
     fd2:	8b ef       	ldi	r24, 0xFB	; 251
     fd4:	90 e0       	ldi	r25, 0x00	; 0
     fd6:	9f 93       	push	r25
     fd8:	8f 93       	push	r24
     fda:	0e 94 33 06 	call	0xc66	; 0xc66 <UART_Printf>
    while(UART_RxChar()!='k');
     fde:	0f 90       	pop	r0
     fe0:	0f 90       	pop	r0
     fe2:	0e 94 20 05 	call	0xa40	; 0xa40 <UART_RxChar>
     fe6:	8b 36       	cpi	r24, 0x6B	; 107
     fe8:	e1 f7       	brne	.-8      	; 0xfe2 <LCD_8bit_test+0x18>
    LCD_SetUp(PB_0,PB_1,PB_2,PC_0,PC_1,PC_2,PC_3,PC_4,PC_5,PC_6,PC_7);
     fea:	87 e1       	ldi	r24, 0x17	; 23
     fec:	8f 93       	push	r24
     fee:	86 e1       	ldi	r24, 0x16	; 22
     ff0:	8f 93       	push	r24
     ff2:	85 e1       	ldi	r24, 0x15	; 21
     ff4:	88 2e       	mov	r8, r24
     ff6:	94 e1       	ldi	r25, 0x14	; 20
     ff8:	a9 2e       	mov	r10, r25
     ffa:	23 e1       	ldi	r18, 0x13	; 19
     ffc:	c2 2e       	mov	r12, r18
     ffe:	32 e1       	ldi	r19, 0x12	; 18
    1000:	e3 2e       	mov	r14, r19
    1002:	01 e1       	ldi	r16, 0x11	; 17
    1004:	20 e1       	ldi	r18, 0x10	; 16
    1006:	4a e0       	ldi	r20, 0x0A	; 10
    1008:	69 e0       	ldi	r22, 0x09	; 9
    100a:	88 e0       	ldi	r24, 0x08	; 8
    100c:	0e 94 54 03 	call	0x6a8	; 0x6a8 <LCD_SetUp>
    LCD_Init(2,16);
    1010:	60 e1       	ldi	r22, 0x10	; 16
    1012:	82 e0       	ldi	r24, 0x02	; 2
    1014:	0e 94 f4 03 	call	0x7e8	; 0x7e8 <LCD_Init>
    DELAY_ms(100);
    1018:	84 e6       	ldi	r24, 0x64	; 100
    101a:	90 e0       	ldi	r25, 0x00	; 0
    101c:	0e 94 69 00 	call	0xd2	; 0xd2 <DELAY_ms>
    LCD_DisplayString("Explore Embedded");
    1020:	84 e2       	ldi	r24, 0x24	; 36
    1022:	91 e0       	ldi	r25, 0x01	; 1
    1024:	0e 94 7b 04 	call	0x8f6	; 0x8f6 <LCD_DisplayString>
    LCD_DisplayString("Lcd 8-bit Mode");
    1028:	85 e3       	ldi	r24, 0x35	; 53
    102a:	91 e0       	ldi	r25, 0x01	; 1
    102c:	0e 94 7b 04 	call	0x8f6	; 0x8f6 <LCD_DisplayString>
    1030:	0f 90       	pop	r0
    1032:	0f 90       	pop	r0
    while(1);
    1034:	ff cf       	rjmp	.-2      	; 0x1034 <LCD_8bit_test+0x6a>

00001036 <LCD_4bit_test>:



void LCD_4bit_test()
{
    UART_TxString("\n\r LCD DataBus:PC4-PC7    RS-PB.0  RW-PB.1  EN-PB.2 ");
    1036:	84 e4       	ldi	r24, 0x44	; 68
    1038:	91 e0       	ldi	r25, 0x01	; 1
    103a:	0e 94 65 05 	call	0xaca	; 0xaca <UART_TxString>
    UART_Printf("\n\r Make connections and hit 'k' to test ");
    103e:	8b ef       	ldi	r24, 0xFB	; 251
    1040:	90 e0       	ldi	r25, 0x00	; 0
    1042:	9f 93       	push	r25
    1044:	8f 93       	push	r24
    1046:	0e 94 33 06 	call	0xc66	; 0xc66 <UART_Printf>
    while(UART_RxChar()!='k');
    104a:	0f 90       	pop	r0
    104c:	0f 90       	pop	r0
    104e:	0e 94 20 05 	call	0xa40	; 0xa40 <UART_RxChar>
    1052:	8b 36       	cpi	r24, 0x6B	; 107
    1054:	e1 f7       	brne	.-8      	; 0x104e <LCD_4bit_test+0x18>
    LCD_SetUp(PB_0,PB_1,PB_2,P_NC,P_NC,P_NC,P_NC,PC_4,PC_5,PC_6,PC_7);
    1056:	87 e1       	ldi	r24, 0x17	; 23
    1058:	8f 93       	push	r24
    105a:	86 e1       	ldi	r24, 0x16	; 22
    105c:	8f 93       	push	r24
    105e:	85 e1       	ldi	r24, 0x15	; 21
    1060:	88 2e       	mov	r8, r24
    1062:	94 e1       	ldi	r25, 0x14	; 20
    1064:	a9 2e       	mov	r10, r25
    1066:	cc 24       	eor	r12, r12
    1068:	ca 94       	dec	r12
    106a:	ee 24       	eor	r14, r14
    106c:	ea 94       	dec	r14
    106e:	0f ef       	ldi	r16, 0xFF	; 255
    1070:	2f ef       	ldi	r18, 0xFF	; 255
    1072:	4a e0       	ldi	r20, 0x0A	; 10
    1074:	69 e0       	ldi	r22, 0x09	; 9
    1076:	88 e0       	ldi	r24, 0x08	; 8
    1078:	0e 94 54 03 	call	0x6a8	; 0x6a8 <LCD_SetUp>
    LCD_Init(2,16);
    107c:	60 e1       	ldi	r22, 0x10	; 16
    107e:	82 e0       	ldi	r24, 0x02	; 2
    1080:	0e 94 f4 03 	call	0x7e8	; 0x7e8 <LCD_Init>
    DELAY_ms(100);
    1084:	84 e6       	ldi	r24, 0x64	; 100
    1086:	90 e0       	ldi	r25, 0x00	; 0
    1088:	0e 94 69 00 	call	0xd2	; 0xd2 <DELAY_ms>
    LCD_DisplayString("Explore Embedded");
    108c:	84 e2       	ldi	r24, 0x24	; 36
    108e:	91 e0       	ldi	r25, 0x01	; 1
    1090:	0e 94 7b 04 	call	0x8f6	; 0x8f6 <LCD_DisplayString>
    LCD_DisplayString("Lcd 4-bit Mode");
    1094:	89 e7       	ldi	r24, 0x79	; 121
    1096:	91 e0       	ldi	r25, 0x01	; 1
    1098:	0e 94 7b 04 	call	0x8f6	; 0x8f6 <LCD_DisplayString>
    109c:	0f 90       	pop	r0
    109e:	0f 90       	pop	r0
    while(1);
    10a0:	ff cf       	rjmp	.-2      	; 0x10a0 <LCD_4bit_test+0x6a>

000010a2 <seg_test>:
 *********************************************************TEST**************************************/

void seg_test()
{  
    unsigned char seg_code[]={0xf9,0xa4,0xb0,0x99};
    UART_TxString("\n\r Segment DataBus: PC Seg select: S1->PB.0 S2->PB.1 S3->PB.2 S4->PB.3  ");
    10a2:	88 e8       	ldi	r24, 0x88	; 136
    10a4:	91 e0       	ldi	r25, 0x01	; 1
    10a6:	0e 94 65 05 	call	0xaca	; 0xaca <UART_TxString>
    UART_Printf("\n\rMake connections and hit 'k' to test! ");
    10aa:	81 ed       	ldi	r24, 0xD1	; 209
    10ac:	91 e0       	ldi	r25, 0x01	; 1
    10ae:	9f 93       	push	r25
    10b0:	8f 93       	push	r24
    10b2:	0e 94 33 06 	call	0xc66	; 0xc66 <UART_Printf>
    while(UART_RxChar()!='k');
    10b6:	0f 90       	pop	r0
    10b8:	0f 90       	pop	r0
    10ba:	0e 94 20 05 	call	0xa40	; 0xa40 <UART_RxChar>
    10be:	8b 36       	cpi	r24, 0x6B	; 107
    10c0:	e1 f7       	brne	.-8      	; 0x10ba <seg_test+0x18>
    SegValueDirnReg = C_PortOutput_U8;
    10c2:	8f ef       	ldi	r24, 0xFF	; 255
    10c4:	84 bb       	out	0x14, r24	; 20
    SegSelectDirnReg = C_PortOutput_U8;
    10c6:	87 bb       	out	0x17, r24	; 23

    while(1)
    {
        SegmentSlection=SegOne;
    10c8:	cc 24       	eor	r12, r12
    10ca:	c3 94       	inc	r12
        SegmentValue = seg_code[0];
    10cc:	89 ef       	ldi	r24, 0xF9	; 249
    10ce:	d8 2e       	mov	r13, r24
        DELAY_us(10);
        SegmentSlection=SegTwo;
    10d0:	92 e0       	ldi	r25, 0x02	; 2
    10d2:	e9 2e       	mov	r14, r25
        SegmentValue = seg_code[1];
    10d4:	24 ea       	ldi	r18, 0xA4	; 164
    10d6:	f2 2e       	mov	r15, r18
        DELAY_us(10);
        SegmentSlection=SegThree;
    10d8:	04 e0       	ldi	r16, 0x04	; 4
        SegmentValue = seg_code[2];
    10da:	10 eb       	ldi	r17, 0xB0	; 176
        DELAY_us(10);
        SegmentSlection=SegFour;
    10dc:	d8 e0       	ldi	r29, 0x08	; 8
        SegmentValue = seg_code[3];
    10de:	c9 e9       	ldi	r28, 0x99	; 153
    SegValueDirnReg = C_PortOutput_U8;
    SegSelectDirnReg = C_PortOutput_U8;

    while(1)
    {
        SegmentSlection=SegOne;
    10e0:	c8 ba       	out	0x18, r12	; 24
        SegmentValue = seg_code[0];
    10e2:	d5 ba       	out	0x15, r13	; 21
        DELAY_us(10);
    10e4:	8a e0       	ldi	r24, 0x0A	; 10
    10e6:	90 e0       	ldi	r25, 0x00	; 0
    10e8:	0e 94 60 00 	call	0xc0	; 0xc0 <DELAY_us>
        SegmentSlection=SegTwo;
    10ec:	e8 ba       	out	0x18, r14	; 24
        SegmentValue = seg_code[1];
    10ee:	f5 ba       	out	0x15, r15	; 21
        DELAY_us(10);
    10f0:	8a e0       	ldi	r24, 0x0A	; 10
    10f2:	90 e0       	ldi	r25, 0x00	; 0
    10f4:	0e 94 60 00 	call	0xc0	; 0xc0 <DELAY_us>
        SegmentSlection=SegThree;
    10f8:	08 bb       	out	0x18, r16	; 24
        SegmentValue = seg_code[2];
    10fa:	15 bb       	out	0x15, r17	; 21
        DELAY_us(10);
    10fc:	8a e0       	ldi	r24, 0x0A	; 10
    10fe:	90 e0       	ldi	r25, 0x00	; 0
    1100:	0e 94 60 00 	call	0xc0	; 0xc0 <DELAY_us>
        SegmentSlection=SegFour;
    1104:	d8 bb       	out	0x18, r29	; 24
        SegmentValue = seg_code[3];
    1106:	c5 bb       	out	0x15, r28	; 21
        DELAY_us(10);
    1108:	8a e0       	ldi	r24, 0x0A	; 10
    110a:	90 e0       	ldi	r25, 0x00	; 0
    110c:	0e 94 60 00 	call	0xc0	; 0xc0 <DELAY_us>
    }
    1110:	e7 cf       	rjmp	.-50     	; 0x10e0 <seg_test+0x3e>

00001112 <rtc_test>:
/***************************************************RTC DS1307*************************************
 				Displays time on UART, reading from the RTC
 *********************************************************TEST**************************************/

void rtc_test()
{
    1112:	cf 93       	push	r28
    1114:	df 93       	push	r29
    1116:	cd b7       	in	r28, 0x3d	; 61
    1118:	de b7       	in	r29, 0x3e	; 62
    111a:	27 97       	sbiw	r28, 0x07	; 7
    111c:	0f b6       	in	r0, 0x3f	; 63
    111e:	f8 94       	cli
    1120:	de bf       	out	0x3e, r29	; 62
    1122:	0f be       	out	0x3f, r0	; 63
    1124:	cd bf       	out	0x3d, r28	; 61
    rtc_t rtc;
    UART_Printf("\n\rConnections SCL->PC.0 SDA->PC.1");
    1126:	8a ef       	ldi	r24, 0xFA	; 250
    1128:	91 e0       	ldi	r25, 0x01	; 1
    112a:	9f 93       	push	r25
    112c:	8f 93       	push	r24
    112e:	0e 94 33 06 	call	0xc66	; 0xc66 <UART_Printf>
    UART_Printf("\n\r Make connections and hit 'k' to test! ");
    1132:	8c e1       	ldi	r24, 0x1C	; 28
    1134:	92 e0       	ldi	r25, 0x02	; 2
    1136:	9f 93       	push	r25
    1138:	8f 93       	push	r24
    113a:	0e 94 33 06 	call	0xc66	; 0xc66 <UART_Printf>
    while(UART_RxChar()!='k');   
    113e:	0f 90       	pop	r0
    1140:	0f 90       	pop	r0
    1142:	0f 90       	pop	r0
    1144:	0f 90       	pop	r0
    1146:	0e 94 20 05 	call	0xa40	; 0xa40 <UART_RxChar>
    114a:	8b 36       	cpi	r24, 0x6B	; 107
    114c:	e1 f7       	brne	.-8      	; 0x1146 <rtc_test+0x34>

    RTC_Init();
    114e:	0e 94 87 04 	call	0x90e	; 0x90e <RTC_Init>
    rtc.hour = 0x10; //  10:40:20 am
    1152:	80 e1       	ldi	r24, 0x10	; 16
    1154:	8b 83       	std	Y+3, r24	; 0x03
    rtc.min =  0x40;
    1156:	80 e4       	ldi	r24, 0x40	; 64
    1158:	8a 83       	std	Y+2, r24	; 0x02
    rtc.sec =  0x00;
    115a:	19 82       	std	Y+1, r1	; 0x01

    rtc.date = 0x01; //1st Jan 2016
    115c:	81 e0       	ldi	r24, 0x01	; 1
    115e:	8d 83       	std	Y+5, r24	; 0x05
    rtc.month = 0x01;
    1160:	8e 83       	std	Y+6, r24	; 0x06
    rtc.year = 0x16;
    1162:	86 e1       	ldi	r24, 0x16	; 22
    1164:	8f 83       	std	Y+7, r24	; 0x07
    rtc.weekDay = 5; // Friday: 5th day of week considering monday as first day.
    1166:	85 e0       	ldi	r24, 0x05	; 5
    1168:	8c 83       	std	Y+4, r24	; 0x04



    /*##### Set the time and Date only once. Once the Time and Date is set, comment these lines
         and reflash the code. Else the time will be set every time the controller is reset*/
    RTC_SetDateTime(&rtc);  //  10:40:20 am, 1st Jan 2016
    116a:	ce 01       	movw	r24, r28
    116c:	01 96       	adiw	r24, 0x01	; 1
    116e:	0e 94 96 04 	call	0x92c	; 0x92c <RTC_SetDateTime>

    /* Display the Time and Date continuously */
    while(1)
    {
        RTC_GetDateTime(&rtc);
        UART_Printf("\n\rtime:%2x:%2x:%2x  \nDate:%2x/%2x/%2x",(uint16_t)rtc.hour,(uint16_t)rtc.min,(uint16_t)rtc.sec,(uint16_t)rtc.date,(uint16_t)rtc.month,(uint16_t)rtc.year);
    1172:	06 e4       	ldi	r16, 0x46	; 70
    1174:	12 e0       	ldi	r17, 0x02	; 2


    /* Display the Time and Date continuously */
    while(1)
    {
        RTC_GetDateTime(&rtc);
    1176:	ce 01       	movw	r24, r28
    1178:	01 96       	adiw	r24, 0x01	; 1
    117a:	0e 94 ba 04 	call	0x974	; 0x974 <RTC_GetDateTime>
        UART_Printf("\n\rtime:%2x:%2x:%2x  \nDate:%2x/%2x/%2x",(uint16_t)rtc.hour,(uint16_t)rtc.min,(uint16_t)rtc.sec,(uint16_t)rtc.date,(uint16_t)rtc.month,(uint16_t)rtc.year);
    117e:	8f 81       	ldd	r24, Y+7	; 0x07
    1180:	1f 92       	push	r1
    1182:	8f 93       	push	r24
    1184:	8e 81       	ldd	r24, Y+6	; 0x06
    1186:	1f 92       	push	r1
    1188:	8f 93       	push	r24
    118a:	8d 81       	ldd	r24, Y+5	; 0x05
    118c:	1f 92       	push	r1
    118e:	8f 93       	push	r24
    1190:	89 81       	ldd	r24, Y+1	; 0x01
    1192:	1f 92       	push	r1
    1194:	8f 93       	push	r24
    1196:	8a 81       	ldd	r24, Y+2	; 0x02
    1198:	1f 92       	push	r1
    119a:	8f 93       	push	r24
    119c:	8b 81       	ldd	r24, Y+3	; 0x03
    119e:	1f 92       	push	r1
    11a0:	8f 93       	push	r24
    11a2:	1f 93       	push	r17
    11a4:	0f 93       	push	r16
    11a6:	0e 94 33 06 	call	0xc66	; 0xc66 <UART_Printf>
    }
    11aa:	0f b6       	in	r0, 0x3f	; 63
    11ac:	f8 94       	cli
    11ae:	de bf       	out	0x3e, r29	; 62
    11b0:	0f be       	out	0x3f, r0	; 63
    11b2:	cd bf       	out	0x3d, r28	; 61
    11b4:	e0 cf       	rjmp	.-64     	; 0x1176 <rtc_test+0x64>

000011b6 <eeprom_test>:
 *****************************************************TEST*****************************************/
void eeprom_test(void)
{
    unsigned char eeprom_address = 0x00, write_char, read_char;

     UART_Printf("\n\r\n\rInbuilt Eeprom Test. Writing and reading A-Z to and from Eeprom.");
    11b6:	8c e6       	ldi	r24, 0x6C	; 108
    11b8:	92 e0       	ldi	r25, 0x02	; 2
    11ba:	9f 93       	push	r25
    11bc:	8f 93       	push	r24
    11be:	0e 94 33 06 	call	0xc66	; 0xc66 <UART_Printf>
    11c2:	0f 90       	pop	r0
    11c4:	0f 90       	pop	r0
    11c6:	c1 e4       	ldi	r28, 0x41	; 65
    11c8:	d0 e0       	ldi	r29, 0x00	; 0

    for(write_char='A';write_char<='Z';write_char++)
    {
        UART_Printf("\n\rEeprom Write: %c    ",write_char); //Print the message on UART
    11ca:	81 eb       	ldi	r24, 0xB1	; 177
    11cc:	e8 2e       	mov	r14, r24
    11ce:	82 e0       	ldi	r24, 0x02	; 2
    11d0:	f8 2e       	mov	r15, r24
        EEPROM_WriteByte(eeprom_address, write_char); // Write the data at memoryLocation    0x00


        read_char = EEPROM_ReadByte(eeprom_address);  // Read the data from memoryLocation 0x00
        UART_Printf("Eeprom Read: %c",read_char); //Print the message on UART
    11d2:	08 ec       	ldi	r16, 0xC8	; 200
    11d4:	12 e0       	ldi	r17, 0x02	; 2

     UART_Printf("\n\r\n\rInbuilt Eeprom Test. Writing and reading A-Z to and from Eeprom.");

    for(write_char='A';write_char<='Z';write_char++)
    {
        UART_Printf("\n\rEeprom Write: %c    ",write_char); //Print the message on UART
    11d6:	df 93       	push	r29
    11d8:	cf 93       	push	r28
    11da:	ff 92       	push	r15
    11dc:	ef 92       	push	r14
    11de:	0e 94 33 06 	call	0xc66	; 0xc66 <UART_Printf>
        EEPROM_WriteByte(eeprom_address, write_char); // Write the data at memoryLocation    0x00
    11e2:	6c 2f       	mov	r22, r28
    11e4:	80 e0       	ldi	r24, 0x00	; 0
    11e6:	90 e0       	ldi	r25, 0x00	; 0
    11e8:	0e 94 74 00 	call	0xe8	; 0xe8 <EEPROM_WriteByte>


        read_char = EEPROM_ReadByte(eeprom_address);  // Read the data from memoryLocation 0x00
    11ec:	80 e0       	ldi	r24, 0x00	; 0
    11ee:	90 e0       	ldi	r25, 0x00	; 0
    11f0:	0e 94 7c 00 	call	0xf8	; 0xf8 <EEPROM_ReadByte>
        UART_Printf("Eeprom Read: %c",read_char); //Print the message on UART
    11f4:	1f 92       	push	r1
    11f6:	8f 93       	push	r24
    11f8:	1f 93       	push	r17
    11fa:	0f 93       	push	r16
    11fc:	0e 94 33 06 	call	0xc66	; 0xc66 <UART_Printf>
    1200:	21 96       	adiw	r28, 0x01	; 1
{
    unsigned char eeprom_address = 0x00, write_char, read_char;

     UART_Printf("\n\r\n\rInbuilt Eeprom Test. Writing and reading A-Z to and from Eeprom.");

    for(write_char='A';write_char<='Z';write_char++)
    1202:	8d b7       	in	r24, 0x3d	; 61
    1204:	9e b7       	in	r25, 0x3e	; 62
    1206:	08 96       	adiw	r24, 0x08	; 8
    1208:	0f b6       	in	r0, 0x3f	; 63
    120a:	f8 94       	cli
    120c:	9e bf       	out	0x3e, r25	; 62
    120e:	0f be       	out	0x3f, r0	; 63
    1210:	8d bf       	out	0x3d, r24	; 61
    1212:	cb 35       	cpi	r28, 0x5B	; 91
    1214:	d1 05       	cpc	r29, r1
    1216:	f9 f6       	brne	.-66     	; 0x11d6 <eeprom_test+0x20>

        read_char = EEPROM_ReadByte(eeprom_address);  // Read the data from memoryLocation 0x00
        UART_Printf("Eeprom Read: %c",read_char); //Print the message on UART
    }
    
    while (1);    
    1218:	ff cf       	rjmp	.-2      	; 0x1218 <eeprom_test+0x62>

0000121a <adc_test>:
 *****************************************************TEST*****************************************/
void adc_test()
{ 
    uint16_t temp,light,pot;

    ADC_Init();
    121a:	0e 94 51 00 	call	0xa2	; 0xa2 <ADC_Init>
    while(1)
    {
        temp = ADC_GetAdcValue(0);
        pot = ADC_GetAdcValue(1);
        light = ADC_GetAdcValue(2);
        UART_Printf("\n\rtemp:%4d pot:%4d light:%4d", temp,pot,light);
    121e:	c8 ed       	ldi	r28, 0xD8	; 216
    1220:	d2 e0       	ldi	r29, 0x02	; 2

    ADC_Init();

    while(1)
    {
        temp = ADC_GetAdcValue(0);
    1222:	80 e0       	ldi	r24, 0x00	; 0
    1224:	0e 94 55 00 	call	0xaa	; 0xaa <ADC_GetAdcValue>
    1228:	18 2f       	mov	r17, r24
    122a:	09 2f       	mov	r16, r25
        pot = ADC_GetAdcValue(1);
    122c:	81 e0       	ldi	r24, 0x01	; 1
    122e:	0e 94 55 00 	call	0xaa	; 0xaa <ADC_GetAdcValue>
    1232:	f8 2e       	mov	r15, r24
    1234:	e9 2e       	mov	r14, r25
        light = ADC_GetAdcValue(2);
    1236:	82 e0       	ldi	r24, 0x02	; 2
    1238:	0e 94 55 00 	call	0xaa	; 0xaa <ADC_GetAdcValue>
        UART_Printf("\n\rtemp:%4d pot:%4d light:%4d", temp,pot,light);
    123c:	9f 93       	push	r25
    123e:	8f 93       	push	r24
    1240:	ef 92       	push	r14
    1242:	ff 92       	push	r15
    1244:	0f 93       	push	r16
    1246:	1f 93       	push	r17
    1248:	df 93       	push	r29
    124a:	cf 93       	push	r28
    124c:	0e 94 33 06 	call	0xc66	; 0xc66 <UART_Printf>

    }
    1250:	8d b7       	in	r24, 0x3d	; 61
    1252:	9e b7       	in	r25, 0x3e	; 62
    1254:	08 96       	adiw	r24, 0x08	; 8
    1256:	0f b6       	in	r0, 0x3f	; 63
    1258:	f8 94       	cli
    125a:	9e bf       	out	0x3e, r25	; 62
    125c:	0f be       	out	0x3f, r0	; 63
    125e:	8d bf       	out	0x3d, r24	; 61
    1260:	e0 cf       	rjmp	.-64     	; 0x1222 <adc_test+0x8>

00001262 <keypad_test>:
 				Displays keys pressed on 4x4 keypad on the uart
 *****************************************************TEST*******************************************/
void keypad_test()
{
    uint8_t key;
    UART_Printf("\n\rConnect KeyPad To PortC");
    1262:	85 ef       	ldi	r24, 0xF5	; 245
    1264:	92 e0       	ldi	r25, 0x02	; 2
    1266:	9f 93       	push	r25
    1268:	8f 93       	push	r24
    126a:	0e 94 33 06 	call	0xc66	; 0xc66 <UART_Printf>
    UART_Printf("\n\rMake connections and hit 'k' to test!");
    126e:	8f e0       	ldi	r24, 0x0F	; 15
    1270:	93 e0       	ldi	r25, 0x03	; 3
    1272:	9f 93       	push	r25
    1274:	8f 93       	push	r24
    1276:	0e 94 33 06 	call	0xc66	; 0xc66 <UART_Printf>
    while(UART_RxChar()!='k');
    127a:	0f 90       	pop	r0
    127c:	0f 90       	pop	r0
    127e:	0f 90       	pop	r0
    1280:	0f 90       	pop	r0
    1282:	0e 94 20 05 	call	0xa40	; 0xa40 <UART_RxChar>
    1286:	8b 36       	cpi	r24, 0x6B	; 107
    1288:	e1 f7       	brne	.-8      	; 0x1282 <keypad_test+0x20>
    KEYPAD_Init(PC_0,PC_1,PC_2,PC_3,PC_4,PC_5,PC_6,PC_7);
    128a:	87 e1       	ldi	r24, 0x17	; 23
    128c:	a8 2e       	mov	r10, r24
    128e:	96 e1       	ldi	r25, 0x16	; 22
    1290:	c9 2e       	mov	r12, r25
    1292:	25 e1       	ldi	r18, 0x15	; 21
    1294:	e2 2e       	mov	r14, r18
    1296:	04 e1       	ldi	r16, 0x14	; 20
    1298:	23 e1       	ldi	r18, 0x13	; 19
    129a:	42 e1       	ldi	r20, 0x12	; 18
    129c:	61 e1       	ldi	r22, 0x11	; 17
    129e:	80 e1       	ldi	r24, 0x10	; 16
    12a0:	0e 94 a8 01 	call	0x350	; 0x350 <KEYPAD_Init>
    while(1)
    {
        key = KEYPAD_GetKey();
        UART_Printf("\n\r Key:%c", key);
    12a4:	c7 e3       	ldi	r28, 0x37	; 55
    12a6:	d3 e0       	ldi	r29, 0x03	; 3
    UART_Printf("\n\rMake connections and hit 'k' to test!");
    while(UART_RxChar()!='k');
    KEYPAD_Init(PC_0,PC_1,PC_2,PC_3,PC_4,PC_5,PC_6,PC_7);
    while(1)
    {
        key = KEYPAD_GetKey();
    12a8:	0e 94 db 01 	call	0x3b6	; 0x3b6 <KEYPAD_GetKey>
        UART_Printf("\n\r Key:%c", key);
    12ac:	1f 92       	push	r1
    12ae:	8f 93       	push	r24
    12b0:	df 93       	push	r29
    12b2:	cf 93       	push	r28
    12b4:	0e 94 33 06 	call	0xc66	; 0xc66 <UART_Printf>
    }
    12b8:	0f 90       	pop	r0
    12ba:	0f 90       	pop	r0
    12bc:	0f 90       	pop	r0
    12be:	0f 90       	pop	r0
    12c0:	f3 cf       	rjmp	.-26     	; 0x12a8 <keypad_test+0x46>

000012c2 <main>:
char mm_option;

/* start the main program */
int main()
{
    UART_Init(9600);
    12c2:	60 e8       	ldi	r22, 0x80	; 128
    12c4:	75 e2       	ldi	r23, 0x25	; 37
    12c6:	80 e0       	ldi	r24, 0x00	; 0
    12c8:	90 e0       	ldi	r25, 0x00	; 0
    12ca:	0e 94 19 05 	call	0xa32	; 0xa32 <UART_Init>
    UART_TxString("\n\rTest menu Utra AVR v1.1\r\n 1:GPIO Blink\r\n 2:LCD 8-bit \n\r 3:LCD 4-bit\n\r 4:7-Segment\n\r 5:RTC\n\r 6:EEPROM\n\r 7:ADC\n\r 8:Keypad \n\r Enter option:");
    12ce:	81 e4       	ldi	r24, 0x41	; 65
    12d0:	93 e0       	ldi	r25, 0x03	; 3
    12d2:	0e 94 65 05 	call	0xaca	; 0xaca <UART_TxString>
    UART_TxString("\n\rReset the board after test is done");
    12d6:	8c ec       	ldi	r24, 0xCC	; 204
    12d8:	93 e0       	ldi	r25, 0x03	; 3
    12da:	0e 94 65 05 	call	0xaca	; 0xaca <UART_TxString>
    mm_option = UART_RxChar();
    12de:	0e 94 20 05 	call	0xa40	; 0xa40 <UART_RxChar>
    12e2:	80 93 0a 04 	sts	0x040A, r24
    while(1)
    {
        switch(mm_option)
    12e6:	90 e0       	ldi	r25, 0x00	; 0
    12e8:	fc 01       	movw	r30, r24
    12ea:	f1 97       	sbiw	r30, 0x31	; 49
    12ec:	e8 30       	cpi	r30, 0x08	; 8
    12ee:	f1 05       	cpc	r31, r1
    12f0:	e8 f7       	brcc	.-6      	; 0x12ec <main+0x2a>
    12f2:	e6 5d       	subi	r30, 0xD6	; 214
    12f4:	ff 4f       	sbci	r31, 0xFF	; 255
    12f6:	0c 94 46 0b 	jmp	0x168c	; 0x168c <__tablejump2__>
        {
        case '1': gpio_test(); break;
    12fa:	0e 94 84 07 	call	0xf08	; 0xf08 <gpio_test>
        case '2': LCD_8bit_test(); break;
    12fe:	0e 94 e5 07 	call	0xfca	; 0xfca <LCD_8bit_test>
        case '3': LCD_4bit_test(); break;
    1302:	0e 94 1b 08 	call	0x1036	; 0x1036 <LCD_4bit_test>
        case '4': seg_test(); break;
    1306:	0e 94 51 08 	call	0x10a2	; 0x10a2 <seg_test>
        case '5': rtc_test(); break;
    130a:	0e 94 89 08 	call	0x1112	; 0x1112 <rtc_test>
        case '6': eeprom_test(); break; //eeprom
    130e:	0e 94 db 08 	call	0x11b6	; 0x11b6 <eeprom_test>
        case '7': adc_test(); break;
    1312:	0e 94 0d 09 	call	0x121a	; 0x121a <adc_test>
        case '8': keypad_test();break;
    1316:	0e 94 31 09 	call	0x1262	; 0x1262 <keypad_test>

0000131a <__subsf3>:
    131a:	50 58       	subi	r21, 0x80	; 128

0000131c <__addsf3>:
    131c:	bb 27       	eor	r27, r27
    131e:	aa 27       	eor	r26, r26
    1320:	0e 94 a5 09 	call	0x134a	; 0x134a <__addsf3x>
    1324:	0c 94 7d 0a 	jmp	0x14fa	; 0x14fa <__fp_round>
    1328:	0e 94 6f 0a 	call	0x14de	; 0x14de <__fp_pscA>
    132c:	38 f0       	brcs	.+14     	; 0x133c <__addsf3+0x20>
    132e:	0e 94 76 0a 	call	0x14ec	; 0x14ec <__fp_pscB>
    1332:	20 f0       	brcs	.+8      	; 0x133c <__addsf3+0x20>
    1334:	39 f4       	brne	.+14     	; 0x1344 <__addsf3+0x28>
    1336:	9f 3f       	cpi	r25, 0xFF	; 255
    1338:	19 f4       	brne	.+6      	; 0x1340 <__addsf3+0x24>
    133a:	26 f4       	brtc	.+8      	; 0x1344 <__addsf3+0x28>
    133c:	0c 94 6c 0a 	jmp	0x14d8	; 0x14d8 <__fp_nan>
    1340:	0e f4       	brtc	.+2      	; 0x1344 <__addsf3+0x28>
    1342:	e0 95       	com	r30
    1344:	e7 fb       	bst	r30, 7
    1346:	0c 94 66 0a 	jmp	0x14cc	; 0x14cc <__fp_inf>

0000134a <__addsf3x>:
    134a:	e9 2f       	mov	r30, r25
    134c:	0e 94 8e 0a 	call	0x151c	; 0x151c <__fp_split3>
    1350:	58 f3       	brcs	.-42     	; 0x1328 <__addsf3+0xc>
    1352:	ba 17       	cp	r27, r26
    1354:	62 07       	cpc	r22, r18
    1356:	73 07       	cpc	r23, r19
    1358:	84 07       	cpc	r24, r20
    135a:	95 07       	cpc	r25, r21
    135c:	20 f0       	brcs	.+8      	; 0x1366 <__addsf3x+0x1c>
    135e:	79 f4       	brne	.+30     	; 0x137e <__addsf3x+0x34>
    1360:	a6 f5       	brtc	.+104    	; 0x13ca <__addsf3x+0x80>
    1362:	0c 94 b0 0a 	jmp	0x1560	; 0x1560 <__fp_zero>
    1366:	0e f4       	brtc	.+2      	; 0x136a <__addsf3x+0x20>
    1368:	e0 95       	com	r30
    136a:	0b 2e       	mov	r0, r27
    136c:	ba 2f       	mov	r27, r26
    136e:	a0 2d       	mov	r26, r0
    1370:	0b 01       	movw	r0, r22
    1372:	b9 01       	movw	r22, r18
    1374:	90 01       	movw	r18, r0
    1376:	0c 01       	movw	r0, r24
    1378:	ca 01       	movw	r24, r20
    137a:	a0 01       	movw	r20, r0
    137c:	11 24       	eor	r1, r1
    137e:	ff 27       	eor	r31, r31
    1380:	59 1b       	sub	r21, r25
    1382:	99 f0       	breq	.+38     	; 0x13aa <__addsf3x+0x60>
    1384:	59 3f       	cpi	r21, 0xF9	; 249
    1386:	50 f4       	brcc	.+20     	; 0x139c <__addsf3x+0x52>
    1388:	50 3e       	cpi	r21, 0xE0	; 224
    138a:	68 f1       	brcs	.+90     	; 0x13e6 <__addsf3x+0x9c>
    138c:	1a 16       	cp	r1, r26
    138e:	f0 40       	sbci	r31, 0x00	; 0
    1390:	a2 2f       	mov	r26, r18
    1392:	23 2f       	mov	r18, r19
    1394:	34 2f       	mov	r19, r20
    1396:	44 27       	eor	r20, r20
    1398:	58 5f       	subi	r21, 0xF8	; 248
    139a:	f3 cf       	rjmp	.-26     	; 0x1382 <__addsf3x+0x38>
    139c:	46 95       	lsr	r20
    139e:	37 95       	ror	r19
    13a0:	27 95       	ror	r18
    13a2:	a7 95       	ror	r26
    13a4:	f0 40       	sbci	r31, 0x00	; 0
    13a6:	53 95       	inc	r21
    13a8:	c9 f7       	brne	.-14     	; 0x139c <__addsf3x+0x52>
    13aa:	7e f4       	brtc	.+30     	; 0x13ca <__addsf3x+0x80>
    13ac:	1f 16       	cp	r1, r31
    13ae:	ba 0b       	sbc	r27, r26
    13b0:	62 0b       	sbc	r22, r18
    13b2:	73 0b       	sbc	r23, r19
    13b4:	84 0b       	sbc	r24, r20
    13b6:	ba f0       	brmi	.+46     	; 0x13e6 <__addsf3x+0x9c>
    13b8:	91 50       	subi	r25, 0x01	; 1
    13ba:	a1 f0       	breq	.+40     	; 0x13e4 <__addsf3x+0x9a>
    13bc:	ff 0f       	add	r31, r31
    13be:	bb 1f       	adc	r27, r27
    13c0:	66 1f       	adc	r22, r22
    13c2:	77 1f       	adc	r23, r23
    13c4:	88 1f       	adc	r24, r24
    13c6:	c2 f7       	brpl	.-16     	; 0x13b8 <__addsf3x+0x6e>
    13c8:	0e c0       	rjmp	.+28     	; 0x13e6 <__addsf3x+0x9c>
    13ca:	ba 0f       	add	r27, r26
    13cc:	62 1f       	adc	r22, r18
    13ce:	73 1f       	adc	r23, r19
    13d0:	84 1f       	adc	r24, r20
    13d2:	48 f4       	brcc	.+18     	; 0x13e6 <__addsf3x+0x9c>
    13d4:	87 95       	ror	r24
    13d6:	77 95       	ror	r23
    13d8:	67 95       	ror	r22
    13da:	b7 95       	ror	r27
    13dc:	f7 95       	ror	r31
    13de:	9e 3f       	cpi	r25, 0xFE	; 254
    13e0:	08 f0       	brcs	.+2      	; 0x13e4 <__addsf3x+0x9a>
    13e2:	b0 cf       	rjmp	.-160    	; 0x1344 <__addsf3+0x28>
    13e4:	93 95       	inc	r25
    13e6:	88 0f       	add	r24, r24
    13e8:	08 f0       	brcs	.+2      	; 0x13ec <__addsf3x+0xa2>
    13ea:	99 27       	eor	r25, r25
    13ec:	ee 0f       	add	r30, r30
    13ee:	97 95       	ror	r25
    13f0:	87 95       	ror	r24
    13f2:	08 95       	ret

000013f4 <__fixunssfsi>:
    13f4:	0e 94 96 0a 	call	0x152c	; 0x152c <__fp_splitA>
    13f8:	88 f0       	brcs	.+34     	; 0x141c <__fixunssfsi+0x28>
    13fa:	9f 57       	subi	r25, 0x7F	; 127
    13fc:	98 f0       	brcs	.+38     	; 0x1424 <__fixunssfsi+0x30>
    13fe:	b9 2f       	mov	r27, r25
    1400:	99 27       	eor	r25, r25
    1402:	b7 51       	subi	r27, 0x17	; 23
    1404:	b0 f0       	brcs	.+44     	; 0x1432 <__fixunssfsi+0x3e>
    1406:	e1 f0       	breq	.+56     	; 0x1440 <__fixunssfsi+0x4c>
    1408:	66 0f       	add	r22, r22
    140a:	77 1f       	adc	r23, r23
    140c:	88 1f       	adc	r24, r24
    140e:	99 1f       	adc	r25, r25
    1410:	1a f0       	brmi	.+6      	; 0x1418 <__fixunssfsi+0x24>
    1412:	ba 95       	dec	r27
    1414:	c9 f7       	brne	.-14     	; 0x1408 <__fixunssfsi+0x14>
    1416:	14 c0       	rjmp	.+40     	; 0x1440 <__fixunssfsi+0x4c>
    1418:	b1 30       	cpi	r27, 0x01	; 1
    141a:	91 f0       	breq	.+36     	; 0x1440 <__fixunssfsi+0x4c>
    141c:	0e 94 b0 0a 	call	0x1560	; 0x1560 <__fp_zero>
    1420:	b1 e0       	ldi	r27, 0x01	; 1
    1422:	08 95       	ret
    1424:	0c 94 b0 0a 	jmp	0x1560	; 0x1560 <__fp_zero>
    1428:	67 2f       	mov	r22, r23
    142a:	78 2f       	mov	r23, r24
    142c:	88 27       	eor	r24, r24
    142e:	b8 5f       	subi	r27, 0xF8	; 248
    1430:	39 f0       	breq	.+14     	; 0x1440 <__fixunssfsi+0x4c>
    1432:	b9 3f       	cpi	r27, 0xF9	; 249
    1434:	cc f3       	brlt	.-14     	; 0x1428 <__fixunssfsi+0x34>
    1436:	86 95       	lsr	r24
    1438:	77 95       	ror	r23
    143a:	67 95       	ror	r22
    143c:	b3 95       	inc	r27
    143e:	d9 f7       	brne	.-10     	; 0x1436 <__fixunssfsi+0x42>
    1440:	3e f4       	brtc	.+14     	; 0x1450 <__fixunssfsi+0x5c>
    1442:	90 95       	com	r25
    1444:	80 95       	com	r24
    1446:	70 95       	com	r23
    1448:	61 95       	neg	r22
    144a:	7f 4f       	sbci	r23, 0xFF	; 255
    144c:	8f 4f       	sbci	r24, 0xFF	; 255
    144e:	9f 4f       	sbci	r25, 0xFF	; 255
    1450:	08 95       	ret

00001452 <__floatunsisf>:
    1452:	e8 94       	clt
    1454:	09 c0       	rjmp	.+18     	; 0x1468 <__floatsisf+0x12>

00001456 <__floatsisf>:
    1456:	97 fb       	bst	r25, 7
    1458:	3e f4       	brtc	.+14     	; 0x1468 <__floatsisf+0x12>
    145a:	90 95       	com	r25
    145c:	80 95       	com	r24
    145e:	70 95       	com	r23
    1460:	61 95       	neg	r22
    1462:	7f 4f       	sbci	r23, 0xFF	; 255
    1464:	8f 4f       	sbci	r24, 0xFF	; 255
    1466:	9f 4f       	sbci	r25, 0xFF	; 255
    1468:	99 23       	and	r25, r25
    146a:	a9 f0       	breq	.+42     	; 0x1496 <__floatsisf+0x40>
    146c:	f9 2f       	mov	r31, r25
    146e:	96 e9       	ldi	r25, 0x96	; 150
    1470:	bb 27       	eor	r27, r27
    1472:	93 95       	inc	r25
    1474:	f6 95       	lsr	r31
    1476:	87 95       	ror	r24
    1478:	77 95       	ror	r23
    147a:	67 95       	ror	r22
    147c:	b7 95       	ror	r27
    147e:	f1 11       	cpse	r31, r1
    1480:	f8 cf       	rjmp	.-16     	; 0x1472 <__floatsisf+0x1c>
    1482:	fa f4       	brpl	.+62     	; 0x14c2 <__floatsisf+0x6c>
    1484:	bb 0f       	add	r27, r27
    1486:	11 f4       	brne	.+4      	; 0x148c <__floatsisf+0x36>
    1488:	60 ff       	sbrs	r22, 0
    148a:	1b c0       	rjmp	.+54     	; 0x14c2 <__floatsisf+0x6c>
    148c:	6f 5f       	subi	r22, 0xFF	; 255
    148e:	7f 4f       	sbci	r23, 0xFF	; 255
    1490:	8f 4f       	sbci	r24, 0xFF	; 255
    1492:	9f 4f       	sbci	r25, 0xFF	; 255
    1494:	16 c0       	rjmp	.+44     	; 0x14c2 <__floatsisf+0x6c>
    1496:	88 23       	and	r24, r24
    1498:	11 f0       	breq	.+4      	; 0x149e <__floatsisf+0x48>
    149a:	96 e9       	ldi	r25, 0x96	; 150
    149c:	11 c0       	rjmp	.+34     	; 0x14c0 <__floatsisf+0x6a>
    149e:	77 23       	and	r23, r23
    14a0:	21 f0       	breq	.+8      	; 0x14aa <__floatsisf+0x54>
    14a2:	9e e8       	ldi	r25, 0x8E	; 142
    14a4:	87 2f       	mov	r24, r23
    14a6:	76 2f       	mov	r23, r22
    14a8:	05 c0       	rjmp	.+10     	; 0x14b4 <__floatsisf+0x5e>
    14aa:	66 23       	and	r22, r22
    14ac:	71 f0       	breq	.+28     	; 0x14ca <__floatsisf+0x74>
    14ae:	96 e8       	ldi	r25, 0x86	; 134
    14b0:	86 2f       	mov	r24, r22
    14b2:	70 e0       	ldi	r23, 0x00	; 0
    14b4:	60 e0       	ldi	r22, 0x00	; 0
    14b6:	2a f0       	brmi	.+10     	; 0x14c2 <__floatsisf+0x6c>
    14b8:	9a 95       	dec	r25
    14ba:	66 0f       	add	r22, r22
    14bc:	77 1f       	adc	r23, r23
    14be:	88 1f       	adc	r24, r24
    14c0:	da f7       	brpl	.-10     	; 0x14b8 <__floatsisf+0x62>
    14c2:	88 0f       	add	r24, r24
    14c4:	96 95       	lsr	r25
    14c6:	87 95       	ror	r24
    14c8:	97 f9       	bld	r25, 7
    14ca:	08 95       	ret

000014cc <__fp_inf>:
    14cc:	97 f9       	bld	r25, 7
    14ce:	9f 67       	ori	r25, 0x7F	; 127
    14d0:	80 e8       	ldi	r24, 0x80	; 128
    14d2:	70 e0       	ldi	r23, 0x00	; 0
    14d4:	60 e0       	ldi	r22, 0x00	; 0
    14d6:	08 95       	ret

000014d8 <__fp_nan>:
    14d8:	9f ef       	ldi	r25, 0xFF	; 255
    14da:	80 ec       	ldi	r24, 0xC0	; 192
    14dc:	08 95       	ret

000014de <__fp_pscA>:
    14de:	00 24       	eor	r0, r0
    14e0:	0a 94       	dec	r0
    14e2:	16 16       	cp	r1, r22
    14e4:	17 06       	cpc	r1, r23
    14e6:	18 06       	cpc	r1, r24
    14e8:	09 06       	cpc	r0, r25
    14ea:	08 95       	ret

000014ec <__fp_pscB>:
    14ec:	00 24       	eor	r0, r0
    14ee:	0a 94       	dec	r0
    14f0:	12 16       	cp	r1, r18
    14f2:	13 06       	cpc	r1, r19
    14f4:	14 06       	cpc	r1, r20
    14f6:	05 06       	cpc	r0, r21
    14f8:	08 95       	ret

000014fa <__fp_round>:
    14fa:	09 2e       	mov	r0, r25
    14fc:	03 94       	inc	r0
    14fe:	00 0c       	add	r0, r0
    1500:	11 f4       	brne	.+4      	; 0x1506 <__fp_round+0xc>
    1502:	88 23       	and	r24, r24
    1504:	52 f0       	brmi	.+20     	; 0x151a <__fp_round+0x20>
    1506:	bb 0f       	add	r27, r27
    1508:	40 f4       	brcc	.+16     	; 0x151a <__fp_round+0x20>
    150a:	bf 2b       	or	r27, r31
    150c:	11 f4       	brne	.+4      	; 0x1512 <__fp_round+0x18>
    150e:	60 ff       	sbrs	r22, 0
    1510:	04 c0       	rjmp	.+8      	; 0x151a <__fp_round+0x20>
    1512:	6f 5f       	subi	r22, 0xFF	; 255
    1514:	7f 4f       	sbci	r23, 0xFF	; 255
    1516:	8f 4f       	sbci	r24, 0xFF	; 255
    1518:	9f 4f       	sbci	r25, 0xFF	; 255
    151a:	08 95       	ret

0000151c <__fp_split3>:
    151c:	57 fd       	sbrc	r21, 7
    151e:	90 58       	subi	r25, 0x80	; 128
    1520:	44 0f       	add	r20, r20
    1522:	55 1f       	adc	r21, r21
    1524:	59 f0       	breq	.+22     	; 0x153c <__fp_splitA+0x10>
    1526:	5f 3f       	cpi	r21, 0xFF	; 255
    1528:	71 f0       	breq	.+28     	; 0x1546 <__fp_splitA+0x1a>
    152a:	47 95       	ror	r20

0000152c <__fp_splitA>:
    152c:	88 0f       	add	r24, r24
    152e:	97 fb       	bst	r25, 7
    1530:	99 1f       	adc	r25, r25
    1532:	61 f0       	breq	.+24     	; 0x154c <__fp_splitA+0x20>
    1534:	9f 3f       	cpi	r25, 0xFF	; 255
    1536:	79 f0       	breq	.+30     	; 0x1556 <__fp_splitA+0x2a>
    1538:	87 95       	ror	r24
    153a:	08 95       	ret
    153c:	12 16       	cp	r1, r18
    153e:	13 06       	cpc	r1, r19
    1540:	14 06       	cpc	r1, r20
    1542:	55 1f       	adc	r21, r21
    1544:	f2 cf       	rjmp	.-28     	; 0x152a <__fp_split3+0xe>
    1546:	46 95       	lsr	r20
    1548:	f1 df       	rcall	.-30     	; 0x152c <__fp_splitA>
    154a:	08 c0       	rjmp	.+16     	; 0x155c <__fp_splitA+0x30>
    154c:	16 16       	cp	r1, r22
    154e:	17 06       	cpc	r1, r23
    1550:	18 06       	cpc	r1, r24
    1552:	99 1f       	adc	r25, r25
    1554:	f1 cf       	rjmp	.-30     	; 0x1538 <__fp_splitA+0xc>
    1556:	86 95       	lsr	r24
    1558:	71 05       	cpc	r23, r1
    155a:	61 05       	cpc	r22, r1
    155c:	08 94       	sec
    155e:	08 95       	ret

00001560 <__fp_zero>:
    1560:	e8 94       	clt

00001562 <__fp_szero>:
    1562:	bb 27       	eor	r27, r27
    1564:	66 27       	eor	r22, r22
    1566:	77 27       	eor	r23, r23
    1568:	cb 01       	movw	r24, r22
    156a:	97 f9       	bld	r25, 7
    156c:	08 95       	ret

0000156e <__mulsf3>:
    156e:	0e 94 ca 0a 	call	0x1594	; 0x1594 <__mulsf3x>
    1572:	0c 94 7d 0a 	jmp	0x14fa	; 0x14fa <__fp_round>
    1576:	0e 94 6f 0a 	call	0x14de	; 0x14de <__fp_pscA>
    157a:	38 f0       	brcs	.+14     	; 0x158a <__mulsf3+0x1c>
    157c:	0e 94 76 0a 	call	0x14ec	; 0x14ec <__fp_pscB>
    1580:	20 f0       	brcs	.+8      	; 0x158a <__mulsf3+0x1c>
    1582:	95 23       	and	r25, r21
    1584:	11 f0       	breq	.+4      	; 0x158a <__mulsf3+0x1c>
    1586:	0c 94 66 0a 	jmp	0x14cc	; 0x14cc <__fp_inf>
    158a:	0c 94 6c 0a 	jmp	0x14d8	; 0x14d8 <__fp_nan>
    158e:	11 24       	eor	r1, r1
    1590:	0c 94 b1 0a 	jmp	0x1562	; 0x1562 <__fp_szero>

00001594 <__mulsf3x>:
    1594:	0e 94 8e 0a 	call	0x151c	; 0x151c <__fp_split3>
    1598:	70 f3       	brcs	.-36     	; 0x1576 <__mulsf3+0x8>

0000159a <__mulsf3_pse>:
    159a:	95 9f       	mul	r25, r21
    159c:	c1 f3       	breq	.-16     	; 0x158e <__mulsf3+0x20>
    159e:	95 0f       	add	r25, r21
    15a0:	50 e0       	ldi	r21, 0x00	; 0
    15a2:	55 1f       	adc	r21, r21
    15a4:	62 9f       	mul	r22, r18
    15a6:	f0 01       	movw	r30, r0
    15a8:	72 9f       	mul	r23, r18
    15aa:	bb 27       	eor	r27, r27
    15ac:	f0 0d       	add	r31, r0
    15ae:	b1 1d       	adc	r27, r1
    15b0:	63 9f       	mul	r22, r19
    15b2:	aa 27       	eor	r26, r26
    15b4:	f0 0d       	add	r31, r0
    15b6:	b1 1d       	adc	r27, r1
    15b8:	aa 1f       	adc	r26, r26
    15ba:	64 9f       	mul	r22, r20
    15bc:	66 27       	eor	r22, r22
    15be:	b0 0d       	add	r27, r0
    15c0:	a1 1d       	adc	r26, r1
    15c2:	66 1f       	adc	r22, r22
    15c4:	82 9f       	mul	r24, r18
    15c6:	22 27       	eor	r18, r18
    15c8:	b0 0d       	add	r27, r0
    15ca:	a1 1d       	adc	r26, r1
    15cc:	62 1f       	adc	r22, r18
    15ce:	73 9f       	mul	r23, r19
    15d0:	b0 0d       	add	r27, r0
    15d2:	a1 1d       	adc	r26, r1
    15d4:	62 1f       	adc	r22, r18
    15d6:	83 9f       	mul	r24, r19
    15d8:	a0 0d       	add	r26, r0
    15da:	61 1d       	adc	r22, r1
    15dc:	22 1f       	adc	r18, r18
    15de:	74 9f       	mul	r23, r20
    15e0:	33 27       	eor	r19, r19
    15e2:	a0 0d       	add	r26, r0
    15e4:	61 1d       	adc	r22, r1
    15e6:	23 1f       	adc	r18, r19
    15e8:	84 9f       	mul	r24, r20
    15ea:	60 0d       	add	r22, r0
    15ec:	21 1d       	adc	r18, r1
    15ee:	82 2f       	mov	r24, r18
    15f0:	76 2f       	mov	r23, r22
    15f2:	6a 2f       	mov	r22, r26
    15f4:	11 24       	eor	r1, r1
    15f6:	9f 57       	subi	r25, 0x7F	; 127
    15f8:	50 40       	sbci	r21, 0x00	; 0
    15fa:	9a f0       	brmi	.+38     	; 0x1622 <__mulsf3_pse+0x88>
    15fc:	f1 f0       	breq	.+60     	; 0x163a <__mulsf3_pse+0xa0>
    15fe:	88 23       	and	r24, r24
    1600:	4a f0       	brmi	.+18     	; 0x1614 <__mulsf3_pse+0x7a>
    1602:	ee 0f       	add	r30, r30
    1604:	ff 1f       	adc	r31, r31
    1606:	bb 1f       	adc	r27, r27
    1608:	66 1f       	adc	r22, r22
    160a:	77 1f       	adc	r23, r23
    160c:	88 1f       	adc	r24, r24
    160e:	91 50       	subi	r25, 0x01	; 1
    1610:	50 40       	sbci	r21, 0x00	; 0
    1612:	a9 f7       	brne	.-22     	; 0x15fe <__mulsf3_pse+0x64>
    1614:	9e 3f       	cpi	r25, 0xFE	; 254
    1616:	51 05       	cpc	r21, r1
    1618:	80 f0       	brcs	.+32     	; 0x163a <__mulsf3_pse+0xa0>
    161a:	0c 94 66 0a 	jmp	0x14cc	; 0x14cc <__fp_inf>
    161e:	0c 94 b1 0a 	jmp	0x1562	; 0x1562 <__fp_szero>
    1622:	5f 3f       	cpi	r21, 0xFF	; 255
    1624:	e4 f3       	brlt	.-8      	; 0x161e <__mulsf3_pse+0x84>
    1626:	98 3e       	cpi	r25, 0xE8	; 232
    1628:	d4 f3       	brlt	.-12     	; 0x161e <__mulsf3_pse+0x84>
    162a:	86 95       	lsr	r24
    162c:	77 95       	ror	r23
    162e:	67 95       	ror	r22
    1630:	b7 95       	ror	r27
    1632:	f7 95       	ror	r31
    1634:	e7 95       	ror	r30
    1636:	9f 5f       	subi	r25, 0xFF	; 255
    1638:	c1 f7       	brne	.-16     	; 0x162a <__mulsf3_pse+0x90>
    163a:	fe 2b       	or	r31, r30
    163c:	88 0f       	add	r24, r24
    163e:	91 1d       	adc	r25, r1
    1640:	96 95       	lsr	r25
    1642:	87 95       	ror	r24
    1644:	97 f9       	bld	r25, 7
    1646:	08 95       	ret

00001648 <__udivmodsi4>:
    1648:	a1 e2       	ldi	r26, 0x21	; 33
    164a:	1a 2e       	mov	r1, r26
    164c:	aa 1b       	sub	r26, r26
    164e:	bb 1b       	sub	r27, r27
    1650:	fd 01       	movw	r30, r26
    1652:	0d c0       	rjmp	.+26     	; 0x166e <__udivmodsi4_ep>

00001654 <__udivmodsi4_loop>:
    1654:	aa 1f       	adc	r26, r26
    1656:	bb 1f       	adc	r27, r27
    1658:	ee 1f       	adc	r30, r30
    165a:	ff 1f       	adc	r31, r31
    165c:	a2 17       	cp	r26, r18
    165e:	b3 07       	cpc	r27, r19
    1660:	e4 07       	cpc	r30, r20
    1662:	f5 07       	cpc	r31, r21
    1664:	20 f0       	brcs	.+8      	; 0x166e <__udivmodsi4_ep>
    1666:	a2 1b       	sub	r26, r18
    1668:	b3 0b       	sbc	r27, r19
    166a:	e4 0b       	sbc	r30, r20
    166c:	f5 0b       	sbc	r31, r21

0000166e <__udivmodsi4_ep>:
    166e:	66 1f       	adc	r22, r22
    1670:	77 1f       	adc	r23, r23
    1672:	88 1f       	adc	r24, r24
    1674:	99 1f       	adc	r25, r25
    1676:	1a 94       	dec	r1
    1678:	69 f7       	brne	.-38     	; 0x1654 <__udivmodsi4_loop>
    167a:	60 95       	com	r22
    167c:	70 95       	com	r23
    167e:	80 95       	com	r24
    1680:	90 95       	com	r25
    1682:	9b 01       	movw	r18, r22
    1684:	ac 01       	movw	r20, r24
    1686:	bd 01       	movw	r22, r26
    1688:	cf 01       	movw	r24, r30
    168a:	08 95       	ret

0000168c <__tablejump2__>:
    168c:	ee 0f       	add	r30, r30
    168e:	ff 1f       	adc	r31, r31
    1690:	05 90       	lpm	r0, Z+
    1692:	f4 91       	lpm	r31, Z
    1694:	e0 2d       	mov	r30, r0
    1696:	09 94       	ijmp

00001698 <__mulshisi3>:
    1698:	b7 ff       	sbrs	r27, 7
    169a:	0c 94 54 0b 	jmp	0x16a8	; 0x16a8 <__muluhisi3>

0000169e <__mulohisi3>:
    169e:	0e 94 54 0b 	call	0x16a8	; 0x16a8 <__muluhisi3>
    16a2:	82 1b       	sub	r24, r18
    16a4:	93 0b       	sbc	r25, r19
    16a6:	08 95       	ret

000016a8 <__muluhisi3>:
    16a8:	0e 94 5f 0b 	call	0x16be	; 0x16be <__umulhisi3>
    16ac:	a5 9f       	mul	r26, r21
    16ae:	90 0d       	add	r25, r0
    16b0:	b4 9f       	mul	r27, r20
    16b2:	90 0d       	add	r25, r0
    16b4:	a4 9f       	mul	r26, r20
    16b6:	80 0d       	add	r24, r0
    16b8:	91 1d       	adc	r25, r1
    16ba:	11 24       	eor	r1, r1
    16bc:	08 95       	ret

000016be <__umulhisi3>:
    16be:	a2 9f       	mul	r26, r18
    16c0:	b0 01       	movw	r22, r0
    16c2:	b3 9f       	mul	r27, r19
    16c4:	c0 01       	movw	r24, r0
    16c6:	a3 9f       	mul	r26, r19
    16c8:	70 0d       	add	r23, r0
    16ca:	81 1d       	adc	r24, r1
    16cc:	11 24       	eor	r1, r1
    16ce:	91 1d       	adc	r25, r1
    16d0:	b2 9f       	mul	r27, r18
    16d2:	70 0d       	add	r23, r0
    16d4:	81 1d       	adc	r24, r1
    16d6:	11 24       	eor	r1, r1
    16d8:	91 1d       	adc	r25, r1
    16da:	08 95       	ret

000016dc <_exit>:
    16dc:	f8 94       	cli

000016de <__stop_program>:
    16de:	ff cf       	rjmp	.-2      	; 0x16de <__stop_program>
