
09b-RTC_DS1307_LCD.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000010b0  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000028  00800060  000010b0  00001144  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000010  00800088  00800088  0000116c  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  0000116c  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  0000119c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000190  00000000  00000000  000011d8  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00001d59  00000000  00000000  00001368  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000007e0  00000000  00000000  000030c1  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000007c0  00000000  00000000  000038a1  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000438  00000000  00000000  00004064  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000784  00000000  00000000  0000449c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00001790  00000000  00000000  00004c20  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000178  00000000  00000000  000063b0  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e0 eb       	ldi	r30, 0xB0	; 176
      68:	f0 e1       	ldi	r31, 0x10	; 16
      6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0
      70:	a8 38       	cpi	r26, 0x88	; 136
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
      76:	20 e0       	ldi	r18, 0x00	; 0
      78:	a8 e8       	ldi	r26, 0x88	; 136
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a8 39       	cpi	r26, 0x98	; 152
      82:	b2 07       	cpc	r27, r18
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 43 06 	call	0xc86	; 0xc86 <main>
      8a:	0c 94 56 08 	jmp	0x10ac	; 0x10ac <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <DELAY_us>:
         if 5000 is passed as the argument then it generates a delay of 5ms.		  

 ***************************************************************************************************/
void DELAY_us(uint16_t us_count) 
{
    while (us_count != 0) 
      92:	00 97       	sbiw	r24, 0x00	; 0
      94:	31 f0       	breq	.+12     	; 0xa2 <DELAY_us+0x10>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
      96:	25 e0       	ldi	r18, 0x05	; 5
      98:	2a 95       	dec	r18
      9a:	f1 f7       	brne	.-4      	; 0x98 <DELAY_us+0x6>
      9c:	00 00       	nop
    {
        _delay_us(1);
		us_count--;
      9e:	01 97       	sbiw	r24, 0x01	; 1
      a0:	f8 cf       	rjmp	.-16     	; 0x92 <DELAY_us>
    }
}
      a2:	08 95       	ret

000000a4 <DELAY_ms>:
     It generates a delay of 1ms for each count,
     if 1000 is passed as the argument then it generates delay of 1000ms(1sec)
 ***************************************************************************************************/
void DELAY_ms(uint16_t ms_count) 
{
    while (ms_count != 0) 
      a4:	00 97       	sbiw	r24, 0x00	; 0
      a6:	41 f0       	breq	.+16     	; 0xb8 <DELAY_ms+0x14>
      a8:	ef e9       	ldi	r30, 0x9F	; 159
      aa:	ff e0       	ldi	r31, 0x0F	; 15
      ac:	31 97       	sbiw	r30, 0x01	; 1
      ae:	f1 f7       	brne	.-4      	; 0xac <DELAY_ms+0x8>
      b0:	00 c0       	rjmp	.+0      	; 0xb2 <DELAY_ms+0xe>
      b2:	00 00       	nop
    {
        _delay_us(1000); //DELAY_us is called to generate 1ms delay
        ms_count--;
      b4:	01 97       	sbiw	r24, 0x01	; 1
      b6:	f6 cf       	rjmp	.-20     	; 0xa4 <DELAY_ms>
    }
}
      b8:	08 95       	ret

000000ba <GPIO_PinDirection>:

    uint8_t v_portNumber_u8;


    v_portNumber_u8 =  (enm_pinNumber>>3);  // Divide the pin number by 8 go get the PORT number
    enm_pinNumber  =   enm_pinNumber & 0x07;  // lower 3-bits contains the bit number of a byte 
      ba:	98 2f       	mov	r25, r24
      bc:	97 70       	andi	r25, 0x07	; 7
{

    uint8_t v_portNumber_u8;


    v_portNumber_u8 =  (enm_pinNumber>>3);  // Divide the pin number by 8 go get the PORT number
      be:	86 95       	lsr	r24
      c0:	86 95       	lsr	r24
      c2:	86 95       	lsr	r24
    enm_pinNumber  =   enm_pinNumber & 0x07;  // lower 3-bits contains the bit number of a byte 

    /* Go to particular port after decoding from the pin number and 
        set the direction as specified*/
    switch(v_portNumber_u8)
      c4:	81 30       	cpi	r24, 0x01	; 1
      c6:	01 f1       	breq	.+64     	; 0x108 <GPIO_PinDirection+0x4e>
      c8:	30 f0       	brcs	.+12     	; 0xd6 <GPIO_PinDirection+0x1c>
      ca:	82 30       	cpi	r24, 0x02	; 2
      cc:	b1 f1       	breq	.+108    	; 0x13a <GPIO_PinDirection+0x80>
      ce:	83 30       	cpi	r24, 0x03	; 3
      d0:	09 f4       	brne	.+2      	; 0xd4 <GPIO_PinDirection+0x1a>
      d2:	4c c0       	rjmp	.+152    	; 0x16c <GPIO_PinDirection+0xb2>
      d4:	08 95       	ret
    {
#ifdef DDRA        
    case 0:
        util_UpdateBit(DDRA,enm_pinNumber,v_pinDirn_u8);
      d6:	4a b3       	in	r20, 0x1a	; 26
      d8:	21 e0       	ldi	r18, 0x01	; 1
      da:	30 e0       	ldi	r19, 0x00	; 0
      dc:	66 23       	and	r22, r22
      de:	49 f0       	breq	.+18     	; 0xf2 <GPIO_PinDirection+0x38>
      e0:	b9 01       	movw	r22, r18
      e2:	02 c0       	rjmp	.+4      	; 0xe8 <GPIO_PinDirection+0x2e>
      e4:	66 0f       	add	r22, r22
      e6:	77 1f       	adc	r23, r23
      e8:	9a 95       	dec	r25
      ea:	e2 f7       	brpl	.-8      	; 0xe4 <GPIO_PinDirection+0x2a>
      ec:	cb 01       	movw	r24, r22
      ee:	84 2b       	or	r24, r20
      f0:	09 c0       	rjmp	.+18     	; 0x104 <GPIO_PinDirection+0x4a>
      f2:	b9 01       	movw	r22, r18
      f4:	02 c0       	rjmp	.+4      	; 0xfa <GPIO_PinDirection+0x40>
      f6:	66 0f       	add	r22, r22
      f8:	77 1f       	adc	r23, r23
      fa:	9a 95       	dec	r25
      fc:	e2 f7       	brpl	.-8      	; 0xf6 <GPIO_PinDirection+0x3c>
      fe:	cb 01       	movw	r24, r22
     100:	80 95       	com	r24
     102:	84 23       	and	r24, r20
     104:	8a bb       	out	0x1a, r24	; 26
     106:	08 95       	ret
#endif        


#ifdef DDRB
    case 1:
        util_UpdateBit(DDRB,enm_pinNumber,v_pinDirn_u8);
     108:	47 b3       	in	r20, 0x17	; 23
     10a:	21 e0       	ldi	r18, 0x01	; 1
     10c:	30 e0       	ldi	r19, 0x00	; 0
     10e:	66 23       	and	r22, r22
     110:	49 f0       	breq	.+18     	; 0x124 <GPIO_PinDirection+0x6a>
     112:	b9 01       	movw	r22, r18
     114:	02 c0       	rjmp	.+4      	; 0x11a <GPIO_PinDirection+0x60>
     116:	66 0f       	add	r22, r22
     118:	77 1f       	adc	r23, r23
     11a:	9a 95       	dec	r25
     11c:	e2 f7       	brpl	.-8      	; 0x116 <GPIO_PinDirection+0x5c>
     11e:	cb 01       	movw	r24, r22
     120:	84 2b       	or	r24, r20
     122:	09 c0       	rjmp	.+18     	; 0x136 <GPIO_PinDirection+0x7c>
     124:	b9 01       	movw	r22, r18
     126:	02 c0       	rjmp	.+4      	; 0x12c <GPIO_PinDirection+0x72>
     128:	66 0f       	add	r22, r22
     12a:	77 1f       	adc	r23, r23
     12c:	9a 95       	dec	r25
     12e:	e2 f7       	brpl	.-8      	; 0x128 <GPIO_PinDirection+0x6e>
     130:	cb 01       	movw	r24, r22
     132:	80 95       	com	r24
     134:	84 23       	and	r24, r20
     136:	87 bb       	out	0x17, r24	; 23
     138:	08 95       	ret
#endif 

        
#ifdef DDRC
    case 2:
        util_UpdateBit(DDRC,enm_pinNumber,v_pinDirn_u8);
     13a:	44 b3       	in	r20, 0x14	; 20
     13c:	21 e0       	ldi	r18, 0x01	; 1
     13e:	30 e0       	ldi	r19, 0x00	; 0
     140:	66 23       	and	r22, r22
     142:	49 f0       	breq	.+18     	; 0x156 <GPIO_PinDirection+0x9c>
     144:	b9 01       	movw	r22, r18
     146:	02 c0       	rjmp	.+4      	; 0x14c <GPIO_PinDirection+0x92>
     148:	66 0f       	add	r22, r22
     14a:	77 1f       	adc	r23, r23
     14c:	9a 95       	dec	r25
     14e:	e2 f7       	brpl	.-8      	; 0x148 <GPIO_PinDirection+0x8e>
     150:	cb 01       	movw	r24, r22
     152:	84 2b       	or	r24, r20
     154:	09 c0       	rjmp	.+18     	; 0x168 <GPIO_PinDirection+0xae>
     156:	b9 01       	movw	r22, r18
     158:	02 c0       	rjmp	.+4      	; 0x15e <GPIO_PinDirection+0xa4>
     15a:	66 0f       	add	r22, r22
     15c:	77 1f       	adc	r23, r23
     15e:	9a 95       	dec	r25
     160:	e2 f7       	brpl	.-8      	; 0x15a <GPIO_PinDirection+0xa0>
     162:	cb 01       	movw	r24, r22
     164:	80 95       	com	r24
     166:	84 23       	and	r24, r20
     168:	84 bb       	out	0x14, r24	; 20
     16a:	08 95       	ret
#endif 

        
#ifdef DDRD        
    case 3:
        util_UpdateBit(DDRD,enm_pinNumber,v_pinDirn_u8);
     16c:	41 b3       	in	r20, 0x11	; 17
     16e:	21 e0       	ldi	r18, 0x01	; 1
     170:	30 e0       	ldi	r19, 0x00	; 0
     172:	66 23       	and	r22, r22
     174:	49 f0       	breq	.+18     	; 0x188 <GPIO_PinDirection+0xce>
     176:	b9 01       	movw	r22, r18
     178:	02 c0       	rjmp	.+4      	; 0x17e <GPIO_PinDirection+0xc4>
     17a:	66 0f       	add	r22, r22
     17c:	77 1f       	adc	r23, r23
     17e:	9a 95       	dec	r25
     180:	e2 f7       	brpl	.-8      	; 0x17a <GPIO_PinDirection+0xc0>
     182:	cb 01       	movw	r24, r22
     184:	84 2b       	or	r24, r20
     186:	09 c0       	rjmp	.+18     	; 0x19a <GPIO_PinDirection+0xe0>
     188:	b9 01       	movw	r22, r18
     18a:	02 c0       	rjmp	.+4      	; 0x190 <GPIO_PinDirection+0xd6>
     18c:	66 0f       	add	r22, r22
     18e:	77 1f       	adc	r23, r23
     190:	9a 95       	dec	r25
     192:	e2 f7       	brpl	.-8      	; 0x18c <GPIO_PinDirection+0xd2>
     194:	cb 01       	movw	r24, r22
     196:	80 95       	com	r24
     198:	84 23       	and	r24, r20
     19a:	81 bb       	out	0x11, r24	; 17
     19c:	08 95       	ret

0000019e <GPIO_PinWrite>:

    uint8_t v_portNumber_u8;


    v_portNumber_u8 =  (enm_pinNumber>>3);  // Divide the pin number by 8 go get the PORT number
    enm_pinNumber  =   enm_pinNumber & 0x07;  // lower 3-bits contains the bit number of a byte 
     19e:	98 2f       	mov	r25, r24
     1a0:	97 70       	andi	r25, 0x07	; 7
{

    uint8_t v_portNumber_u8;


    v_portNumber_u8 =  (enm_pinNumber>>3);  // Divide the pin number by 8 go get the PORT number
     1a2:	86 95       	lsr	r24
     1a4:	86 95       	lsr	r24
     1a6:	86 95       	lsr	r24
    enm_pinNumber  =   enm_pinNumber & 0x07;  // lower 3-bits contains the bit number of a byte 

    /* Go to particular port after decoding from the pin number and 
        update the value of the specified pin*/
    switch(v_portNumber_u8)
     1a8:	81 30       	cpi	r24, 0x01	; 1
     1aa:	01 f1       	breq	.+64     	; 0x1ec <GPIO_PinWrite+0x4e>
     1ac:	30 f0       	brcs	.+12     	; 0x1ba <GPIO_PinWrite+0x1c>
     1ae:	82 30       	cpi	r24, 0x02	; 2
     1b0:	b1 f1       	breq	.+108    	; 0x21e <GPIO_PinWrite+0x80>
     1b2:	83 30       	cpi	r24, 0x03	; 3
     1b4:	09 f4       	brne	.+2      	; 0x1b8 <GPIO_PinWrite+0x1a>
     1b6:	4c c0       	rjmp	.+152    	; 0x250 <GPIO_PinWrite+0xb2>
     1b8:	08 95       	ret
    {
#ifdef PORTA        
    case 0:
        util_UpdateBit(PORTA,enm_pinNumber,v_pinValue_u8);
     1ba:	4b b3       	in	r20, 0x1b	; 27
     1bc:	21 e0       	ldi	r18, 0x01	; 1
     1be:	30 e0       	ldi	r19, 0x00	; 0
     1c0:	66 23       	and	r22, r22
     1c2:	49 f0       	breq	.+18     	; 0x1d6 <GPIO_PinWrite+0x38>
     1c4:	b9 01       	movw	r22, r18
     1c6:	02 c0       	rjmp	.+4      	; 0x1cc <GPIO_PinWrite+0x2e>
     1c8:	66 0f       	add	r22, r22
     1ca:	77 1f       	adc	r23, r23
     1cc:	9a 95       	dec	r25
     1ce:	e2 f7       	brpl	.-8      	; 0x1c8 <GPIO_PinWrite+0x2a>
     1d0:	cb 01       	movw	r24, r22
     1d2:	84 2b       	or	r24, r20
     1d4:	09 c0       	rjmp	.+18     	; 0x1e8 <GPIO_PinWrite+0x4a>
     1d6:	b9 01       	movw	r22, r18
     1d8:	02 c0       	rjmp	.+4      	; 0x1de <GPIO_PinWrite+0x40>
     1da:	66 0f       	add	r22, r22
     1dc:	77 1f       	adc	r23, r23
     1de:	9a 95       	dec	r25
     1e0:	e2 f7       	brpl	.-8      	; 0x1da <GPIO_PinWrite+0x3c>
     1e2:	cb 01       	movw	r24, r22
     1e4:	80 95       	com	r24
     1e6:	84 23       	and	r24, r20
     1e8:	8b bb       	out	0x1b, r24	; 27
     1ea:	08 95       	ret
#endif        

        
#ifdef PORTB
    case 1:
        util_UpdateBit(PORTB,enm_pinNumber,v_pinValue_u8);
     1ec:	48 b3       	in	r20, 0x18	; 24
     1ee:	21 e0       	ldi	r18, 0x01	; 1
     1f0:	30 e0       	ldi	r19, 0x00	; 0
     1f2:	66 23       	and	r22, r22
     1f4:	49 f0       	breq	.+18     	; 0x208 <GPIO_PinWrite+0x6a>
     1f6:	b9 01       	movw	r22, r18
     1f8:	02 c0       	rjmp	.+4      	; 0x1fe <GPIO_PinWrite+0x60>
     1fa:	66 0f       	add	r22, r22
     1fc:	77 1f       	adc	r23, r23
     1fe:	9a 95       	dec	r25
     200:	e2 f7       	brpl	.-8      	; 0x1fa <GPIO_PinWrite+0x5c>
     202:	cb 01       	movw	r24, r22
     204:	84 2b       	or	r24, r20
     206:	09 c0       	rjmp	.+18     	; 0x21a <GPIO_PinWrite+0x7c>
     208:	b9 01       	movw	r22, r18
     20a:	02 c0       	rjmp	.+4      	; 0x210 <GPIO_PinWrite+0x72>
     20c:	66 0f       	add	r22, r22
     20e:	77 1f       	adc	r23, r23
     210:	9a 95       	dec	r25
     212:	e2 f7       	brpl	.-8      	; 0x20c <GPIO_PinWrite+0x6e>
     214:	cb 01       	movw	r24, r22
     216:	80 95       	com	r24
     218:	84 23       	and	r24, r20
     21a:	88 bb       	out	0x18, r24	; 24
     21c:	08 95       	ret
#endif        

        
#ifdef PORTC        
    case 2:
        util_UpdateBit(PORTC,enm_pinNumber,v_pinValue_u8);
     21e:	45 b3       	in	r20, 0x15	; 21
     220:	21 e0       	ldi	r18, 0x01	; 1
     222:	30 e0       	ldi	r19, 0x00	; 0
     224:	66 23       	and	r22, r22
     226:	49 f0       	breq	.+18     	; 0x23a <GPIO_PinWrite+0x9c>
     228:	b9 01       	movw	r22, r18
     22a:	02 c0       	rjmp	.+4      	; 0x230 <GPIO_PinWrite+0x92>
     22c:	66 0f       	add	r22, r22
     22e:	77 1f       	adc	r23, r23
     230:	9a 95       	dec	r25
     232:	e2 f7       	brpl	.-8      	; 0x22c <GPIO_PinWrite+0x8e>
     234:	cb 01       	movw	r24, r22
     236:	84 2b       	or	r24, r20
     238:	09 c0       	rjmp	.+18     	; 0x24c <GPIO_PinWrite+0xae>
     23a:	b9 01       	movw	r22, r18
     23c:	02 c0       	rjmp	.+4      	; 0x242 <GPIO_PinWrite+0xa4>
     23e:	66 0f       	add	r22, r22
     240:	77 1f       	adc	r23, r23
     242:	9a 95       	dec	r25
     244:	e2 f7       	brpl	.-8      	; 0x23e <GPIO_PinWrite+0xa0>
     246:	cb 01       	movw	r24, r22
     248:	80 95       	com	r24
     24a:	84 23       	and	r24, r20
     24c:	85 bb       	out	0x15, r24	; 21
     24e:	08 95       	ret
#endif        

        
#ifdef PORTD        
    case 3:
        util_UpdateBit(PORTD,enm_pinNumber,v_pinValue_u8);
     250:	42 b3       	in	r20, 0x12	; 18
     252:	21 e0       	ldi	r18, 0x01	; 1
     254:	30 e0       	ldi	r19, 0x00	; 0
     256:	66 23       	and	r22, r22
     258:	49 f0       	breq	.+18     	; 0x26c <GPIO_PinWrite+0xce>
     25a:	b9 01       	movw	r22, r18
     25c:	02 c0       	rjmp	.+4      	; 0x262 <GPIO_PinWrite+0xc4>
     25e:	66 0f       	add	r22, r22
     260:	77 1f       	adc	r23, r23
     262:	9a 95       	dec	r25
     264:	e2 f7       	brpl	.-8      	; 0x25e <GPIO_PinWrite+0xc0>
     266:	cb 01       	movw	r24, r22
     268:	84 2b       	or	r24, r20
     26a:	09 c0       	rjmp	.+18     	; 0x27e <GPIO_PinWrite+0xe0>
     26c:	b9 01       	movw	r22, r18
     26e:	02 c0       	rjmp	.+4      	; 0x274 <GPIO_PinWrite+0xd6>
     270:	66 0f       	add	r22, r22
     272:	77 1f       	adc	r23, r23
     274:	9a 95       	dec	r25
     276:	e2 f7       	brpl	.-8      	; 0x270 <GPIO_PinWrite+0xd2>
     278:	cb 01       	movw	r24, r22
     27a:	80 95       	com	r24
     27c:	84 23       	and	r24, r20
     27e:	82 bb       	out	0x12, r24	; 18
     280:	08 95       	ret

00000282 <GPIO_PinRead>:
{
    uint8_t v_portNumber_u8;
    uint8_t returnStatus = 0;

    v_portNumber_u8 =  (enm_pinNumber>>3); // Divide the pin number by 8 go get the PORT number
    enm_pinNumber  =     enm_pinNumber & 0x07; // lower 3-bits contains the bit number of a byte 
     282:	28 2f       	mov	r18, r24
     284:	27 70       	andi	r18, 0x07	; 7
uint8_t GPIO_PinRead(gpioPins_et enm_pinNumber)
{
    uint8_t v_portNumber_u8;
    uint8_t returnStatus = 0;

    v_portNumber_u8 =  (enm_pinNumber>>3); // Divide the pin number by 8 go get the PORT number
     286:	86 95       	lsr	r24
     288:	86 95       	lsr	r24
     28a:	86 95       	lsr	r24
    enm_pinNumber  =     enm_pinNumber & 0x07; // lower 3-bits contains the bit number of a byte 

    /* Go to particular port after decoding from the pin number and read the pins status */
    switch(v_portNumber_u8)     
     28c:	81 30       	cpi	r24, 0x01	; 1
     28e:	49 f0       	breq	.+18     	; 0x2a2 <GPIO_PinRead+0x20>
     290:	30 f0       	brcs	.+12     	; 0x29e <GPIO_PinRead+0x1c>
     292:	82 30       	cpi	r24, 0x02	; 2
     294:	41 f0       	breq	.+16     	; 0x2a6 <GPIO_PinRead+0x24>
     296:	83 30       	cpi	r24, 0x03	; 3
     298:	79 f4       	brne	.+30     	; 0x2b8 <GPIO_PinRead+0x36>
#endif        
        
        
#ifdef PIND
    case 3:
        returnStatus = util_IsBitSet(PIND,enm_pinNumber);
     29a:	80 b3       	in	r24, 0x10	; 16
     29c:	05 c0       	rjmp	.+10     	; 0x2a8 <GPIO_PinRead+0x26>
    /* Go to particular port after decoding from the pin number and read the pins status */
    switch(v_portNumber_u8)     
    { 
#ifdef PINA    
    case 0: 
        returnStatus = util_IsBitSet(PINA,enm_pinNumber);
     29e:	89 b3       	in	r24, 0x19	; 25
     2a0:	03 c0       	rjmp	.+6      	; 0x2a8 <GPIO_PinRead+0x26>
        break;
#endif        

#ifdef PINB
    case 1:
        returnStatus = util_IsBitSet(PINB,enm_pinNumber);
     2a2:	86 b3       	in	r24, 0x16	; 22
     2a4:	01 c0       	rjmp	.+2      	; 0x2a8 <GPIO_PinRead+0x26>
        break;
#endif          

#ifdef PINC
    case 2:
        returnStatus = util_IsBitSet(PINC,enm_pinNumber);
     2a6:	83 b3       	in	r24, 0x13	; 19
#endif        
        
        
#ifdef PIND
    case 3:
        returnStatus = util_IsBitSet(PIND,enm_pinNumber);
     2a8:	90 e0       	ldi	r25, 0x00	; 0
     2aa:	02 c0       	rjmp	.+4      	; 0x2b0 <GPIO_PinRead+0x2e>
     2ac:	95 95       	asr	r25
     2ae:	87 95       	ror	r24
     2b0:	2a 95       	dec	r18
     2b2:	e2 f7       	brpl	.-8      	; 0x2ac <GPIO_PinRead+0x2a>
     2b4:	81 70       	andi	r24, 0x01	; 1
        break;
     2b6:	08 95       	ret
                Before reading the pins status, the pin should be configured as INPUT 
 ***************************************************************************************************/
uint8_t GPIO_PinRead(gpioPins_et enm_pinNumber)
{
    uint8_t v_portNumber_u8;
    uint8_t returnStatus = 0;
     2b8:	80 e0       	ldi	r24, 0x00	; 0
        returnStatus = util_IsBitSet(PING,enm_pinNumber);
        break;
#endif             
    }                         
    return returnStatus;
}
     2ba:	08 95       	ret

000002bc <I2C_Init>:

 * description :This function is used to initialize the I2C module
------------------------------------------------------------------------------------*/
void I2C_Init()
{
    TWSR=0x00; //set presca1er bits to zero
     2bc:	11 b8       	out	0x01, r1	; 1
    TWBR=0x46; //SCL frequency is 50K for 16Mhz
     2be:	86 e4       	ldi	r24, 0x46	; 70
     2c0:	80 b9       	out	0x00, r24	; 0
    TWCR=0x04; //enab1e TWI module
     2c2:	84 e0       	ldi	r24, 0x04	; 4
     2c4:	86 bf       	out	0x36, r24	; 54
     2c6:	08 95       	ret

000002c8 <I2C_Start>:
                      ____|         |____________

 ***************************************************************************************************/
void I2C_Start()
{
    TWCR = ((1<<TWINT) | (1<<TWSTA) | (1<<TWEN));
     2c8:	84 ea       	ldi	r24, 0xA4	; 164
     2ca:	86 bf       	out	0x36, r24	; 54
    while (!(TWCR & (1<<TWINT)));
     2cc:	06 b6       	in	r0, 0x36	; 54
     2ce:	07 fe       	sbrs	r0, 7
     2d0:	fd cf       	rjmp	.-6      	; 0x2cc <I2C_Start+0x4>
}
     2d2:	08 95       	ret

000002d4 <I2C_Stop>:

 ***************************************************************************************************/

void I2C_Stop(void)
{
    TWCR = ((1<< TWINT) | (1<<TWEN) | (1<<TWSTO));
     2d4:	84 e9       	ldi	r24, 0x94	; 148
     2d6:	86 bf       	out	0x36, r24	; 54
    DELAY_us(100) ; //wait for a short time
     2d8:	84 e6       	ldi	r24, 0x64	; 100
     2da:	90 e0       	ldi	r25, 0x00	; 0
     2dc:	0c 94 49 00 	jmp	0x92	; 0x92 <DELAY_us>

000002e0 <I2C_Write>:


 ***************************************************************************************************/
void I2C_Write(uint8_t v_i2cData_u8)
{
    TWDR = v_i2cData_u8 ;
     2e0:	83 b9       	out	0x03, r24	; 3
    TWCR = ((1<< TWINT) | (1<<TWEN));
     2e2:	84 e8       	ldi	r24, 0x84	; 132
     2e4:	86 bf       	out	0x36, r24	; 54
    while (!(TWCR & (1 <<TWINT)));
     2e6:	06 b6       	in	r0, 0x36	; 54
     2e8:	07 fe       	sbrs	r0, 7
     2ea:	fd cf       	rjmp	.-6      	; 0x2e6 <I2C_Write+0x6>
}
     2ec:	08 95       	ret

000002ee <I2C_Read>:


***************************************************************************************************/
uint8_t I2C_Read(uint8_t v_ackOption_u8)
{
    TWCR = ((1<< TWINT) | (1<<TWEN) | (v_ackOption_u8<<TWEA));
     2ee:	20 e4       	ldi	r18, 0x40	; 64
     2f0:	82 9f       	mul	r24, r18
     2f2:	c0 01       	movw	r24, r0
     2f4:	11 24       	eor	r1, r1
     2f6:	84 68       	ori	r24, 0x84	; 132
     2f8:	86 bf       	out	0x36, r24	; 54
    while ( !(TWCR & (1 <<TWINT)));
     2fa:	06 b6       	in	r0, 0x36	; 54
     2fc:	07 fe       	sbrs	r0, 7
     2fe:	fd cf       	rjmp	.-6      	; 0x2fa <I2C_Read+0xc>
    return TWDR;
     300:	83 b1       	in	r24, 0x03	; 3
}
     302:	08 95       	ret

00000304 <lcd_SendHigherNibble>:
 * Return value    : none

 * description : This functions is used to send the higher nibble of the data to LCD in 4-bit mode
**************************************************************************************************/
static void lcd_SendHigherNibble(uint8_t dataByte)
{
     304:	0f 93       	push	r16
     306:	1f 93       	push	r17
     308:	cf 93       	push	r28
     30a:	c8 2f       	mov	r28, r24
    GPIO_PinWrite(LCDConfig.D4,util_IsBitSet(dataByte,4));
     30c:	84 fb       	bst	r24, 4
     30e:	66 27       	eor	r22, r22
     310:	60 f9       	bld	r22, 0
     312:	08 e8       	ldi	r16, 0x88	; 136
     314:	10 e0       	ldi	r17, 0x00	; 0
     316:	f8 01       	movw	r30, r16
     318:	82 85       	ldd	r24, Z+10	; 0x0a
     31a:	0e 94 cf 00 	call	0x19e	; 0x19e <GPIO_PinWrite>
    GPIO_PinWrite(LCDConfig.D5,util_IsBitSet(dataByte,5));
     31e:	c5 fb       	bst	r28, 5
     320:	66 27       	eor	r22, r22
     322:	60 f9       	bld	r22, 0
     324:	f8 01       	movw	r30, r16
     326:	83 85       	ldd	r24, Z+11	; 0x0b
     328:	0e 94 cf 00 	call	0x19e	; 0x19e <GPIO_PinWrite>
    GPIO_PinWrite(LCDConfig.D6,util_IsBitSet(dataByte,6));
     32c:	c6 fb       	bst	r28, 6
     32e:	66 27       	eor	r22, r22
     330:	60 f9       	bld	r22, 0
     332:	f8 01       	movw	r30, r16
     334:	84 85       	ldd	r24, Z+12	; 0x0c
     336:	0e 94 cf 00 	call	0x19e	; 0x19e <GPIO_PinWrite>
    GPIO_PinWrite(LCDConfig.D7,util_IsBitSet(dataByte,7));
     33a:	6c 2f       	mov	r22, r28
     33c:	66 1f       	adc	r22, r22
     33e:	66 27       	eor	r22, r22
     340:	66 1f       	adc	r22, r22
     342:	f8 01       	movw	r30, r16
     344:	85 85       	ldd	r24, Z+13	; 0x0d
}
     346:	cf 91       	pop	r28
     348:	1f 91       	pop	r17
     34a:	0f 91       	pop	r16
static void lcd_SendHigherNibble(uint8_t dataByte)
{
    GPIO_PinWrite(LCDConfig.D4,util_IsBitSet(dataByte,4));
    GPIO_PinWrite(LCDConfig.D5,util_IsBitSet(dataByte,5));
    GPIO_PinWrite(LCDConfig.D6,util_IsBitSet(dataByte,6));
    GPIO_PinWrite(LCDConfig.D7,util_IsBitSet(dataByte,7));
     34c:	0c 94 cf 00 	jmp	0x19e	; 0x19e <GPIO_PinWrite>

00000350 <lcd_SendCmdSignals>:
 * Return value    : none

 * description : This functions generates the signals for sending the v_lcdCmd_u8 to LCD
**************************************************************************************************/
static void lcd_SendCmdSignals(void)
{
     350:	cf 93       	push	r28
     352:	df 93       	push	r29
     GPIO_PinWrite(LCDConfig.RS,0);
     354:	c8 e8       	ldi	r28, 0x88	; 136
     356:	d0 e0       	ldi	r29, 0x00	; 0
     358:	60 e0       	ldi	r22, 0x00	; 0
     35a:	8b 81       	ldd	r24, Y+3	; 0x03
     35c:	0e 94 cf 00 	call	0x19e	; 0x19e <GPIO_PinWrite>
     GPIO_PinWrite(LCDConfig.RW,0);
     360:	60 e0       	ldi	r22, 0x00	; 0
     362:	8c 81       	ldd	r24, Y+4	; 0x04
     364:	0e 94 cf 00 	call	0x19e	; 0x19e <GPIO_PinWrite>
     GPIO_PinWrite(LCDConfig.EN,1);
     368:	61 e0       	ldi	r22, 0x01	; 1
     36a:	8d 81       	ldd	r24, Y+5	; 0x05
     36c:	0e 94 cf 00 	call	0x19e	; 0x19e <GPIO_PinWrite>
     DELAY_us(10);
     370:	8a e0       	ldi	r24, 0x0A	; 10
     372:	90 e0       	ldi	r25, 0x00	; 0
     374:	0e 94 49 00 	call	0x92	; 0x92 <DELAY_us>
     GPIO_PinWrite(LCDConfig.EN,0);
     378:	60 e0       	ldi	r22, 0x00	; 0
     37a:	8d 81       	ldd	r24, Y+5	; 0x05
  
}
     37c:	df 91       	pop	r29
     37e:	cf 91       	pop	r28
{
     GPIO_PinWrite(LCDConfig.RS,0);
     GPIO_PinWrite(LCDConfig.RW,0);
     GPIO_PinWrite(LCDConfig.EN,1);
     DELAY_us(10);
     GPIO_PinWrite(LCDConfig.EN,0);
     380:	0c 94 cf 00 	jmp	0x19e	; 0x19e <GPIO_PinWrite>

00000384 <lcd_SendLowerNibble>:
 * Return value    : none

 * description : This functions is used to send the lower nibble of the data to LCD
**************************************************************************************************/
static void lcd_SendLowerNibble(uint8_t dataByte)
{
     384:	0f 93       	push	r16
     386:	1f 93       	push	r17
     388:	cf 93       	push	r28
     38a:	c8 2f       	mov	r28, r24
    GPIO_PinWrite(LCDConfig.D0,util_IsBitSet(dataByte,0));
     38c:	68 2f       	mov	r22, r24
     38e:	61 70       	andi	r22, 0x01	; 1
     390:	08 e8       	ldi	r16, 0x88	; 136
     392:	10 e0       	ldi	r17, 0x00	; 0
     394:	f8 01       	movw	r30, r16
     396:	86 81       	ldd	r24, Z+6	; 0x06
     398:	0e 94 cf 00 	call	0x19e	; 0x19e <GPIO_PinWrite>
    GPIO_PinWrite(LCDConfig.D1,util_IsBitSet(dataByte,1));
     39c:	c1 fb       	bst	r28, 1
     39e:	66 27       	eor	r22, r22
     3a0:	60 f9       	bld	r22, 0
     3a2:	f8 01       	movw	r30, r16
     3a4:	87 81       	ldd	r24, Z+7	; 0x07
     3a6:	0e 94 cf 00 	call	0x19e	; 0x19e <GPIO_PinWrite>
    GPIO_PinWrite(LCDConfig.D2,util_IsBitSet(dataByte,2));
     3aa:	c2 fb       	bst	r28, 2
     3ac:	66 27       	eor	r22, r22
     3ae:	60 f9       	bld	r22, 0
     3b0:	f8 01       	movw	r30, r16
     3b2:	80 85       	ldd	r24, Z+8	; 0x08
     3b4:	0e 94 cf 00 	call	0x19e	; 0x19e <GPIO_PinWrite>
    GPIO_PinWrite(LCDConfig.D3,util_IsBitSet(dataByte,3));
     3b8:	c3 fb       	bst	r28, 3
     3ba:	66 27       	eor	r22, r22
     3bc:	60 f9       	bld	r22, 0
     3be:	f8 01       	movw	r30, r16
     3c0:	81 85       	ldd	r24, Z+9	; 0x09
}
     3c2:	cf 91       	pop	r28
     3c4:	1f 91       	pop	r17
     3c6:	0f 91       	pop	r16
static void lcd_SendLowerNibble(uint8_t dataByte)
{
    GPIO_PinWrite(LCDConfig.D0,util_IsBitSet(dataByte,0));
    GPIO_PinWrite(LCDConfig.D1,util_IsBitSet(dataByte,1));
    GPIO_PinWrite(LCDConfig.D2,util_IsBitSet(dataByte,2));
    GPIO_PinWrite(LCDConfig.D3,util_IsBitSet(dataByte,3));
     3c8:	0c 94 cf 00 	jmp	0x19e	; 0x19e <GPIO_PinWrite>

000003cc <lcd_SendDataSignals>:
 * Return value    : none

 * description : This functions generates the signals for sending the Data to LCD
**************************************************************************************************/
static void lcd_SendDataSignals(void)
{
     3cc:	cf 93       	push	r28
     3ce:	df 93       	push	r29
     GPIO_PinWrite(LCDConfig.RS,1);
     3d0:	c8 e8       	ldi	r28, 0x88	; 136
     3d2:	d0 e0       	ldi	r29, 0x00	; 0
     3d4:	61 e0       	ldi	r22, 0x01	; 1
     3d6:	8b 81       	ldd	r24, Y+3	; 0x03
     3d8:	0e 94 cf 00 	call	0x19e	; 0x19e <GPIO_PinWrite>
     GPIO_PinWrite(LCDConfig.RW,0);
     3dc:	60 e0       	ldi	r22, 0x00	; 0
     3de:	8c 81       	ldd	r24, Y+4	; 0x04
     3e0:	0e 94 cf 00 	call	0x19e	; 0x19e <GPIO_PinWrite>
     GPIO_PinWrite(LCDConfig.EN,1);
     3e4:	61 e0       	ldi	r22, 0x01	; 1
     3e6:	8d 81       	ldd	r24, Y+5	; 0x05
     3e8:	0e 94 cf 00 	call	0x19e	; 0x19e <GPIO_PinWrite>
     DELAY_us(10);
     3ec:	8a e0       	ldi	r24, 0x0A	; 10
     3ee:	90 e0       	ldi	r25, 0x00	; 0
     3f0:	0e 94 49 00 	call	0x92	; 0x92 <DELAY_us>
     GPIO_PinWrite(LCDConfig.EN,0);
     3f4:	60 e0       	ldi	r22, 0x00	; 0
     3f6:	8d 81       	ldd	r24, Y+5	; 0x05
}
     3f8:	df 91       	pop	r29
     3fa:	cf 91       	pop	r28
{
     GPIO_PinWrite(LCDConfig.RS,1);
     GPIO_PinWrite(LCDConfig.RW,0);
     GPIO_PinWrite(LCDConfig.EN,1);
     DELAY_us(10);
     GPIO_PinWrite(LCDConfig.EN,0);
     3fc:	0c 94 cf 00 	jmp	0x19e	; 0x19e <GPIO_PinWrite>

00000400 <lcd_BusyCheck>:
 * description : This functions is used check whether LCD is busy.
                 It waits till the LCD is busy by polling the LCD busy flag.
                 After completing the previous operation, LCDs clears its internal busy flag.
**************************************************************************************************/
static void lcd_BusyCheck(void)
{
     400:	cf 93       	push	r28
    uint8_t busyflag;
 
  if(LCDConfig.RW != P_NC)                         //Perform Busy check if RW pin is used
     402:	80 91 8c 00 	lds	r24, 0x008C
     406:	8f 3f       	cpi	r24, 0xFF	; 255
     408:	09 f4       	brne	.+2      	; 0x40c <lcd_BusyCheck+0xc>
     40a:	44 c0       	rjmp	.+136    	; 0x494 <lcd_BusyCheck+0x94>
   {
    GPIO_PinDirection(LCDConfig.D7,INPUT); // Configure busy pin as input
     40c:	60 e0       	ldi	r22, 0x00	; 0
     40e:	80 91 95 00 	lds	r24, 0x0095
     412:	0e 94 5d 00 	call	0xba	; 0xba <GPIO_PinDirection>
    GPIO_PinWrite(LCDConfig.RS,0);           // Select the Command Register by pulling RS LOW
     416:	60 e0       	ldi	r22, 0x00	; 0
     418:	80 91 8b 00 	lds	r24, 0x008B
     41c:	0e 94 cf 00 	call	0x19e	; 0x19e <GPIO_PinWrite>
    GPIO_PinWrite(LCDConfig.RW,1);           // Select the Read Operation for busy flag by setting RW
     420:	61 e0       	ldi	r22, 0x01	; 1
     422:	80 91 8c 00 	lds	r24, 0x008C
     426:	0e 94 cf 00 	call	0x19e	; 0x19e <GPIO_PinWrite>
    do
    {

        GPIO_PinWrite(LCDConfig.EN,0);
     42a:	60 e0       	ldi	r22, 0x00	; 0
     42c:	80 91 8d 00 	lds	r24, 0x008D
     430:	0e 94 cf 00 	call	0x19e	; 0x19e <GPIO_PinWrite>
        DELAY_us(10);
     434:	8a e0       	ldi	r24, 0x0A	; 10
     436:	90 e0       	ldi	r25, 0x00	; 0
     438:	0e 94 49 00 	call	0x92	; 0x92 <DELAY_us>
        GPIO_PinWrite(LCDConfig.EN,1); 
     43c:	61 e0       	ldi	r22, 0x01	; 1
     43e:	80 91 8d 00 	lds	r24, 0x008D
     442:	0e 94 cf 00 	call	0x19e	; 0x19e <GPIO_PinWrite>
        DELAY_us(10);
     446:	8a e0       	ldi	r24, 0x0A	; 10
     448:	90 e0       	ldi	r25, 0x00	; 0
     44a:	0e 94 49 00 	call	0x92	; 0x92 <DELAY_us>
        busyflag = GPIO_PinRead(LCDConfig.D7);
     44e:	80 91 95 00 	lds	r24, 0x0095
     452:	0e 94 41 01 	call	0x282	; 0x282 <GPIO_PinRead>
     456:	c8 2f       	mov	r28, r24


        if(LCDConfig.v_LcdMode_U8 == 4)
     458:	80 91 8a 00 	lds	r24, 0x008A
     45c:	84 30       	cpi	r24, 0x04	; 4
     45e:	91 f4       	brne	.+36     	; 0x484 <lcd_BusyCheck+0x84>
        {
            /* Perform extra dummy read for 4-bit */            
            GPIO_PinWrite(LCDConfig.EN,0);
     460:	60 e0       	ldi	r22, 0x00	; 0
     462:	80 91 8d 00 	lds	r24, 0x008D
     466:	0e 94 cf 00 	call	0x19e	; 0x19e <GPIO_PinWrite>
            DELAY_us(10);
     46a:	8a e0       	ldi	r24, 0x0A	; 10
     46c:	90 e0       	ldi	r25, 0x00	; 0
     46e:	0e 94 49 00 	call	0x92	; 0x92 <DELAY_us>
            GPIO_PinWrite(LCDConfig.EN,1); 
     472:	61 e0       	ldi	r22, 0x01	; 1
     474:	80 91 8d 00 	lds	r24, 0x008D
     478:	0e 94 cf 00 	call	0x19e	; 0x19e <GPIO_PinWrite>
            DELAY_us(10);
     47c:	8a e0       	ldi	r24, 0x0A	; 10
     47e:	90 e0       	ldi	r25, 0x00	; 0
     480:	0e 94 49 00 	call	0x92	; 0x92 <DELAY_us>
        }    
    }while(busyflag!=0);
     484:	c1 11       	cpse	r28, r1
     486:	d1 cf       	rjmp	.-94     	; 0x42a <lcd_BusyCheck+0x2a>

    GPIO_PinDirection(LCDConfig.D7,OUTPUT); // Configure busy pin as Output
     488:	61 e0       	ldi	r22, 0x01	; 1
     48a:	80 91 95 00 	lds	r24, 0x0095
 {
    /* Busy flag cannot be read as RW is not available hence Extra delay of 1ms is added 
      to ensure the LCD completes previous operation and ready to receive new commands/data */
    DELAY_ms(1);  
 }
}
     48e:	cf 91       	pop	r28
            GPIO_PinWrite(LCDConfig.EN,1); 
            DELAY_us(10);
        }    
    }while(busyflag!=0);

    GPIO_PinDirection(LCDConfig.D7,OUTPUT); // Configure busy pin as Output
     490:	0c 94 5d 00 	jmp	0xba	; 0xba <GPIO_PinDirection>
  }
else
 {
    /* Busy flag cannot be read as RW is not available hence Extra delay of 1ms is added 
      to ensure the LCD completes previous operation and ready to receive new commands/data */
    DELAY_ms(1);  
     494:	81 e0       	ldi	r24, 0x01	; 1
     496:	90 e0       	ldi	r25, 0x00	; 0
 }
}
     498:	cf 91       	pop	r28
  }
else
 {
    /* Busy flag cannot be read as RW is not available hence Extra delay of 1ms is added 
      to ensure the LCD completes previous operation and ready to receive new commands/data */
    DELAY_ms(1);  
     49a:	0c 94 52 00 	jmp	0xa4	; 0xa4 <DELAY_ms>

0000049e <LCD_SetUp>:
               gpioPins_et D3,
               gpioPins_et D4,
               gpioPins_et D5,
               gpioPins_et D6,
               gpioPins_et D7 )
{
     49e:	8f 92       	push	r8
     4a0:	9f 92       	push	r9
     4a2:	af 92       	push	r10
     4a4:	bf 92       	push	r11
     4a6:	cf 92       	push	r12
     4a8:	df 92       	push	r13
     4aa:	ef 92       	push	r14
     4ac:	ff 92       	push	r15
     4ae:	0f 93       	push	r16
     4b0:	1f 93       	push	r17
     4b2:	cf 93       	push	r28
     4b4:	df 93       	push	r29
     4b6:	cd b7       	in	r28, 0x3d	; 61
     4b8:	de b7       	in	r29, 0x3e	; 62
     4ba:	98 2e       	mov	r9, r24
     4bc:	b6 2e       	mov	r11, r22
     4be:	d4 2e       	mov	r13, r20
     4c0:	ff 84       	ldd	r15, Y+15	; 0x0f
     4c2:	18 89       	ldd	r17, Y+16	; 0x10
  /* Copy the PIN numbers where the LCD is connected */
    LCDConfig.RS = RS;
     4c4:	80 93 8b 00 	sts	0x008B, r24
    LCDConfig.RW = RW;
     4c8:	60 93 8c 00 	sts	0x008C, r22
    LCDConfig.EN = EN;
     4cc:	40 93 8d 00 	sts	0x008D, r20

    LCDConfig.D0 = D0;
     4d0:	20 93 8e 00 	sts	0x008E, r18
    LCDConfig.D1 = D1;
     4d4:	00 93 8f 00 	sts	0x008F, r16
    LCDConfig.D2 = D2;
     4d8:	e0 92 90 00 	sts	0x0090, r14
    LCDConfig.D3 = D3;
     4dc:	c0 92 91 00 	sts	0x0091, r12
    LCDConfig.D4 = D4;
     4e0:	a0 92 92 00 	sts	0x0092, r10
    LCDConfig.D5 = D5;
     4e4:	80 92 93 00 	sts	0x0093, r8
    LCDConfig.D6 = D6;
     4e8:	f0 92 94 00 	sts	0x0094, r15
    LCDConfig.D7 = D7;
     4ec:	10 93 95 00 	sts	0x0095, r17


    if((D0 == P_NC) || (D1 == P_NC) || (D2 == P_NC) || (D3 == P_NC))
     4f0:	2f 3f       	cpi	r18, 0xFF	; 255
     4f2:	39 f0       	breq	.+14     	; 0x502 <LCD_SetUp+0x64>
     4f4:	0f 3f       	cpi	r16, 0xFF	; 255
     4f6:	29 f0       	breq	.+10     	; 0x502 <LCD_SetUp+0x64>
     4f8:	8f ef       	ldi	r24, 0xFF	; 255
     4fa:	e8 16       	cp	r14, r24
     4fc:	11 f0       	breq	.+4      	; 0x502 <LCD_SetUp+0x64>
     4fe:	c8 12       	cpse	r12, r24
     500:	04 c0       	rjmp	.+8      	; 0x50a <LCD_SetUp+0x6c>
    {
        LCDConfig.v_LcdMode_U8 = 4; // Select 4-bit mode as D0-D3 are not used(P_NC)
     502:	84 e0       	ldi	r24, 0x04	; 4
     504:	80 93 8a 00 	sts	0x008A, r24
     508:	13 c0       	rjmp	.+38     	; 0x530 <LCD_SetUp+0x92>
    }
    else
    {
        LCDConfig.v_LcdMode_U8 = 8; // 8-bit mode configure D0-D3 as output.      
     50a:	88 e0       	ldi	r24, 0x08	; 8
     50c:	80 93 8a 00 	sts	0x008A, r24
        GPIO_PinDirection(D0,OUTPUT);
     510:	61 e0       	ldi	r22, 0x01	; 1
     512:	82 2f       	mov	r24, r18
     514:	0e 94 5d 00 	call	0xba	; 0xba <GPIO_PinDirection>
        GPIO_PinDirection(D1,OUTPUT);
     518:	61 e0       	ldi	r22, 0x01	; 1
     51a:	80 2f       	mov	r24, r16
     51c:	0e 94 5d 00 	call	0xba	; 0xba <GPIO_PinDirection>
        GPIO_PinDirection(D2,OUTPUT);
     520:	61 e0       	ldi	r22, 0x01	; 1
     522:	8e 2d       	mov	r24, r14
     524:	0e 94 5d 00 	call	0xba	; 0xba <GPIO_PinDirection>
        GPIO_PinDirection(D3,OUTPUT);
     528:	61 e0       	ldi	r22, 0x01	; 1
     52a:	8c 2d       	mov	r24, r12
     52c:	0e 94 5d 00 	call	0xba	; 0xba <GPIO_PinDirection>
    }

    /* Configure RS,RW,EN, D4-D7 as Output for both 4/8-bit mode.*/
    GPIO_PinDirection(RS,OUTPUT);
     530:	61 e0       	ldi	r22, 0x01	; 1
     532:	89 2d       	mov	r24, r9
     534:	0e 94 5d 00 	call	0xba	; 0xba <GPIO_PinDirection>
    GPIO_PinDirection(RW,OUTPUT);
     538:	61 e0       	ldi	r22, 0x01	; 1
     53a:	8b 2d       	mov	r24, r11
     53c:	0e 94 5d 00 	call	0xba	; 0xba <GPIO_PinDirection>
    GPIO_PinDirection(EN,OUTPUT);
     540:	61 e0       	ldi	r22, 0x01	; 1
     542:	8d 2d       	mov	r24, r13
     544:	0e 94 5d 00 	call	0xba	; 0xba <GPIO_PinDirection>

    GPIO_PinDirection(D4,OUTPUT);
     548:	61 e0       	ldi	r22, 0x01	; 1
     54a:	8a 2d       	mov	r24, r10
     54c:	0e 94 5d 00 	call	0xba	; 0xba <GPIO_PinDirection>
    GPIO_PinDirection(D5,OUTPUT);
     550:	61 e0       	ldi	r22, 0x01	; 1
     552:	88 2d       	mov	r24, r8
     554:	0e 94 5d 00 	call	0xba	; 0xba <GPIO_PinDirection>
    GPIO_PinDirection(D6,OUTPUT);
     558:	61 e0       	ldi	r22, 0x01	; 1
     55a:	8f 2d       	mov	r24, r15
     55c:	0e 94 5d 00 	call	0xba	; 0xba <GPIO_PinDirection>
    GPIO_PinDirection(D7,OUTPUT);  
     560:	61 e0       	ldi	r22, 0x01	; 1
     562:	81 2f       	mov	r24, r17
}
     564:	df 91       	pop	r29
     566:	cf 91       	pop	r28
     568:	1f 91       	pop	r17
     56a:	0f 91       	pop	r16
     56c:	ff 90       	pop	r15
     56e:	ef 90       	pop	r14
     570:	df 90       	pop	r13
     572:	cf 90       	pop	r12
     574:	bf 90       	pop	r11
     576:	af 90       	pop	r10
     578:	9f 90       	pop	r9
     57a:	8f 90       	pop	r8
    GPIO_PinDirection(EN,OUTPUT);

    GPIO_PinDirection(D4,OUTPUT);
    GPIO_PinDirection(D5,OUTPUT);
    GPIO_PinDirection(D6,OUTPUT);
    GPIO_PinDirection(D7,OUTPUT);  
     57c:	0c 94 5d 00 	jmp	0xba	; 0xba <GPIO_PinDirection>

00000580 <LCD_CmdWrite>:
                Some of the commonly used commands are defined in lcd.h.
                For more commands refer the data sheet and send the supported command.                
                The behaviour is undefined if unsupported commands are sent.    
****************************************************************************************************/
void LCD_CmdWrite( uint8_t v_lcdCmd_u8)
{
     580:	cf 93       	push	r28
     582:	c8 2f       	mov	r28, r24
    lcd_BusyCheck();
     584:	0e 94 00 02 	call	0x400	; 0x400 <lcd_BusyCheck>
    if(LCDConfig.v_LcdMode_U8 == C_EightBitMode_U8)
     588:	80 91 8a 00 	lds	r24, 0x008A
     58c:	88 30       	cpi	r24, 0x08	; 8
     58e:	21 f4       	brne	.+8      	; 0x598 <LCD_CmdWrite+0x18>
     {
         lcd_SendLowerNibble(v_lcdCmd_u8);
     590:	8c 2f       	mov	r24, r28
     592:	0e 94 c2 01 	call	0x384	; 0x384 <lcd_SendLowerNibble>
     596:	07 c0       	rjmp	.+14     	; 0x5a6 <LCD_CmdWrite+0x26>
     }
     else
     {
         lcd_SendHigherNibble(v_lcdCmd_u8);
     598:	8c 2f       	mov	r24, r28
     59a:	0e 94 82 01 	call	0x304	; 0x304 <lcd_SendHigherNibble>
         lcd_SendCmdSignals();
     59e:	0e 94 a8 01 	call	0x350	; 0x350 <lcd_SendCmdSignals>
         v_lcdCmd_u8 = v_lcdCmd_u8 << 4;
     5a2:	c2 95       	swap	r28
     5a4:	c0 7f       	andi	r28, 0xF0	; 240
     }

     lcd_SendHigherNibble(v_lcdCmd_u8);
     5a6:	8c 2f       	mov	r24, r28
     5a8:	0e 94 82 01 	call	0x304	; 0x304 <lcd_SendHigherNibble>
     lcd_SendCmdSignals();
}
     5ac:	cf 91       	pop	r28
         lcd_SendCmdSignals();
         v_lcdCmd_u8 = v_lcdCmd_u8 << 4;
     }

     lcd_SendHigherNibble(v_lcdCmd_u8);
     lcd_SendCmdSignals();
     5ae:	0c 94 a8 01 	jmp	0x350	; 0x350 <lcd_SendCmdSignals>

000005b2 <LCD_GoToLine>:
           C_LcdLineThree,

****************************************************************************************************/
void LCD_GoToLine(uint8_t v_lineNumber_u8)
{
    if(v_lineNumber_u8 < LCDConfig.v_MaxSupportedLines_U8)
     5b2:	90 91 88 00 	lds	r25, 0x0088
     5b6:	89 17       	cp	r24, r25
     5b8:	58 f4       	brcc	.+22     	; 0x5d0 <LCD_GoToLine+0x1e>
    {
        /* If the line number is within range then
           Move the Cursor to beginning of the specified line */
        v_LcdTrackCursorPos_U8 = 0x00;
     5ba:	10 92 96 00 	sts	0x0096, r1
        v_LcdTrackLineNum_U8 = v_lineNumber_u8;
     5be:	80 93 97 00 	sts	0x0097, r24
        LCD_CmdWrite(ARR_LcdLineNumAddress_U8[v_lineNumber_u8]);
     5c2:	e8 2f       	mov	r30, r24
     5c4:	f0 e0       	ldi	r31, 0x00	; 0
     5c6:	e0 5a       	subi	r30, 0xA0	; 160
     5c8:	ff 4f       	sbci	r31, 0xFF	; 255
     5ca:	80 81       	ld	r24, Z
     5cc:	0c 94 c0 02 	jmp	0x580	; 0x580 <LCD_CmdWrite>
     5d0:	08 95       	ret

000005d2 <LCD_Clear>:

 * description  :This function clears the LCD and moves the cursor to beginning of first line
****************************************************************************************************/
void LCD_Clear()
{
    LCD_CmdWrite(CMD_LCD_CLEAR);    // Clear the LCD and go to First line First Position
     5d2:	81 e0       	ldi	r24, 0x01	; 1
     5d4:	0e 94 c0 02 	call	0x580	; 0x580 <LCD_CmdWrite>
    LCD_GoToLine(C_LcdLineZero);
     5d8:	80 e0       	ldi	r24, 0x00	; 0
     5da:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <LCD_GoToLine>

000005de <LCD_Init>:
**************************************************************************************************/
void LCD_Init(uint8_t v_lcdNoOfLines_u8, uint8_t v_MaxCharsPerLine_u8)
{


    LCDConfig.v_MaxSupportedChars_U8 = v_MaxCharsPerLine_u8; //Maintaian the LCD type
     5de:	60 93 89 00 	sts	0x0089, r22
    LCDConfig.v_MaxSupportedLines_U8 = v_lcdNoOfLines_u8;
     5e2:	80 93 88 00 	sts	0x0088, r24
    if(v_lcdNoOfLines_u8 > C_LcdLineTwo)
     5e6:	83 30       	cpi	r24, 0x03	; 3
     5e8:	40 f0       	brcs	.+16     	; 0x5fa <LCD_Init+0x1c>
    {
        ARR_LcdLineNumAddress_U8[C_LcdLineTwo] =  0x90 + (v_MaxCharsPerLine_u8 & 0x0fu);
     5ea:	6f 70       	andi	r22, 0x0F	; 15
     5ec:	80 e9       	ldi	r24, 0x90	; 144
     5ee:	86 0f       	add	r24, r22
     5f0:	80 93 62 00 	sts	0x0062, r24
        ARR_LcdLineNumAddress_U8[C_LcdLineThree] =  0xd0 + (v_MaxCharsPerLine_u8 & 0x0fu);
     5f4:	60 53       	subi	r22, 0x30	; 48
     5f6:	60 93 63 00 	sts	0x0063, r22
    }

    DELAY_ms(100);
     5fa:	84 e6       	ldi	r24, 0x64	; 100
     5fc:	90 e0       	ldi	r25, 0x00	; 0
     5fe:	0e 94 52 00 	call	0xa4	; 0xa4 <DELAY_ms>

    if(LCDConfig.v_LcdMode_U8 == C_EightBitMode_U8)
     602:	80 91 8a 00 	lds	r24, 0x008A
     606:	88 30       	cpi	r24, 0x08	; 8
     608:	11 f4       	brne	.+4      	; 0x60e <LCD_Init+0x30>
    {
        LCD_CmdWrite(CMD_LCD_EIGHT_BIT_MODE); // Initialize the LCD for 8-bit 5x7 matrix type
     60a:	88 e3       	ldi	r24, 0x38	; 56
     60c:	27 c0       	rjmp	.+78     	; 0x65c <LCD_Init+0x7e>
    }
    else if(LCDConfig.v_LcdMode_U8 == C_FourBitMode_U8)
     60e:	84 30       	cpi	r24, 0x04	; 4
     610:	39 f5       	brne	.+78     	; 0x660 <LCD_Init+0x82>
                 This is used only in 4-bit mode as the LCD by default boots in 8-Bit mode.
----------------------------------------------------------------------------------*/
static void lcd_Reset(void)
{
    /* LCD reset sequence for 4-bit mode, refer data sheet for more info */
    lcd_SendHigherNibble(0x30);
     612:	80 e3       	ldi	r24, 0x30	; 48
     614:	0e 94 82 01 	call	0x304	; 0x304 <lcd_SendHigherNibble>
    lcd_SendCmdSignals();
     618:	0e 94 a8 01 	call	0x350	; 0x350 <lcd_SendCmdSignals>
    DELAY_ms(100);
     61c:	84 e6       	ldi	r24, 0x64	; 100
     61e:	90 e0       	ldi	r25, 0x00	; 0
     620:	0e 94 52 00 	call	0xa4	; 0xa4 <DELAY_ms>
    lcd_SendHigherNibble(0x30);
     624:	80 e3       	ldi	r24, 0x30	; 48
     626:	0e 94 82 01 	call	0x304	; 0x304 <lcd_SendHigherNibble>
    lcd_SendCmdSignals();
     62a:	0e 94 a8 01 	call	0x350	; 0x350 <lcd_SendCmdSignals>
    DELAY_us(200);
     62e:	88 ec       	ldi	r24, 0xC8	; 200
     630:	90 e0       	ldi	r25, 0x00	; 0
     632:	0e 94 49 00 	call	0x92	; 0x92 <DELAY_us>
    lcd_SendHigherNibble(0x30);
     636:	80 e3       	ldi	r24, 0x30	; 48
     638:	0e 94 82 01 	call	0x304	; 0x304 <lcd_SendHigherNibble>
    lcd_SendCmdSignals();
     63c:	0e 94 a8 01 	call	0x350	; 0x350 <lcd_SendCmdSignals>
    DELAY_us(200);
     640:	88 ec       	ldi	r24, 0xC8	; 200
     642:	90 e0       	ldi	r25, 0x00	; 0
     644:	0e 94 49 00 	call	0x92	; 0x92 <DELAY_us>
    lcd_SendHigherNibble(0x20);
     648:	80 e2       	ldi	r24, 0x20	; 32
     64a:	0e 94 82 01 	call	0x304	; 0x304 <lcd_SendHigherNibble>
    lcd_SendCmdSignals();
     64e:	0e 94 a8 01 	call	0x350	; 0x350 <lcd_SendCmdSignals>
    DELAY_us(200);
     652:	88 ec       	ldi	r24, 0xC8	; 200
     654:	90 e0       	ldi	r25, 0x00	; 0
     656:	0e 94 49 00 	call	0x92	; 0x92 <DELAY_us>
        LCD_CmdWrite(CMD_LCD_EIGHT_BIT_MODE); // Initialize the LCD for 8-bit 5x7 matrix type
    }
    else if(LCDConfig.v_LcdMode_U8 == C_FourBitMode_U8)
    {
        lcd_Reset();
        LCD_CmdWrite(CMD_LCD_FOUR_BIT_MODE); // Initialize the LCD for 4-bit 5x7 matrix type 
     65a:	88 e2       	ldi	r24, 0x28	; 40
     65c:	0e 94 c0 02 	call	0x580	; 0x580 <LCD_CmdWrite>
    }

    LCD_CmdWrite(CMD_DISPLAY_ON_CURSOR_ON);     // Display ON cursor ON
     660:	8e e0       	ldi	r24, 0x0E	; 14
     662:	0e 94 c0 02 	call	0x580	; 0x580 <LCD_CmdWrite>
    LCD_Clear();                             // Clear the LCD and go to First line First Position
     666:	0c 94 e9 02 	jmp	0x5d2	; 0x5d2 <LCD_Clear>

0000066a <LCD_GoToNextLine>:
****************************************************************************************************/
void  LCD_GoToNextLine(void)
{
    /*Increment the current line number.
      In case it exceeds the limit, rool it back to first line */
    v_LcdTrackLineNum_U8++;
     66a:	80 91 97 00 	lds	r24, 0x0097
     66e:	8f 5f       	subi	r24, 0xFF	; 255
     670:	80 93 97 00 	sts	0x0097, r24
    v_LcdTrackCursorPos_U8 = 0x00;
     674:	10 92 96 00 	sts	0x0096, r1
    if(v_LcdTrackLineNum_U8 >= LCDConfig.v_MaxSupportedLines_U8)
     678:	90 91 88 00 	lds	r25, 0x0088
     67c:	89 17       	cp	r24, r25
     67e:	10 f0       	brcs	.+4      	; 0x684 <LCD_GoToNextLine+0x1a>
        v_LcdTrackLineNum_U8 = C_LcdLineZero;
     680:	10 92 97 00 	sts	0x0097, r1
    LCD_CmdWrite(ARR_LcdLineNumAddress_U8[v_LcdTrackLineNum_U8]);
     684:	e0 91 97 00 	lds	r30, 0x0097
     688:	f0 e0       	ldi	r31, 0x00	; 0
     68a:	e0 5a       	subi	r30, 0xA0	; 160
     68c:	ff 4f       	sbci	r31, 0xFF	; 255
     68e:	80 81       	ld	r24, Z
     690:	0c 94 c0 02 	jmp	0x580	; 0x580 <LCD_CmdWrite>

00000694 <LCD_DisplayChar>:
 * description  : This function sends a character to be displayed on LCD.
                  Any valid ascii value can be passed to display respective character

****************************************************************************************************/
void LCD_DisplayChar(char v_lcdData_u8)
{
     694:	cf 93       	push	r28
     696:	c8 2f       	mov	r28, r24
    if((v_LcdTrackCursorPos_U8>=LCDConfig.v_MaxSupportedChars_U8) || (v_lcdData_u8=='\n'))
     698:	90 91 96 00 	lds	r25, 0x0096
     69c:	80 91 89 00 	lds	r24, 0x0089
     6a0:	98 17       	cp	r25, r24
     6a2:	60 f4       	brcc	.+24     	; 0x6bc <LCD_DisplayChar+0x28>
     6a4:	ca 30       	cpi	r28, 0x0A	; 10
     6a6:	51 f0       	breq	.+20     	; 0x6bc <LCD_DisplayChar+0x28>

 * description : This functions is used to send a byte of data to LCD.                 .    
**************************************************************************************************/
static void lcd_DataWrite( uint8_t dataByte)
{
    lcd_BusyCheck();
     6a8:	0e 94 00 02 	call	0x400	; 0x400 <lcd_BusyCheck>
    if(LCDConfig.v_LcdMode_U8 == C_EightBitMode_U8)
     6ac:	80 91 8a 00 	lds	r24, 0x008A
     6b0:	88 30       	cpi	r24, 0x08	; 8
     6b2:	49 f4       	brne	.+18     	; 0x6c6 <LCD_DisplayChar+0x32>
     {
         lcd_SendLowerNibble(dataByte);
     6b4:	8c 2f       	mov	r24, r28
     6b6:	0e 94 c2 01 	call	0x384	; 0x384 <lcd_SendLowerNibble>
     6ba:	0c c0       	rjmp	.+24     	; 0x6d4 <LCD_DisplayChar+0x40>
{
    if((v_LcdTrackCursorPos_U8>=LCDConfig.v_MaxSupportedChars_U8) || (v_lcdData_u8=='\n'))
    {
        /* If the cursor has reached to end of line on page1
        OR NewLine command is issued Then Move the cursor to next line */
        LCD_GoToNextLine();
     6bc:	0e 94 35 03 	call	0x66a	; 0x66a <LCD_GoToNextLine>
    }
    if(v_lcdData_u8!='\n') /* Display the character if its not newLine Char */
     6c0:	ca 30       	cpi	r28, 0x0A	; 10
     6c2:	91 f0       	breq	.+36     	; 0x6e8 <LCD_DisplayChar+0x54>
     6c4:	f1 cf       	rjmp	.-30     	; 0x6a8 <LCD_DisplayChar+0x14>
     {
         lcd_SendLowerNibble(dataByte);
     }
     else
     {
         lcd_SendHigherNibble(dataByte);
     6c6:	8c 2f       	mov	r24, r28
     6c8:	0e 94 82 01 	call	0x304	; 0x304 <lcd_SendHigherNibble>
         lcd_SendDataSignals();
     6cc:	0e 94 e6 01 	call	0x3cc	; 0x3cc <lcd_SendDataSignals>
         dataByte = dataByte << 4;
     6d0:	c2 95       	swap	r28
     6d2:	c0 7f       	andi	r28, 0xF0	; 240
     }

     lcd_SendHigherNibble(dataByte);
     6d4:	8c 2f       	mov	r24, r28
     6d6:	0e 94 82 01 	call	0x304	; 0x304 <lcd_SendHigherNibble>
     lcd_SendDataSignals();
     6da:	0e 94 e6 01 	call	0x3cc	; 0x3cc <lcd_SendDataSignals>
    }
    if(v_lcdData_u8!='\n') /* Display the character if its not newLine Char */
    {

        lcd_DataWrite(v_lcdData_u8); /* Display the data and keep track of cursor */
        v_LcdTrackCursorPos_U8++;
     6de:	80 91 96 00 	lds	r24, 0x0096
     6e2:	8f 5f       	subi	r24, 0xFF	; 255
     6e4:	80 93 96 00 	sts	0x0096, r24
    }
}
     6e8:	cf 91       	pop	r28
     6ea:	08 95       	ret

000006ec <LCD_DisplayNumber.part.3>:
    Hex:        7.(16,0x12AB,3) then 3-digits ie. 2AB will be displayed
                8.(C_HEX_U8,0x12AB,6) then 6-digits ie. 0012AB will be displayed
                9.(C_HEX_U8,0x12AB,C_DisplayDefaultDigits_U8) then 12AB will be displayed.                
****************************************************************************************************/
#if ((Enable_LCD_DisplayNumber == 1) || (Enable_LCD_DisplayFloatNumber == 1) || (Enable_LCD_Printf==1))
void LCD_DisplayNumber(uint8_t v_numericSystem_u8, uint32_t v_number_u32, uint8_t v_numOfDigitsToDisplay_u8)
     6ec:	af 92       	push	r10
     6ee:	bf 92       	push	r11
     6f0:	cf 92       	push	r12
     6f2:	df 92       	push	r13
     6f4:	ef 92       	push	r14
     6f6:	ff 92       	push	r15
     6f8:	0f 93       	push	r16
     6fa:	1f 93       	push	r17
     6fc:	cf 93       	push	r28
     6fe:	df 93       	push	r29
     700:	1f 92       	push	r1
     702:	cd b7       	in	r28, 0x3d	; 61
     704:	de b7       	in	r29, 0x3e	; 62
     706:	6b 01       	movw	r12, r22
     708:	7c 01       	movw	r14, r24
    {
        while(v_numOfDigitsToDisplay_u8!=0)
        {
          /* Start Extracting the bits from the specified bit positions.
          Get the Acsii values of the bits and display */
          i = util_GetBitStatus(v_number_u32,(v_numOfDigitsToDisplay_u8-1));
     70a:	aa 24       	eor	r10, r10
     70c:	a3 94       	inc	r10
     70e:	b1 2c       	mov	r11, r1
{
    uint8_t i=0,a[10];
    
    if(C_BINARY_U8 == v_numericSystem_u8)
    {
        while(v_numOfDigitsToDisplay_u8!=0)
     710:	44 23       	and	r20, r20
     712:	e9 f0       	breq	.+58     	; 0x74e <LCD_DisplayNumber.part.3+0x62>
        {
          /* Start Extracting the bits from the specified bit positions.
          Get the Acsii values of the bits and display */
          i = util_GetBitStatus(v_number_u32,(v_numOfDigitsToDisplay_u8-1));
     714:	8f ef       	ldi	r24, 0xFF	; 255
     716:	84 0f       	add	r24, r20
     718:	85 01       	movw	r16, r10
     71a:	02 c0       	rjmp	.+4      	; 0x720 <LCD_DisplayNumber.part.3+0x34>
     71c:	00 0f       	add	r16, r16
     71e:	11 1f       	adc	r17, r17
     720:	8a 95       	dec	r24
     722:	e2 f7       	brpl	.-8      	; 0x71c <LCD_DisplayNumber.part.3+0x30>
     724:	01 2e       	mov	r0, r17
     726:	00 0c       	add	r0, r0
     728:	22 0b       	sbc	r18, r18
     72a:	33 0b       	sbc	r19, r19
     72c:	0c 21       	and	r16, r12
     72e:	1d 21       	and	r17, r13
     730:	2e 21       	and	r18, r14
     732:	3f 21       	and	r19, r15
     734:	81 e0       	ldi	r24, 0x01	; 1
     736:	01 2b       	or	r16, r17
     738:	02 2b       	or	r16, r18
     73a:	03 2b       	or	r16, r19
     73c:	09 f4       	brne	.+2      	; 0x740 <LCD_DisplayNumber.part.3+0x54>
     73e:	80 e0       	ldi	r24, 0x00	; 0
          LCD_DisplayChar(util_Dec2Ascii(i));
     740:	80 5d       	subi	r24, 0xD0	; 208
     742:	49 83       	std	Y+1, r20	; 0x01
     744:	0e 94 4a 03 	call	0x694	; 0x694 <LCD_DisplayChar>
          v_numOfDigitsToDisplay_u8--;
     748:	49 81       	ldd	r20, Y+1	; 0x01
     74a:	41 50       	subi	r20, 0x01	; 1
     74c:	e1 cf       	rjmp	.-62     	; 0x710 <LCD_DisplayNumber.part.3+0x24>
          /* Finally get the ascii values of the digits and display*/
          LCD_DisplayChar(util_Hex2Ascii(a[i-1]));
          i--;
        }
    }
}
     74e:	0f 90       	pop	r0
     750:	df 91       	pop	r29
     752:	cf 91       	pop	r28
     754:	1f 91       	pop	r17
     756:	0f 91       	pop	r16
     758:	ff 90       	pop	r15
     75a:	ef 90       	pop	r14
     75c:	df 90       	pop	r13
     75e:	cf 90       	pop	r12
     760:	bf 90       	pop	r11
     762:	af 90       	pop	r10
     764:	08 95       	ret

00000766 <LCD_DisplayString>:
                    and traverses till the end(NULL CHAR)and displays a char each time.

****************************************************************************************************/
#if (Enable_LCD_DisplayString==1)
void LCD_DisplayString(const char *ptr_stringPointer_u8)
{
     766:	cf 93       	push	r28
     768:	df 93       	push	r29
     76a:	ec 01       	movw	r28, r24
    while((*ptr_stringPointer_u8)!=0)
     76c:	89 91       	ld	r24, Y+
     76e:	88 23       	and	r24, r24
     770:	19 f0       	breq	.+6      	; 0x778 <LCD_DisplayString+0x12>
        LCD_DisplayChar(*ptr_stringPointer_u8++); // Loop through the string and display char by char
     772:	0e 94 4a 03 	call	0x694	; 0x694 <LCD_DisplayChar>
     776:	fa cf       	rjmp	.-12     	; 0x76c <LCD_DisplayString+0x6>
}
     778:	df 91       	pop	r29
     77a:	cf 91       	pop	r28
     77c:	08 95       	ret

0000077e <LCD_DisplayNumber>:
                8.(C_HEX_U8,0x12AB,6) then 6-digits ie. 0012AB will be displayed
                9.(C_HEX_U8,0x12AB,C_DisplayDefaultDigits_U8) then 12AB will be displayed.                
****************************************************************************************************/
#if ((Enable_LCD_DisplayNumber == 1) || (Enable_LCD_DisplayFloatNumber == 1) || (Enable_LCD_Printf==1))
void LCD_DisplayNumber(uint8_t v_numericSystem_u8, uint32_t v_number_u32, uint8_t v_numOfDigitsToDisplay_u8)
{
     77e:	4f 92       	push	r4
     780:	5f 92       	push	r5
     782:	6f 92       	push	r6
     784:	7f 92       	push	r7
     786:	bf 92       	push	r11
     788:	cf 92       	push	r12
     78a:	df 92       	push	r13
     78c:	ef 92       	push	r14
     78e:	ff 92       	push	r15
     790:	0f 93       	push	r16
     792:	1f 93       	push	r17
     794:	cf 93       	push	r28
     796:	df 93       	push	r29
     798:	cd b7       	in	r28, 0x3d	; 61
     79a:	de b7       	in	r29, 0x3e	; 62
     79c:	2a 97       	sbiw	r28, 0x0a	; 10
     79e:	0f b6       	in	r0, 0x3f	; 63
     7a0:	f8 94       	cli
     7a2:	de bf       	out	0x3e, r29	; 62
     7a4:	0f be       	out	0x3f, r0	; 63
     7a6:	cd bf       	out	0x3d, r28	; 61
     7a8:	b8 2e       	mov	r11, r24
     7aa:	cb 01       	movw	r24, r22
     7ac:	ba 01       	movw	r22, r20
     7ae:	02 2f       	mov	r16, r18
    uint8_t i=0,a[10];
    
    if(C_BINARY_U8 == v_numericSystem_u8)
     7b0:	22 e0       	ldi	r18, 0x02	; 2
     7b2:	b2 12       	cpse	r11, r18
     7b4:	16 c0       	rjmp	.+44     	; 0x7e2 <LCD_DisplayNumber+0x64>
     7b6:	40 2f       	mov	r20, r16
          /* Finally get the ascii values of the digits and display*/
          LCD_DisplayChar(util_Hex2Ascii(a[i-1]));
          i--;
        }
    }
}
     7b8:	2a 96       	adiw	r28, 0x0a	; 10
     7ba:	0f b6       	in	r0, 0x3f	; 63
     7bc:	f8 94       	cli
     7be:	de bf       	out	0x3e, r29	; 62
     7c0:	0f be       	out	0x3f, r0	; 63
     7c2:	cd bf       	out	0x3d, r28	; 61
     7c4:	df 91       	pop	r29
     7c6:	cf 91       	pop	r28
     7c8:	1f 91       	pop	r17
     7ca:	0f 91       	pop	r16
     7cc:	ff 90       	pop	r15
     7ce:	ef 90       	pop	r14
     7d0:	df 90       	pop	r13
     7d2:	cf 90       	pop	r12
     7d4:	bf 90       	pop	r11
     7d6:	7f 90       	pop	r7
     7d8:	6f 90       	pop	r6
     7da:	5f 90       	pop	r5
     7dc:	4f 90       	pop	r4
     7de:	0c 94 76 03 	jmp	0x6ec	; 0x6ec <LCD_DisplayNumber.part.3>
          i = util_GetBitStatus(v_number_u32,(v_numOfDigitsToDisplay_u8-1));
          LCD_DisplayChar(util_Dec2Ascii(i));
          v_numOfDigitsToDisplay_u8--;
        }        
    }    
    else if(v_number_u32==0)
     7e2:	61 15       	cp	r22, r1
     7e4:	71 05       	cpc	r23, r1
     7e6:	81 05       	cpc	r24, r1
     7e8:	91 05       	cpc	r25, r1
     7ea:	49 f0       	breq	.+18     	; 0x7fe <LCD_DisplayNumber+0x80>
     7ec:	fe 01       	movw	r30, r28
     7ee:	31 96       	adiw	r30, 0x01	; 1
     7f0:	6f 01       	movw	r12, r30
     7f2:	7f 01       	movw	r14, r30
                First get the remainder and divide the number by TypeOfNum(10-Dec, 16-Hex) each time.
                
                example for Decimal number: 
                If v_number_u32 = 123 then extracted remainder will be 3 and number will be 12.
                The process continues till it becomes zero or max digits reached*/
                a[i]=util_GetMod32(v_number_u32,v_numericSystem_u8);
     7f4:	4b 2c       	mov	r4, r11
     7f6:	51 2c       	mov	r5, r1
     7f8:	61 2c       	mov	r6, r1
     7fa:	71 2c       	mov	r7, r1
     7fc:	2a c0       	rjmp	.+84     	; 0x852 <LCD_DisplayNumber+0xd4>
    else if(v_number_u32==0)
    {
        /* If the number is zero then display Specified number of zeros*/
        /*TODO: Display single zero or multiple. Currently single zero is displayed*/
        //for(i=0;((i<v_numOfDigitsToDisplay_u8) && (i<C_MaxDigitsToDisplay_U8));i++)
            LCD_DisplayChar('0');
     7fe:	80 e3       	ldi	r24, 0x30	; 48
          /* Finally get the ascii values of the digits and display*/
          LCD_DisplayChar(util_Hex2Ascii(a[i-1]));
          i--;
        }
    }
}
     800:	2a 96       	adiw	r28, 0x0a	; 10
     802:	0f b6       	in	r0, 0x3f	; 63
     804:	f8 94       	cli
     806:	de bf       	out	0x3e, r29	; 62
     808:	0f be       	out	0x3f, r0	; 63
     80a:	cd bf       	out	0x3d, r28	; 61
     80c:	df 91       	pop	r29
     80e:	cf 91       	pop	r28
     810:	1f 91       	pop	r17
     812:	0f 91       	pop	r16
     814:	ff 90       	pop	r15
     816:	ef 90       	pop	r14
     818:	df 90       	pop	r13
     81a:	cf 90       	pop	r12
     81c:	bf 90       	pop	r11
     81e:	7f 90       	pop	r7
     820:	6f 90       	pop	r6
     822:	5f 90       	pop	r5
     824:	4f 90       	pop	r4
    else if(v_number_u32==0)
    {
        /* If the number is zero then display Specified number of zeros*/
        /*TODO: Display single zero or multiple. Currently single zero is displayed*/
        //for(i=0;((i<v_numOfDigitsToDisplay_u8) && (i<C_MaxDigitsToDisplay_U8));i++)
            LCD_DisplayChar('0');
     826:	0c 94 4a 03 	jmp	0x694	; 0x694 <LCD_DisplayChar>
    {
        for(i=0;i<v_numOfDigitsToDisplay_u8;i++)
        {
            /* Continue extracting the digits from right side
               till the Specified v_numOfDigitsToDisplay_u8 */
            if(v_number_u32!=0)
     82a:	61 15       	cp	r22, r1
     82c:	71 05       	cpc	r23, r1
     82e:	81 05       	cpc	r24, r1
     830:	91 05       	cpc	r25, r1
     832:	a1 f0       	breq	.+40     	; 0x85c <LCD_DisplayNumber+0xde>
                First get the remainder and divide the number by TypeOfNum(10-Dec, 16-Hex) each time.
                
                example for Decimal number: 
                If v_number_u32 = 123 then extracted remainder will be 3 and number will be 12.
                The process continues till it becomes zero or max digits reached*/
                a[i]=util_GetMod32(v_number_u32,v_numericSystem_u8);
     834:	16 2f       	mov	r17, r22
     836:	a3 01       	movw	r20, r6
     838:	92 01       	movw	r18, r4
     83a:	0e 94 34 08 	call	0x1068	; 0x1068 <__udivmodsi4>
     83e:	ca 01       	movw	r24, r20
     840:	b9 01       	movw	r22, r18
     842:	b2 9e       	mul	r11, r18
     844:	10 19       	sub	r17, r0
     846:	11 24       	eor	r1, r1
     848:	f7 01       	movw	r30, r14
     84a:	10 83       	st	Z, r17
     84c:	ff ef       	ldi	r31, 0xFF	; 255
     84e:	ef 1a       	sub	r14, r31
     850:	ff 0a       	sbc	r15, r31
     852:	1e 2d       	mov	r17, r14
     854:	1c 19       	sub	r17, r12
        //for(i=0;((i<v_numOfDigitsToDisplay_u8) && (i<C_MaxDigitsToDisplay_U8));i++)
            LCD_DisplayChar('0');
    }
    else
    {
        for(i=0;i<v_numOfDigitsToDisplay_u8;i++)
     856:	10 17       	cp	r17, r16
     858:	40 f3       	brcs	.-48     	; 0x82a <LCD_DisplayNumber+0xac>
     85a:	0f c0       	rjmp	.+30     	; 0x87a <__stack+0x1b>
                If v_number_u32 = 123 then extracted remainder will be 3 and number will be 12.
                The process continues till it becomes zero or max digits reached*/
                a[i]=util_GetMod32(v_number_u32,v_numericSystem_u8);
                v_number_u32=v_number_u32/v_numericSystem_u8;
            }
            else if( (v_numOfDigitsToDisplay_u8 == C_DisplayDefaultDigits_U8) ||
     85c:	0b 30       	cpi	r16, 0x0B	; 11
     85e:	68 f4       	brcc	.+26     	; 0x87a <__stack+0x1b>
            else
            {
                /* In case user expects more digits to be displayed than the actual digits in number,
                  then update the remaining digits with zero.
               Ex: v_num_u32 is 123 and user wants five digits then 00123 has to be displayed */
                a[i]=0;
     860:	f7 01       	movw	r30, r14
     862:	10 82       	st	Z, r1
     864:	f3 cf       	rjmp	.-26     	; 0x84c <LCD_DisplayNumber+0xce>
        }
        
         while(i!=0)
        { 
          /* Finally get the ascii values of the digits and display*/
          LCD_DisplayChar(util_Hex2Ascii(a[i-1]));
     866:	fe 01       	movw	r30, r28
     868:	e1 0f       	add	r30, r17
     86a:	f1 1d       	adc	r31, r1
     86c:	80 81       	ld	r24, Z
     86e:	8a 30       	cpi	r24, 0x0A	; 10
     870:	38 f0       	brcs	.+14     	; 0x880 <__stack+0x21>
     872:	89 5c       	subi	r24, 0xC9	; 201
     874:	0e 94 4a 03 	call	0x694	; 0x694 <LCD_DisplayChar>
          i--;
     878:	11 50       	subi	r17, 0x01	; 1
               Ex: v_num_u32 is 123 and user wants five digits then 00123 has to be displayed */
                a[i]=0;
            }
        }
        
         while(i!=0)
     87a:	11 11       	cpse	r17, r1
     87c:	f4 cf       	rjmp	.-24     	; 0x866 <__stack+0x7>
     87e:	02 c0       	rjmp	.+4      	; 0x884 <__stack+0x25>
        { 
          /* Finally get the ascii values of the digits and display*/
          LCD_DisplayChar(util_Hex2Ascii(a[i-1]));
     880:	80 5d       	subi	r24, 0xD0	; 208
     882:	f8 cf       	rjmp	.-16     	; 0x874 <__stack+0x15>
          i--;
        }
    }
}
     884:	2a 96       	adiw	r28, 0x0a	; 10
     886:	0f b6       	in	r0, 0x3f	; 63
     888:	f8 94       	cli
     88a:	de bf       	out	0x3e, r29	; 62
     88c:	0f be       	out	0x3f, r0	; 63
     88e:	cd bf       	out	0x3d, r28	; 61
     890:	df 91       	pop	r29
     892:	cf 91       	pop	r28
     894:	1f 91       	pop	r17
     896:	0f 91       	pop	r16
     898:	ff 90       	pop	r15
     89a:	ef 90       	pop	r14
     89c:	df 90       	pop	r13
     89e:	cf 90       	pop	r12
     8a0:	bf 90       	pop	r11
     8a2:	7f 90       	pop	r7
     8a4:	6f 90       	pop	r6
     8a6:	5f 90       	pop	r5
     8a8:	4f 90       	pop	r4
     8aa:	08 95       	ret

000008ac <LCD_DisplayFloatNumber>:
    Note: Float will be disabled by default as it takes huge controller resources
         It can be enabled by changing value of Enable_LCD_DisplayFloatNumber to 1 in lcd.h
***************************************************************************************************/
#if (Enable_LCD_DisplayFloatNumber == 1)  
void LCD_DisplayFloatNumber(double v_floatNum_f32)
{
     8ac:	8f 92       	push	r8
     8ae:	9f 92       	push	r9
     8b0:	af 92       	push	r10
     8b2:	bf 92       	push	r11
     8b4:	cf 92       	push	r12
     8b6:	df 92       	push	r13
     8b8:	ef 92       	push	r14
     8ba:	ff 92       	push	r15
     8bc:	6b 01       	movw	r12, r22
     8be:	7c 01       	movw	r14, r24
      1.Type cast the number to int to get the integer part.
      2.Display the extracted integer part followed by a decimal point(.)
      3.Later the integer part is made zero by subtracting with the extracted integer value.
      4.Finally the fractional part is multiplied by 100000 to support 6-digit precision */

    v_decNumber_u32 = (uint32_t) v_floatNum_f32;
     8c0:	0e 94 0a 07 	call	0xe14	; 0xe14 <__fixunssfsi>
     8c4:	4b 01       	movw	r8, r22
     8c6:	5c 01       	movw	r10, r24
    LCD_DisplayNumber(C_DECIMAL_U8,v_decNumber_u32,C_DisplayDefaultDigits_U8);
     8c8:	2f ef       	ldi	r18, 0xFF	; 255
     8ca:	ab 01       	movw	r20, r22
     8cc:	bc 01       	movw	r22, r24
     8ce:	8a e0       	ldi	r24, 0x0A	; 10
     8d0:	0e 94 bf 03 	call	0x77e	; 0x77e <LCD_DisplayNumber>

    LCD_DisplayChar('.');
     8d4:	8e e2       	ldi	r24, 0x2E	; 46
     8d6:	0e 94 4a 03 	call	0x694	; 0x694 <LCD_DisplayChar>

    v_floatNum_f32 = v_floatNum_f32 - v_decNumber_u32;
     8da:	c5 01       	movw	r24, r10
     8dc:	b4 01       	movw	r22, r8
     8de:	0e 94 39 07 	call	0xe72	; 0xe72 <__floatunsisf>
     8e2:	9b 01       	movw	r18, r22
     8e4:	ac 01       	movw	r20, r24
     8e6:	c7 01       	movw	r24, r14
     8e8:	b6 01       	movw	r22, r12
     8ea:	0e 94 9d 06 	call	0xd3a	; 0xd3a <__subsf3>
    v_decNumber_u32 = v_floatNum_f32 * 1000000;
     8ee:	20 e0       	ldi	r18, 0x00	; 0
     8f0:	34 e2       	ldi	r19, 0x24	; 36
     8f2:	44 e7       	ldi	r20, 0x74	; 116
     8f4:	59 e4       	ldi	r21, 0x49	; 73
     8f6:	0e 94 c7 07 	call	0xf8e	; 0xf8e <__mulsf3>
     8fa:	0e 94 0a 07 	call	0xe14	; 0xe14 <__fixunssfsi>
     8fe:	ab 01       	movw	r20, r22
     900:	bc 01       	movw	r22, r24
    LCD_DisplayNumber(C_DECIMAL_U8,v_decNumber_u32,C_DisplayDefaultDigits_U8);
     902:	2f ef       	ldi	r18, 0xFF	; 255
     904:	8a e0       	ldi	r24, 0x0A	; 10
}
     906:	ff 90       	pop	r15
     908:	ef 90       	pop	r14
     90a:	df 90       	pop	r13
     90c:	cf 90       	pop	r12
     90e:	bf 90       	pop	r11
     910:	af 90       	pop	r10
     912:	9f 90       	pop	r9
     914:	8f 90       	pop	r8

    LCD_DisplayChar('.');

    v_floatNum_f32 = v_floatNum_f32 - v_decNumber_u32;
    v_decNumber_u32 = v_floatNum_f32 * 1000000;
    LCD_DisplayNumber(C_DECIMAL_U8,v_decNumber_u32,C_DisplayDefaultDigits_U8);
     916:	0c 94 bf 03 	jmp	0x77e	; 0x77e <LCD_DisplayNumber>

0000091a <LCD_Printf>:
        uint8_t v_Num_u8;
        LCD_Printf("num1:%u",(uint16_t)v_Num_u8); 
**************************************************************************************************/
#if ( Enable_LCD_Printf   == 1 ) 
void LCD_Printf(const char *argList, ...)
{
     91a:	cf 92       	push	r12
     91c:	df 92       	push	r13
     91e:	ef 92       	push	r14
     920:	ff 92       	push	r15
     922:	0f 93       	push	r16
     924:	1f 93       	push	r17
     926:	cf 93       	push	r28
     928:	df 93       	push	r29
     92a:	00 d0       	rcall	.+0      	; 0x92c <LCD_Printf+0x12>
     92c:	00 d0       	rcall	.+0      	; 0x92e <LCD_Printf+0x14>
     92e:	1f 92       	push	r1
     930:	cd b7       	in	r28, 0x3d	; 61
     932:	de b7       	in	r29, 0x3e	; 62
     934:	fe 01       	movw	r30, r28
     936:	70 96       	adiw	r30, 0x10	; 16
     938:	c1 90       	ld	r12, Z+
     93a:	d1 90       	ld	r13, Z+
    uint8_t v_numOfDigitsToDisp_u8;
#if (Enable_LCD_DisplayFloatNumber == 1)  
    double v_floatNum_f32;
#endif

    va_start(argp, argList);
     93c:	8f 01       	movw	r16, r30

    /* Loop through the list to extract all the input arguments */
    for(ptr = argList; *ptr != '\0'; ptr++)
     93e:	f6 01       	movw	r30, r12
     940:	80 81       	ld	r24, Z
     942:	88 23       	and	r24, r24
     944:	09 f4       	brne	.+2      	; 0x948 <LCD_Printf+0x2e>
     946:	2c c1       	rjmp	.+600    	; 0xba0 <LCD_Printf+0x286>
    {

        ch= *ptr;
        if(ch == '%')         /*Check for '%' as there will be format specifier after it */
     948:	85 32       	cpi	r24, 0x25	; 37
     94a:	09 f0       	breq	.+2      	; 0x94e <LCD_Printf+0x34>
     94c:	0e c1       	rjmp	.+540    	; 0xb6a <LCD_Printf+0x250>
        {
            ptr++;
     94e:	76 01       	movw	r14, r12
     950:	8f ef       	ldi	r24, 0xFF	; 255
     952:	e8 1a       	sub	r14, r24
     954:	f8 0a       	sbc	r15, r24
            ch = *ptr;
     956:	f6 01       	movw	r30, r12
     958:	81 81       	ldd	r24, Z+1	; 0x01
           if((ch>=0x30) && (ch<=0x39))
     95a:	90 ed       	ldi	r25, 0xD0	; 208
     95c:	98 0f       	add	r25, r24
     95e:	9a 30       	cpi	r25, 0x0A	; 10
     960:	08 f0       	brcs	.+2      	; 0x964 <LCD_Printf+0x4a>
     962:	b7 c0       	rjmp	.+366    	; 0xad2 <LCD_Printf+0x1b8>
     964:	20 e0       	ldi	r18, 0x00	; 0
            {
               v_numOfDigitsToDisp_u8 = 0;
               while((ch>=0x30) && (ch<=0x39))
     966:	90 ed       	ldi	r25, 0xD0	; 208
     968:	98 0f       	add	r25, r24
     96a:	9a 30       	cpi	r25, 0x0A	; 10
     96c:	58 f4       	brcc	.+22     	; 0x984 <LCD_Printf+0x6a>
                {
                   v_numOfDigitsToDisp_u8 = (v_numOfDigitsToDisp_u8 * 10) + (ch-0x30);
     96e:	fa e0       	ldi	r31, 0x0A	; 10
     970:	2f 9f       	mul	r18, r31
     972:	90 0d       	add	r25, r0
     974:	11 24       	eor	r1, r1
     976:	29 2f       	mov	r18, r25
                   ptr++;
     978:	8f ef       	ldi	r24, 0xFF	; 255
     97a:	e8 1a       	sub	r14, r24
     97c:	f8 0a       	sbc	r15, r24
                   ch = *ptr;
     97e:	f7 01       	movw	r30, r14
     980:	80 81       	ld	r24, Z
     982:	f1 cf       	rjmp	.-30     	; 0x966 <LCD_Printf+0x4c>
            {
              v_numOfDigitsToDisp_u8 = C_MaxDigitsToDisplayUsingPrintf_U8;
            }                


            switch(ch)       /* Decode the type of the argument */
     984:	88 35       	cpi	r24, 0x58	; 88
     986:	09 f4       	brne	.+2      	; 0x98a <LCD_Printf+0x70>
     988:	a8 c0       	rjmp	.+336    	; 0xada <LCD_Printf+0x1c0>
     98a:	70 f4       	brcc	.+28     	; 0x9a8 <LCD_Printf+0x8e>
     98c:	84 34       	cpi	r24, 0x44	; 68
     98e:	09 f4       	brne	.+2      	; 0x992 <LCD_Printf+0x78>
     990:	50 c0       	rjmp	.+160    	; 0xa32 <LCD_Printf+0x118>
     992:	18 f4       	brcc	.+6      	; 0x99a <LCD_Printf+0x80>
     994:	82 34       	cpi	r24, 0x42	; 66
     996:	d9 f4       	brne	.+54     	; 0x9ce <LCD_Printf+0xb4>
     998:	bd c0       	rjmp	.+378    	; 0xb14 <LCD_Printf+0x1fa>
     99a:	83 35       	cpi	r24, 0x53	; 83
     99c:	09 f4       	brne	.+2      	; 0x9a0 <LCD_Printf+0x86>
     99e:	da c0       	rjmp	.+436    	; 0xb54 <LCD_Printf+0x23a>
     9a0:	85 35       	cpi	r24, 0x55	; 85
     9a2:	09 f4       	brne	.+2      	; 0x9a6 <LCD_Printf+0x8c>
     9a4:	7d c0       	rjmp	.+250    	; 0xaa0 <LCD_Printf+0x186>
     9a6:	c6 c0       	rjmp	.+396    	; 0xb34 <LCD_Printf+0x21a>
     9a8:	86 36       	cpi	r24, 0x66	; 102
     9aa:	09 f4       	brne	.+2      	; 0x9ae <LCD_Printf+0x94>
     9ac:	c5 c0       	rjmp	.+394    	; 0xb38 <LCD_Printf+0x21e>
     9ae:	40 f4       	brcc	.+16     	; 0x9c0 <LCD_Printf+0xa6>
     9b0:	83 36       	cpi	r24, 0x63	; 99
     9b2:	81 f0       	breq	.+32     	; 0x9d4 <LCD_Printf+0xba>
     9b4:	84 36       	cpi	r24, 0x64	; 100
     9b6:	21 f1       	breq	.+72     	; 0xa00 <LCD_Printf+0xe6>
     9b8:	82 36       	cpi	r24, 0x62	; 98
     9ba:	09 f0       	breq	.+2      	; 0x9be <LCD_Printf+0xa4>
     9bc:	d9 c0       	rjmp	.+434    	; 0xb70 <LCD_Printf+0x256>
     9be:	9d c0       	rjmp	.+314    	; 0xafa <LCD_Printf+0x1e0>
     9c0:	85 37       	cpi	r24, 0x75	; 117
     9c2:	09 f4       	brne	.+2      	; 0x9c6 <LCD_Printf+0xac>
     9c4:	59 c0       	rjmp	.+178    	; 0xa78 <LCD_Printf+0x15e>
     9c6:	88 37       	cpi	r24, 0x78	; 120
     9c8:	09 f4       	brne	.+2      	; 0x9cc <LCD_Printf+0xb2>
     9ca:	79 c0       	rjmp	.+242    	; 0xabe <LCD_Printf+0x1a4>
     9cc:	c1 c0       	rjmp	.+386    	; 0xb50 <LCD_Printf+0x236>
     9ce:	83 34       	cpi	r24, 0x43	; 67
     9d0:	08 f4       	brcc	.+2      	; 0x9d4 <LCD_Printf+0xba>
     9d2:	e0 c0       	rjmp	.+448    	; 0xb94 <LCD_Printf+0x27a>
            {
            case 'C':
            case 'c':     /* Argument type is of char, hence read char data from the argp */
                ch = va_arg(argp, int);
     9d4:	68 01       	movw	r12, r16
     9d6:	f2 e0       	ldi	r31, 0x02	; 2
     9d8:	cf 0e       	add	r12, r31
     9da:	d1 1c       	adc	r13, r1
                LCD_DisplayChar(ch);
     9dc:	f8 01       	movw	r30, r16
     9de:	80 81       	ld	r24, Z
     9e0:	0e 94 4a 03 	call	0x694	; 0x694 <LCD_DisplayChar>
     9e4:	c0 c0       	rjmp	.+384    	; 0xb66 <LCD_Printf+0x24c>
            {
              v_numOfDigitsToDisp_u8 = C_MaxDigitsToDisplayUsingPrintf_U8;
            }                


            switch(ch)       /* Decode the type of the argument */
     9e6:	89 35       	cpi	r24, 0x59	; 89
     9e8:	08 f1       	brcs	.+66     	; 0xa2c <LCD_Printf+0x112>
     9ea:	86 36       	cpi	r24, 0x66	; 102
     9ec:	09 f4       	brne	.+2      	; 0x9f0 <LCD_Printf+0xd6>
     9ee:	a4 c0       	rjmp	.+328    	; 0xb38 <LCD_Printf+0x21e>
     9f0:	08 f0       	brcs	.+2      	; 0x9f4 <LCD_Printf+0xda>
     9f2:	3f c0       	rjmp	.+126    	; 0xa72 <LCD_Printf+0x158>
     9f4:	83 36       	cpi	r24, 0x63	; 99
     9f6:	71 f3       	breq	.-36     	; 0x9d4 <LCD_Printf+0xba>
     9f8:	84 36       	cpi	r24, 0x64	; 100
     9fa:	09 f0       	breq	.+2      	; 0x9fe <LCD_Printf+0xe4>
     9fc:	7b c0       	rjmp	.+246    	; 0xaf4 <LCD_Printf+0x1da>
                   ch = *ptr;
                }
            }
            else
            {
              v_numOfDigitsToDisp_u8 = C_MaxDigitsToDisplayUsingPrintf_U8;
     9fe:	2f ef       	ldi	r18, 0xFF	; 255
                ch = va_arg(argp, int);
                LCD_DisplayChar(ch);
                break;

            case 'd':    /* Argument type is of signed integer, hence read 16bit data from the argp */
                v_num_s16 = va_arg(argp, int);
     a00:	68 01       	movw	r12, r16
     a02:	f2 e0       	ldi	r31, 0x02	; 2
     a04:	cf 0e       	add	r12, r31
     a06:	d1 1c       	adc	r13, r1
     a08:	f8 01       	movw	r30, r16
     a0a:	00 81       	ld	r16, Z
     a0c:	11 81       	ldd	r17, Z+1	; 0x01
                if(v_num_s16<0)
     a0e:	17 ff       	sbrs	r17, 7
     a10:	08 c0       	rjmp	.+16     	; 0xa22 <LCD_Printf+0x108>
                 { /* If the number is -ve then display the 2's complement along with '-' sign */ 
                   v_num_s16 = -v_num_s16;
     a12:	11 95       	neg	r17
     a14:	01 95       	neg	r16
     a16:	11 09       	sbc	r17, r1
                   LCD_DisplayChar('-');
     a18:	8d e2       	ldi	r24, 0x2D	; 45
     a1a:	2d 83       	std	Y+5, r18	; 0x05
     a1c:	0e 94 4a 03 	call	0x694	; 0x694 <LCD_DisplayChar>
     a20:	2d 81       	ldd	r18, Y+5	; 0x05
                 }
                LCD_DisplayNumber(C_DECIMAL_U8,v_num_s16,v_numOfDigitsToDisp_u8);
     a22:	a8 01       	movw	r20, r16
     a24:	11 0f       	add	r17, r17
     a26:	66 0b       	sbc	r22, r22
     a28:	77 0b       	sbc	r23, r23
     a2a:	43 c0       	rjmp	.+134    	; 0xab2 <LCD_Printf+0x198>
            {
              v_numOfDigitsToDisp_u8 = C_MaxDigitsToDisplayUsingPrintf_U8;
            }                


            switch(ch)       /* Decode the type of the argument */
     a2c:	84 34       	cpi	r24, 0x44	; 68
     a2e:	71 f5       	brne	.+92     	; 0xa8c <LCD_Printf+0x172>
                   ch = *ptr;
                }
            }
            else
            {
              v_numOfDigitsToDisp_u8 = C_MaxDigitsToDisplayUsingPrintf_U8;
     a30:	2f ef       	ldi	r18, 0xFF	; 255
                 }
                LCD_DisplayNumber(C_DECIMAL_U8,v_num_s16,v_numOfDigitsToDisp_u8);
                break;
                
            case 'D':    /* Argument type is of integer, hence read 16bit data from the argp */
                v_num_s32 = va_arg(argp, sint32_t);
     a32:	68 01       	movw	r12, r16
     a34:	f4 e0       	ldi	r31, 0x04	; 4
     a36:	cf 0e       	add	r12, r31
     a38:	d1 1c       	adc	r13, r1
     a3a:	f8 01       	movw	r30, r16
     a3c:	40 81       	ld	r20, Z
     a3e:	51 81       	ldd	r21, Z+1	; 0x01
     a40:	62 81       	ldd	r22, Z+2	; 0x02
     a42:	73 81       	ldd	r23, Z+3	; 0x03
                if(v_num_s32<0)
     a44:	77 ff       	sbrs	r23, 7
     a46:	35 c0       	rjmp	.+106    	; 0xab2 <LCD_Printf+0x198>
                 { /* If the number is -ve then display the 2's complement along with '-' sign */
                   v_num_s32 = -v_num_s32;
     a48:	70 95       	com	r23
     a4a:	60 95       	com	r22
     a4c:	50 95       	com	r21
     a4e:	41 95       	neg	r20
     a50:	5f 4f       	sbci	r21, 0xFF	; 255
     a52:	6f 4f       	sbci	r22, 0xFF	; 255
     a54:	7f 4f       	sbci	r23, 0xFF	; 255
                   LCD_DisplayChar('-');
     a56:	8d e2       	ldi	r24, 0x2D	; 45
     a58:	2d 83       	std	Y+5, r18	; 0x05
     a5a:	49 83       	std	Y+1, r20	; 0x01
     a5c:	5a 83       	std	Y+2, r21	; 0x02
     a5e:	6b 83       	std	Y+3, r22	; 0x03
     a60:	7c 83       	std	Y+4, r23	; 0x04
     a62:	0e 94 4a 03 	call	0x694	; 0x694 <LCD_DisplayChar>
     a66:	7c 81       	ldd	r23, Y+4	; 0x04
     a68:	6b 81       	ldd	r22, Y+3	; 0x03
     a6a:	5a 81       	ldd	r21, Y+2	; 0x02
     a6c:	49 81       	ldd	r20, Y+1	; 0x01
     a6e:	2d 81       	ldd	r18, Y+5	; 0x05
     a70:	20 c0       	rjmp	.+64     	; 0xab2 <LCD_Printf+0x198>
            {
              v_numOfDigitsToDisp_u8 = C_MaxDigitsToDisplayUsingPrintf_U8;
            }                


            switch(ch)       /* Decode the type of the argument */
     a72:	85 37       	cpi	r24, 0x75	; 117
     a74:	01 f5       	brne	.+64     	; 0xab6 <LCD_Printf+0x19c>
                   ch = *ptr;
                }
            }
            else
            {
              v_numOfDigitsToDisp_u8 = C_MaxDigitsToDisplayUsingPrintf_U8;
     a76:	2f ef       	ldi	r18, 0xFF	; 255
                 }
                LCD_DisplayNumber(C_DECIMAL_U8,v_num_s32,v_numOfDigitsToDisp_u8);              
                break;    

            case 'u':    /* Argument type is of unsigned integer, hence read 16bit unsigned data */
                v_num_u16 = va_arg(argp, int);
     a78:	68 01       	movw	r12, r16
     a7a:	f2 e0       	ldi	r31, 0x02	; 2
     a7c:	cf 0e       	add	r12, r31
     a7e:	d1 1c       	adc	r13, r1
                LCD_DisplayNumber(C_DECIMAL_U8,v_num_u16,v_numOfDigitsToDisp_u8);
     a80:	f8 01       	movw	r30, r16
     a82:	40 81       	ld	r20, Z
     a84:	51 81       	ldd	r21, Z+1	; 0x01
     a86:	60 e0       	ldi	r22, 0x00	; 0
     a88:	70 e0       	ldi	r23, 0x00	; 0
     a8a:	13 c0       	rjmp	.+38     	; 0xab2 <LCD_Printf+0x198>
            {
              v_numOfDigitsToDisp_u8 = C_MaxDigitsToDisplayUsingPrintf_U8;
            }                


            switch(ch)       /* Decode the type of the argument */
     a8c:	85 34       	cpi	r24, 0x45	; 69
     a8e:	08 f4       	brcc	.+2      	; 0xa92 <LCD_Printf+0x178>
     a90:	74 c0       	rjmp	.+232    	; 0xb7a <LCD_Printf+0x260>
     a92:	83 35       	cpi	r24, 0x53	; 83
     a94:	09 f4       	brne	.+2      	; 0xa98 <LCD_Printf+0x17e>
     a96:	5e c0       	rjmp	.+188    	; 0xb54 <LCD_Printf+0x23a>
     a98:	85 35       	cpi	r24, 0x55	; 85
     a9a:	09 f0       	breq	.+2      	; 0xa9e <LCD_Printf+0x184>
     a9c:	4b c0       	rjmp	.+150    	; 0xb34 <LCD_Printf+0x21a>
                   ch = *ptr;
                }
            }
            else
            {
              v_numOfDigitsToDisp_u8 = C_MaxDigitsToDisplayUsingPrintf_U8;
     a9e:	2f ef       	ldi	r18, 0xFF	; 255
                v_num_u16 = va_arg(argp, int);
                LCD_DisplayNumber(C_DECIMAL_U8,v_num_u16,v_numOfDigitsToDisp_u8);
                break;
            
            case 'U':    /* Argument type is of integer, hence read 32bit unsigend data */
                v_num_u32 = va_arg(argp, uint32_t);
     aa0:	68 01       	movw	r12, r16
     aa2:	f4 e0       	ldi	r31, 0x04	; 4
     aa4:	cf 0e       	add	r12, r31
     aa6:	d1 1c       	adc	r13, r1
                LCD_DisplayNumber(C_DECIMAL_U8,v_num_u32,v_numOfDigitsToDisp_u8);               
     aa8:	f8 01       	movw	r30, r16
     aaa:	40 81       	ld	r20, Z
     aac:	51 81       	ldd	r21, Z+1	; 0x01
     aae:	62 81       	ldd	r22, Z+2	; 0x02
     ab0:	73 81       	ldd	r23, Z+3	; 0x03
     ab2:	8a e0       	ldi	r24, 0x0A	; 10
     ab4:	1c c0       	rjmp	.+56     	; 0xaee <LCD_Printf+0x1d4>
            {
              v_numOfDigitsToDisp_u8 = C_MaxDigitsToDisplayUsingPrintf_U8;
            }                


            switch(ch)       /* Decode the type of the argument */
     ab6:	88 37       	cpi	r24, 0x78	; 120
     ab8:	09 f0       	breq	.+2      	; 0xabc <LCD_Printf+0x1a2>
     aba:	4a c0       	rjmp	.+148    	; 0xb50 <LCD_Printf+0x236>
                   ch = *ptr;
                }
            }
            else
            {
              v_numOfDigitsToDisp_u8 = C_MaxDigitsToDisplayUsingPrintf_U8;
     abc:	2f ef       	ldi	r18, 0xFF	; 255
                v_num_u32 = va_arg(argp, uint32_t);
                LCD_DisplayNumber(C_DECIMAL_U8,v_num_u32,v_numOfDigitsToDisp_u8);               
                break;            

            case 'x':  /* Argument type is of hex, hence hexadecimal data from the argp */
                v_num_u16 = va_arg(argp, int);
     abe:	68 01       	movw	r12, r16
     ac0:	f2 e0       	ldi	r31, 0x02	; 2
     ac2:	cf 0e       	add	r12, r31
     ac4:	d1 1c       	adc	r13, r1
                LCD_DisplayNumber(C_HEX_U8,v_num_u16,v_numOfDigitsToDisp_u8);
     ac6:	f8 01       	movw	r30, r16
     ac8:	40 81       	ld	r20, Z
     aca:	51 81       	ldd	r21, Z+1	; 0x01
     acc:	60 e0       	ldi	r22, 0x00	; 0
     ace:	70 e0       	ldi	r23, 0x00	; 0
     ad0:	0d c0       	rjmp	.+26     	; 0xaec <LCD_Printf+0x1d2>
            {
              v_numOfDigitsToDisp_u8 = C_MaxDigitsToDisplayUsingPrintf_U8;
            }                


            switch(ch)       /* Decode the type of the argument */
     ad2:	88 35       	cpi	r24, 0x58	; 88
     ad4:	09 f0       	breq	.+2      	; 0xad8 <LCD_Printf+0x1be>
     ad6:	87 cf       	rjmp	.-242    	; 0x9e6 <LCD_Printf+0xcc>
                   ch = *ptr;
                }
            }
            else
            {
              v_numOfDigitsToDisp_u8 = C_MaxDigitsToDisplayUsingPrintf_U8;
     ad8:	2f ef       	ldi	r18, 0xFF	; 255
                v_num_u16 = va_arg(argp, int);
                LCD_DisplayNumber(C_HEX_U8,v_num_u16,v_numOfDigitsToDisp_u8);
                break;

            case 'X':  /* Argument type is of hex, hence hexadecimal data from the argp */
                v_num_u32 = va_arg(argp, uint32_t);
     ada:	68 01       	movw	r12, r16
     adc:	f4 e0       	ldi	r31, 0x04	; 4
     ade:	cf 0e       	add	r12, r31
     ae0:	d1 1c       	adc	r13, r1
                LCD_DisplayNumber(C_HEX_U8,v_num_u32,v_numOfDigitsToDisp_u8);                
     ae2:	f8 01       	movw	r30, r16
     ae4:	40 81       	ld	r20, Z
     ae6:	51 81       	ldd	r21, Z+1	; 0x01
     ae8:	62 81       	ldd	r22, Z+2	; 0x02
     aea:	73 81       	ldd	r23, Z+3	; 0x03
     aec:	80 e1       	ldi	r24, 0x10	; 16
     aee:	0e 94 bf 03 	call	0x77e	; 0x77e <LCD_DisplayNumber>
     af2:	39 c0       	rjmp	.+114    	; 0xb66 <LCD_Printf+0x24c>
            {
              v_numOfDigitsToDisp_u8 = C_MaxDigitsToDisplayUsingPrintf_U8;
            }                


            switch(ch)       /* Decode the type of the argument */
     af4:	82 36       	cpi	r24, 0x62	; 98
     af6:	e1 f5       	brne	.+120    	; 0xb70 <LCD_Printf+0x256>
                   ch = *ptr;
                }
            }
            else
            {
              v_numOfDigitsToDisp_u8 = C_MaxDigitsToDisplayUsingPrintf_U8;
     af8:	2f ef       	ldi	r18, 0xFF	; 255
                LCD_DisplayNumber(C_HEX_U8,v_num_u32,v_numOfDigitsToDisp_u8);                
                break;

            
            case 'b':  /* Argument type is of binary,Read int and convert to binary */
                v_num_u16 = va_arg(argp, int);
     afa:	68 01       	movw	r12, r16
     afc:	f2 e0       	ldi	r31, 0x02	; 2
     afe:	cf 0e       	add	r12, r31
     b00:	d1 1c       	adc	r13, r1
     b02:	f8 01       	movw	r30, r16
     b04:	60 81       	ld	r22, Z
     b06:	71 81       	ldd	r23, Z+1	; 0x01
                if(v_numOfDigitsToDisp_u8 == C_MaxDigitsToDisplayUsingPrintf_U8)
     b08:	2f 3f       	cpi	r18, 0xFF	; 255
     b0a:	09 f4       	brne	.+2      	; 0xb0e <LCD_Printf+0x1f4>
                   v_numOfDigitsToDisp_u8 = 16;
     b0c:	20 e1       	ldi	r18, 0x10	; 16
                LCD_DisplayNumber(C_BINARY_U8,v_num_u16,v_numOfDigitsToDisp_u8);                
     b0e:	80 e0       	ldi	r24, 0x00	; 0
     b10:	90 e0       	ldi	r25, 0x00	; 0
     b12:	0c c0       	rjmp	.+24     	; 0xb2c <LCD_Printf+0x212>
                break;

            case 'B':  /* Argument type is of binary,Read int and convert to binary */
                v_num_u32 = va_arg(argp, uint32_t);
     b14:	68 01       	movw	r12, r16
     b16:	f4 e0       	ldi	r31, 0x04	; 4
     b18:	cf 0e       	add	r12, r31
     b1a:	d1 1c       	adc	r13, r1
     b1c:	f8 01       	movw	r30, r16
     b1e:	60 81       	ld	r22, Z
     b20:	71 81       	ldd	r23, Z+1	; 0x01
     b22:	82 81       	ldd	r24, Z+2	; 0x02
     b24:	93 81       	ldd	r25, Z+3	; 0x03
                if(v_numOfDigitsToDisp_u8 == C_MaxDigitsToDisplayUsingPrintf_U8)
     b26:	2f 3f       	cpi	r18, 0xFF	; 255
     b28:	09 f4       	brne	.+2      	; 0xb2c <LCD_Printf+0x212>
                   v_numOfDigitsToDisp_u8 = 16;                
     b2a:	20 e1       	ldi	r18, 0x10	; 16
     b2c:	42 2f       	mov	r20, r18
     b2e:	0e 94 76 03 	call	0x6ec	; 0x6ec <LCD_DisplayNumber.part.3>
     b32:	19 c0       	rjmp	.+50     	; 0xb66 <LCD_Printf+0x24c>
            {
              v_numOfDigitsToDisp_u8 = C_MaxDigitsToDisplayUsingPrintf_U8;
            }                


            switch(ch)       /* Decode the type of the argument */
     b34:	86 34       	cpi	r24, 0x46	; 70
     b36:	e1 f4       	brne	.+56     	; 0xb70 <LCD_Printf+0x256>


            case 'F':
            case 'f': /* Argument type is of float, hence read double data from the argp */
#if (Enable_LCD_DisplayFloatNumber == 1)  
                v_floatNum_f32 = va_arg(argp, double);              
     b38:	68 01       	movw	r12, r16
     b3a:	f4 e0       	ldi	r31, 0x04	; 4
     b3c:	cf 0e       	add	r12, r31
     b3e:	d1 1c       	adc	r13, r1
                LCD_DisplayFloatNumber(v_floatNum_f32);
     b40:	f8 01       	movw	r30, r16
     b42:	60 81       	ld	r22, Z
     b44:	71 81       	ldd	r23, Z+1	; 0x01
     b46:	82 81       	ldd	r24, Z+2	; 0x02
     b48:	93 81       	ldd	r25, Z+3	; 0x03
     b4a:	0e 94 56 04 	call	0x8ac	; 0x8ac <LCD_DisplayFloatNumber>
     b4e:	0b c0       	rjmp	.+22     	; 0xb66 <LCD_Printf+0x24c>
            {
              v_numOfDigitsToDisp_u8 = C_MaxDigitsToDisplayUsingPrintf_U8;
            }                


            switch(ch)       /* Decode the type of the argument */
     b50:	83 37       	cpi	r24, 0x73	; 115
     b52:	71 f4       	brne	.+28     	; 0xb70 <LCD_Printf+0x256>
                break;


            case 'S':
            case 's': /* Argument type is of string, hence get the pointer to sting passed */
                str = va_arg(argp, char *);
     b54:	68 01       	movw	r12, r16
     b56:	f2 e0       	ldi	r31, 0x02	; 2
     b58:	cf 0e       	add	r12, r31
     b5a:	d1 1c       	adc	r13, r1
                LCD_DisplayString(str);                
     b5c:	f8 01       	movw	r30, r16
     b5e:	80 81       	ld	r24, Z
     b60:	91 81       	ldd	r25, Z+1	; 0x01
     b62:	0e 94 b3 03 	call	0x766	; 0x766 <LCD_DisplayString>
                break;


            case 'S':
            case 's': /* Argument type is of string, hence get the pointer to sting passed */
                str = va_arg(argp, char *);
     b66:	86 01       	movw	r16, r12
                LCD_DisplayString(str);                
                break;
     b68:	03 c0       	rjmp	.+6      	; 0xb70 <LCD_Printf+0x256>
            }
        }
        else
        {
            /* As '%' is not detected display/transmit the char passed */
            LCD_DisplayChar(ch);
     b6a:	0e 94 4a 03 	call	0x694	; 0x694 <LCD_DisplayChar>
     b6e:	76 01       	movw	r14, r12
#endif

    va_start(argp, argList);

    /* Loop through the list to extract all the input arguments */
    for(ptr = argList; *ptr != '\0'; ptr++)
     b70:	67 01       	movw	r12, r14
     b72:	ff ef       	ldi	r31, 0xFF	; 255
     b74:	cf 1a       	sub	r12, r31
     b76:	df 0a       	sbc	r13, r31
     b78:	e2 ce       	rjmp	.-572    	; 0x93e <LCD_Printf+0x24>
            {
              v_numOfDigitsToDisp_u8 = C_MaxDigitsToDisplayUsingPrintf_U8;
            }                


            switch(ch)       /* Decode the type of the argument */
     b7a:	82 34       	cpi	r24, 0x42	; 66
     b7c:	09 f0       	breq	.+2      	; 0xb80 <LCD_Printf+0x266>
     b7e:	27 cf       	rjmp	.-434    	; 0x9ce <LCD_Printf+0xb4>
                   v_numOfDigitsToDisp_u8 = 16;
                LCD_DisplayNumber(C_BINARY_U8,v_num_u16,v_numOfDigitsToDisp_u8);                
                break;

            case 'B':  /* Argument type is of binary,Read int and convert to binary */
                v_num_u32 = va_arg(argp, uint32_t);
     b80:	68 01       	movw	r12, r16
     b82:	f4 e0       	ldi	r31, 0x04	; 4
     b84:	cf 0e       	add	r12, r31
     b86:	d1 1c       	adc	r13, r1
     b88:	f8 01       	movw	r30, r16
     b8a:	60 81       	ld	r22, Z
     b8c:	71 81       	ldd	r23, Z+1	; 0x01
     b8e:	82 81       	ldd	r24, Z+2	; 0x02
     b90:	93 81       	ldd	r25, Z+3	; 0x03
     b92:	cb cf       	rjmp	.-106    	; 0xb2a <LCD_Printf+0x210>
            {
              v_numOfDigitsToDisp_u8 = C_MaxDigitsToDisplayUsingPrintf_U8;
            }                


            switch(ch)       /* Decode the type of the argument */
     b94:	85 32       	cpi	r24, 0x25	; 37
     b96:	61 f7       	brne	.-40     	; 0xb70 <LCD_Printf+0x256>
                str = va_arg(argp, char *);
                LCD_DisplayString(str);                
                break;

            case '%':
                LCD_DisplayChar('%');
     b98:	85 e2       	ldi	r24, 0x25	; 37
     b9a:	0e 94 4a 03 	call	0x694	; 0x694 <LCD_DisplayChar>
                break;
     b9e:	e8 cf       	rjmp	.-48     	; 0xb70 <LCD_Printf+0x256>
            LCD_DisplayChar(ch);
        }
    }

    va_end(argp);
}
     ba0:	0f 90       	pop	r0
     ba2:	0f 90       	pop	r0
     ba4:	0f 90       	pop	r0
     ba6:	0f 90       	pop	r0
     ba8:	0f 90       	pop	r0
     baa:	df 91       	pop	r29
     bac:	cf 91       	pop	r28
     bae:	1f 91       	pop	r17
     bb0:	0f 91       	pop	r16
     bb2:	ff 90       	pop	r15
     bb4:	ef 90       	pop	r14
     bb6:	df 90       	pop	r13
     bb8:	cf 90       	pop	r12
     bba:	08 95       	ret

00000bbc <RTC_Init>:

 * description :This function is used to Initialize the Ds1307 RTC.
***************************************************************************************************/
void RTC_Init(void)
{
    I2C_Init();                             // Initialize the I2c module.
     bbc:	0e 94 5e 01 	call	0x2bc	; 0x2bc <I2C_Init>
    I2C_Start();                            // Start I2C communication
     bc0:	0e 94 64 01 	call	0x2c8	; 0x2c8 <I2C_Start>

    I2C_Write(C_Ds1307WriteMode_U8);        // Connect to DS1307 by sending its ID on I2c Bus
     bc4:	80 ed       	ldi	r24, 0xD0	; 208
     bc6:	0e 94 70 01 	call	0x2e0	; 0x2e0 <I2C_Write>
    I2C_Write(C_Ds1307ControlRegAddress_U8);// Select the Ds1307 ControlRegister to configure Ds1307
     bca:	87 e0       	ldi	r24, 0x07	; 7
     bcc:	0e 94 70 01 	call	0x2e0	; 0x2e0 <I2C_Write>

    I2C_Write(0x00);                        // Write 0x00 to Control register to disable SQW-Out
     bd0:	80 e0       	ldi	r24, 0x00	; 0
     bd2:	0e 94 70 01 	call	0x2e0	; 0x2e0 <I2C_Write>

    I2C_Stop();                             // Stop I2C communication after initializing DS1307
     bd6:	0c 94 6a 01 	jmp	0x2d4	; 0x2d4 <I2C_Stop>

00000bda <RTC_SetDateTime>:
        Note: The date and time should be of BCD format, 
             like 0x12,0x39,0x26 for 12hr,39min and 26sec.    
                  0x15,0x08,0x47 for 15th day,8th month and 47th year.                 
***************************************************************************************************/
void RTC_SetDateTime(rtc_t *rtc)
{
     bda:	cf 93       	push	r28
     bdc:	df 93       	push	r29
     bde:	ec 01       	movw	r28, r24
    I2C_Start();                          // Start I2C communication
     be0:	0e 94 64 01 	call	0x2c8	; 0x2c8 <I2C_Start>

    I2C_Write(C_Ds1307WriteMode_U8);      // connect to DS1307 by sending its ID on I2c Bus
     be4:	80 ed       	ldi	r24, 0xD0	; 208
     be6:	0e 94 70 01 	call	0x2e0	; 0x2e0 <I2C_Write>
    I2C_Write(C_Ds1307SecondRegAddress_U8); // Request sec RAM address at 00H
     bea:	80 e0       	ldi	r24, 0x00	; 0
     bec:	0e 94 70 01 	call	0x2e0	; 0x2e0 <I2C_Write>

    I2C_Write(rtc->sec);                    // Write sec from RAM address 00H
     bf0:	88 81       	ld	r24, Y
     bf2:	0e 94 70 01 	call	0x2e0	; 0x2e0 <I2C_Write>
    I2C_Write(rtc->min);                    // Write min from RAM address 01H
     bf6:	89 81       	ldd	r24, Y+1	; 0x01
     bf8:	0e 94 70 01 	call	0x2e0	; 0x2e0 <I2C_Write>
    I2C_Write(rtc->hour);                    // Write hour from RAM address 02H
     bfc:	8a 81       	ldd	r24, Y+2	; 0x02
     bfe:	0e 94 70 01 	call	0x2e0	; 0x2e0 <I2C_Write>
    I2C_Write(rtc->weekDay);                // Write weekDay on RAM address 03H
     c02:	8b 81       	ldd	r24, Y+3	; 0x03
     c04:	0e 94 70 01 	call	0x2e0	; 0x2e0 <I2C_Write>
    I2C_Write(rtc->date);                    // Write date on RAM address 04H
     c08:	8c 81       	ldd	r24, Y+4	; 0x04
     c0a:	0e 94 70 01 	call	0x2e0	; 0x2e0 <I2C_Write>
    I2C_Write(rtc->month);                    // Write month on RAM address 05H
     c0e:	8d 81       	ldd	r24, Y+5	; 0x05
     c10:	0e 94 70 01 	call	0x2e0	; 0x2e0 <I2C_Write>
    I2C_Write(rtc->year);                    // Write year on RAM address 06h
     c14:	8e 81       	ldd	r24, Y+6	; 0x06
     c16:	0e 94 70 01 	call	0x2e0	; 0x2e0 <I2C_Write>

    I2C_Stop();                              // Stop I2C communication after Setting the Date
}
     c1a:	df 91       	pop	r29
     c1c:	cf 91       	pop	r28
    I2C_Write(rtc->weekDay);                // Write weekDay on RAM address 03H
    I2C_Write(rtc->date);                    // Write date on RAM address 04H
    I2C_Write(rtc->month);                    // Write month on RAM address 05H
    I2C_Write(rtc->year);                    // Write year on RAM address 06h

    I2C_Stop();                              // Stop I2C communication after Setting the Date
     c1e:	0c 94 6a 01 	jmp	0x2d4	; 0x2d4 <I2C_Stop>

00000c22 <RTC_GetDateTime>:
    Note: The date and time read from Ds1307 will be of BCD format, 
          like 0x12,0x39,0x26 for 12hr,39min and 26sec.    
               0x15,0x08,0x47 for 15th day,8th month and 47th year.              
***************************************************************************************************/
void RTC_GetDateTime(rtc_t *rtc)
{
     c22:	cf 93       	push	r28
     c24:	df 93       	push	r29
     c26:	ec 01       	movw	r28, r24
    I2C_Start();                            // Start I2C communication
     c28:	0e 94 64 01 	call	0x2c8	; 0x2c8 <I2C_Start>

    I2C_Write(C_Ds1307WriteMode_U8);        // connect to DS1307 by sending its ID on I2c Bus
     c2c:	80 ed       	ldi	r24, 0xD0	; 208
     c2e:	0e 94 70 01 	call	0x2e0	; 0x2e0 <I2C_Write>
    I2C_Write(C_Ds1307SecondRegAddress_U8); // Request Sec RAM address at 00H
     c32:	80 e0       	ldi	r24, 0x00	; 0
     c34:	0e 94 70 01 	call	0x2e0	; 0x2e0 <I2C_Write>

    I2C_Stop();                                // Stop I2C communication after selecting Sec Register
     c38:	0e 94 6a 01 	call	0x2d4	; 0x2d4 <I2C_Stop>

    I2C_Start();                            // Start I2C communication
     c3c:	0e 94 64 01 	call	0x2c8	; 0x2c8 <I2C_Start>
    I2C_Write(C_Ds1307ReadMode_U8);            // connect to DS1307(Read mode) by sending its ID
     c40:	81 ed       	ldi	r24, 0xD1	; 209
     c42:	0e 94 70 01 	call	0x2e0	; 0x2e0 <I2C_Write>

    rtc->sec = I2C_Read(1);                // read second and return Positive ACK
     c46:	81 e0       	ldi	r24, 0x01	; 1
     c48:	0e 94 77 01 	call	0x2ee	; 0x2ee <I2C_Read>
     c4c:	88 83       	st	Y, r24
    rtc->min = I2C_Read(1);                 // read minute and return Positive ACK
     c4e:	81 e0       	ldi	r24, 0x01	; 1
     c50:	0e 94 77 01 	call	0x2ee	; 0x2ee <I2C_Read>
     c54:	89 83       	std	Y+1, r24	; 0x01
    rtc->hour= I2C_Read(1);               // read hour and return Negative/No ACK
     c56:	81 e0       	ldi	r24, 0x01	; 1
     c58:	0e 94 77 01 	call	0x2ee	; 0x2ee <I2C_Read>
     c5c:	8a 83       	std	Y+2, r24	; 0x02
    rtc->weekDay = I2C_Read(1);           // read weekDay and return Positive ACK
     c5e:	81 e0       	ldi	r24, 0x01	; 1
     c60:	0e 94 77 01 	call	0x2ee	; 0x2ee <I2C_Read>
     c64:	8b 83       	std	Y+3, r24	; 0x03
    rtc->date= I2C_Read(1);              // read Date and return Positive ACK
     c66:	81 e0       	ldi	r24, 0x01	; 1
     c68:	0e 94 77 01 	call	0x2ee	; 0x2ee <I2C_Read>
     c6c:	8c 83       	std	Y+4, r24	; 0x04
    rtc->month=I2C_Read(1);            // read Month and return Positive ACK
     c6e:	81 e0       	ldi	r24, 0x01	; 1
     c70:	0e 94 77 01 	call	0x2ee	; 0x2ee <I2C_Read>
     c74:	8d 83       	std	Y+5, r24	; 0x05
    rtc->year =I2C_Read(0);             // read Year and return Negative/No ACK
     c76:	80 e0       	ldi	r24, 0x00	; 0
     c78:	0e 94 77 01 	call	0x2ee	; 0x2ee <I2C_Read>
     c7c:	8e 83       	std	Y+6, r24	; 0x06

    I2C_Stop();                              // Stop I2C communication after reading the Date
}
     c7e:	df 91       	pop	r29
     c80:	cf 91       	pop	r28
    rtc->weekDay = I2C_Read(1);           // read weekDay and return Positive ACK
    rtc->date= I2C_Read(1);              // read Date and return Positive ACK
    rtc->month=I2C_Read(1);            // read Month and return Positive ACK
    rtc->year =I2C_Read(0);             // read Year and return Negative/No ACK

    I2C_Stop();                              // Stop I2C communication after reading the Date
     c82:	0c 94 6a 01 	jmp	0x2d4	; 0x2d4 <I2C_Stop>

00000c86 <main>:
#include "rtc.h"
#include "lcd.h"


int main() 
{
     c86:	cf 93       	push	r28
     c88:	df 93       	push	r29
     c8a:	cd b7       	in	r28, 0x3d	; 61
     c8c:	de b7       	in	r29, 0x3e	; 62
     c8e:	27 97       	sbiw	r28, 0x07	; 7
     c90:	0f b6       	in	r0, 0x3f	; 63
     c92:	f8 94       	cli
     c94:	de bf       	out	0x3e, r29	; 62
     c96:	0f be       	out	0x3f, r0	; 63
     c98:	cd bf       	out	0x3d, r28	; 61
    rtc_t rtc;

    /*Connect RS->PB0, RW->PB1, EN->PB2 and data bus to PORTB.4 to PORTB.7*/
    LCD_SetUp(PB_0,PB_1,PB_2,P_NC,P_NC,P_NC,P_NC,PB_4,PB_5,PB_6,PB_7);
     c9a:	8f e0       	ldi	r24, 0x0F	; 15
     c9c:	8f 93       	push	r24
     c9e:	8e e0       	ldi	r24, 0x0E	; 14
     ca0:	8f 93       	push	r24
     ca2:	8d e0       	ldi	r24, 0x0D	; 13
     ca4:	88 2e       	mov	r8, r24
     ca6:	9c e0       	ldi	r25, 0x0C	; 12
     ca8:	a9 2e       	mov	r10, r25
     caa:	cc 24       	eor	r12, r12
     cac:	ca 94       	dec	r12
     cae:	ee 24       	eor	r14, r14
     cb0:	ea 94       	dec	r14
     cb2:	0f ef       	ldi	r16, 0xFF	; 255
     cb4:	2f ef       	ldi	r18, 0xFF	; 255
     cb6:	4a e0       	ldi	r20, 0x0A	; 10
     cb8:	69 e0       	ldi	r22, 0x09	; 9
     cba:	88 e0       	ldi	r24, 0x08	; 8
     cbc:	0e 94 4f 02 	call	0x49e	; 0x49e <LCD_SetUp>
    LCD_Init(2,16);
     cc0:	60 e1       	ldi	r22, 0x10	; 16
     cc2:	82 e0       	ldi	r24, 0x02	; 2
     cc4:	0e 94 ef 02 	call	0x5de	; 0x5de <LCD_Init>
	
    /*Connect SCL->PC0, SDA->PC1*/    
    RTC_Init();
     cc8:	0e 94 de 05 	call	0xbbc	; 0xbbc <RTC_Init>
    rtc.hour = 0x10; //  10:40:20 am
     ccc:	80 e1       	ldi	r24, 0x10	; 16
     cce:	8b 83       	std	Y+3, r24	; 0x03
    rtc.min =  0x40;
     cd0:	80 e4       	ldi	r24, 0x40	; 64
     cd2:	8a 83       	std	Y+2, r24	; 0x02
    rtc.sec =  0x00;
     cd4:	19 82       	std	Y+1, r1	; 0x01

    rtc.date = 0x01; //1st Jan 2016
     cd6:	81 e0       	ldi	r24, 0x01	; 1
     cd8:	8d 83       	std	Y+5, r24	; 0x05
    rtc.month = 0x01;
     cda:	8e 83       	std	Y+6, r24	; 0x06
    rtc.year = 0x16;
     cdc:	86 e1       	ldi	r24, 0x16	; 22
     cde:	8f 83       	std	Y+7, r24	; 0x07
    rtc.weekDay = 5; // Friday: 5th day of week considering monday as first day.
     ce0:	85 e0       	ldi	r24, 0x05	; 5
     ce2:	8c 83       	std	Y+4, r24	; 0x04



    /*##### Set the time and Date only once. Once the Time and Date is set, comment these lines
         and reflash the code. Else the time will be set every time the controller is reset*/
    RTC_SetDateTime(&rtc);  //  10:40:20 am, 1st Jan 2016
     ce4:	ce 01       	movw	r24, r28
     ce6:	01 96       	adiw	r24, 0x01	; 1
     ce8:	0e 94 ed 05 	call	0xbda	; 0xbda <RTC_SetDateTime>
     cec:	0f 90       	pop	r0
     cee:	0f 90       	pop	r0
    /* Display the Time and Date continuously */
    while(1)
    {
        RTC_GetDateTime(&rtc);
        LCD_GoToLine(0);
        LCD_Printf("time:%2x:%2x:%2x  \nDate:%2x/%2x/%2x",(uint16_t)rtc.hour,(uint16_t)rtc.min,(uint16_t)rtc.sec,(uint16_t)rtc.date,(uint16_t)rtc.month,(uint16_t)rtc.year);
     cf0:	04 e6       	ldi	r16, 0x64	; 100
     cf2:	10 e0       	ldi	r17, 0x00	; 0


    /* Display the Time and Date continuously */
    while(1)
    {
        RTC_GetDateTime(&rtc);
     cf4:	ce 01       	movw	r24, r28
     cf6:	01 96       	adiw	r24, 0x01	; 1
     cf8:	0e 94 11 06 	call	0xc22	; 0xc22 <RTC_GetDateTime>
        LCD_GoToLine(0);
     cfc:	80 e0       	ldi	r24, 0x00	; 0
     cfe:	0e 94 d9 02 	call	0x5b2	; 0x5b2 <LCD_GoToLine>
        LCD_Printf("time:%2x:%2x:%2x  \nDate:%2x/%2x/%2x",(uint16_t)rtc.hour,(uint16_t)rtc.min,(uint16_t)rtc.sec,(uint16_t)rtc.date,(uint16_t)rtc.month,(uint16_t)rtc.year);
     d02:	8f 81       	ldd	r24, Y+7	; 0x07
     d04:	1f 92       	push	r1
     d06:	8f 93       	push	r24
     d08:	8e 81       	ldd	r24, Y+6	; 0x06
     d0a:	1f 92       	push	r1
     d0c:	8f 93       	push	r24
     d0e:	8d 81       	ldd	r24, Y+5	; 0x05
     d10:	1f 92       	push	r1
     d12:	8f 93       	push	r24
     d14:	89 81       	ldd	r24, Y+1	; 0x01
     d16:	1f 92       	push	r1
     d18:	8f 93       	push	r24
     d1a:	8a 81       	ldd	r24, Y+2	; 0x02
     d1c:	1f 92       	push	r1
     d1e:	8f 93       	push	r24
     d20:	8b 81       	ldd	r24, Y+3	; 0x03
     d22:	1f 92       	push	r1
     d24:	8f 93       	push	r24
     d26:	1f 93       	push	r17
     d28:	0f 93       	push	r16
     d2a:	0e 94 8d 04 	call	0x91a	; 0x91a <LCD_Printf>
    }
     d2e:	0f b6       	in	r0, 0x3f	; 63
     d30:	f8 94       	cli
     d32:	de bf       	out	0x3e, r29	; 62
     d34:	0f be       	out	0x3f, r0	; 63
     d36:	cd bf       	out	0x3d, r28	; 61
     d38:	dd cf       	rjmp	.-70     	; 0xcf4 <main+0x6e>

00000d3a <__subsf3>:
     d3a:	50 58       	subi	r21, 0x80	; 128

00000d3c <__addsf3>:
     d3c:	bb 27       	eor	r27, r27
     d3e:	aa 27       	eor	r26, r26
     d40:	0e 94 b5 06 	call	0xd6a	; 0xd6a <__addsf3x>
     d44:	0c 94 8d 07 	jmp	0xf1a	; 0xf1a <__fp_round>
     d48:	0e 94 7f 07 	call	0xefe	; 0xefe <__fp_pscA>
     d4c:	38 f0       	brcs	.+14     	; 0xd5c <__addsf3+0x20>
     d4e:	0e 94 86 07 	call	0xf0c	; 0xf0c <__fp_pscB>
     d52:	20 f0       	brcs	.+8      	; 0xd5c <__addsf3+0x20>
     d54:	39 f4       	brne	.+14     	; 0xd64 <__addsf3+0x28>
     d56:	9f 3f       	cpi	r25, 0xFF	; 255
     d58:	19 f4       	brne	.+6      	; 0xd60 <__addsf3+0x24>
     d5a:	26 f4       	brtc	.+8      	; 0xd64 <__addsf3+0x28>
     d5c:	0c 94 7c 07 	jmp	0xef8	; 0xef8 <__fp_nan>
     d60:	0e f4       	brtc	.+2      	; 0xd64 <__addsf3+0x28>
     d62:	e0 95       	com	r30
     d64:	e7 fb       	bst	r30, 7
     d66:	0c 94 76 07 	jmp	0xeec	; 0xeec <__fp_inf>

00000d6a <__addsf3x>:
     d6a:	e9 2f       	mov	r30, r25
     d6c:	0e 94 9e 07 	call	0xf3c	; 0xf3c <__fp_split3>
     d70:	58 f3       	brcs	.-42     	; 0xd48 <__addsf3+0xc>
     d72:	ba 17       	cp	r27, r26
     d74:	62 07       	cpc	r22, r18
     d76:	73 07       	cpc	r23, r19
     d78:	84 07       	cpc	r24, r20
     d7a:	95 07       	cpc	r25, r21
     d7c:	20 f0       	brcs	.+8      	; 0xd86 <__addsf3x+0x1c>
     d7e:	79 f4       	brne	.+30     	; 0xd9e <__addsf3x+0x34>
     d80:	a6 f5       	brtc	.+104    	; 0xdea <__addsf3x+0x80>
     d82:	0c 94 c0 07 	jmp	0xf80	; 0xf80 <__fp_zero>
     d86:	0e f4       	brtc	.+2      	; 0xd8a <__addsf3x+0x20>
     d88:	e0 95       	com	r30
     d8a:	0b 2e       	mov	r0, r27
     d8c:	ba 2f       	mov	r27, r26
     d8e:	a0 2d       	mov	r26, r0
     d90:	0b 01       	movw	r0, r22
     d92:	b9 01       	movw	r22, r18
     d94:	90 01       	movw	r18, r0
     d96:	0c 01       	movw	r0, r24
     d98:	ca 01       	movw	r24, r20
     d9a:	a0 01       	movw	r20, r0
     d9c:	11 24       	eor	r1, r1
     d9e:	ff 27       	eor	r31, r31
     da0:	59 1b       	sub	r21, r25
     da2:	99 f0       	breq	.+38     	; 0xdca <__addsf3x+0x60>
     da4:	59 3f       	cpi	r21, 0xF9	; 249
     da6:	50 f4       	brcc	.+20     	; 0xdbc <__addsf3x+0x52>
     da8:	50 3e       	cpi	r21, 0xE0	; 224
     daa:	68 f1       	brcs	.+90     	; 0xe06 <__addsf3x+0x9c>
     dac:	1a 16       	cp	r1, r26
     dae:	f0 40       	sbci	r31, 0x00	; 0
     db0:	a2 2f       	mov	r26, r18
     db2:	23 2f       	mov	r18, r19
     db4:	34 2f       	mov	r19, r20
     db6:	44 27       	eor	r20, r20
     db8:	58 5f       	subi	r21, 0xF8	; 248
     dba:	f3 cf       	rjmp	.-26     	; 0xda2 <__addsf3x+0x38>
     dbc:	46 95       	lsr	r20
     dbe:	37 95       	ror	r19
     dc0:	27 95       	ror	r18
     dc2:	a7 95       	ror	r26
     dc4:	f0 40       	sbci	r31, 0x00	; 0
     dc6:	53 95       	inc	r21
     dc8:	c9 f7       	brne	.-14     	; 0xdbc <__addsf3x+0x52>
     dca:	7e f4       	brtc	.+30     	; 0xdea <__addsf3x+0x80>
     dcc:	1f 16       	cp	r1, r31
     dce:	ba 0b       	sbc	r27, r26
     dd0:	62 0b       	sbc	r22, r18
     dd2:	73 0b       	sbc	r23, r19
     dd4:	84 0b       	sbc	r24, r20
     dd6:	ba f0       	brmi	.+46     	; 0xe06 <__addsf3x+0x9c>
     dd8:	91 50       	subi	r25, 0x01	; 1
     dda:	a1 f0       	breq	.+40     	; 0xe04 <__addsf3x+0x9a>
     ddc:	ff 0f       	add	r31, r31
     dde:	bb 1f       	adc	r27, r27
     de0:	66 1f       	adc	r22, r22
     de2:	77 1f       	adc	r23, r23
     de4:	88 1f       	adc	r24, r24
     de6:	c2 f7       	brpl	.-16     	; 0xdd8 <__addsf3x+0x6e>
     de8:	0e c0       	rjmp	.+28     	; 0xe06 <__addsf3x+0x9c>
     dea:	ba 0f       	add	r27, r26
     dec:	62 1f       	adc	r22, r18
     dee:	73 1f       	adc	r23, r19
     df0:	84 1f       	adc	r24, r20
     df2:	48 f4       	brcc	.+18     	; 0xe06 <__addsf3x+0x9c>
     df4:	87 95       	ror	r24
     df6:	77 95       	ror	r23
     df8:	67 95       	ror	r22
     dfa:	b7 95       	ror	r27
     dfc:	f7 95       	ror	r31
     dfe:	9e 3f       	cpi	r25, 0xFE	; 254
     e00:	08 f0       	brcs	.+2      	; 0xe04 <__addsf3x+0x9a>
     e02:	b0 cf       	rjmp	.-160    	; 0xd64 <__addsf3+0x28>
     e04:	93 95       	inc	r25
     e06:	88 0f       	add	r24, r24
     e08:	08 f0       	brcs	.+2      	; 0xe0c <__addsf3x+0xa2>
     e0a:	99 27       	eor	r25, r25
     e0c:	ee 0f       	add	r30, r30
     e0e:	97 95       	ror	r25
     e10:	87 95       	ror	r24
     e12:	08 95       	ret

00000e14 <__fixunssfsi>:
     e14:	0e 94 a6 07 	call	0xf4c	; 0xf4c <__fp_splitA>
     e18:	88 f0       	brcs	.+34     	; 0xe3c <__fixunssfsi+0x28>
     e1a:	9f 57       	subi	r25, 0x7F	; 127
     e1c:	98 f0       	brcs	.+38     	; 0xe44 <__fixunssfsi+0x30>
     e1e:	b9 2f       	mov	r27, r25
     e20:	99 27       	eor	r25, r25
     e22:	b7 51       	subi	r27, 0x17	; 23
     e24:	b0 f0       	brcs	.+44     	; 0xe52 <__fixunssfsi+0x3e>
     e26:	e1 f0       	breq	.+56     	; 0xe60 <__fixunssfsi+0x4c>
     e28:	66 0f       	add	r22, r22
     e2a:	77 1f       	adc	r23, r23
     e2c:	88 1f       	adc	r24, r24
     e2e:	99 1f       	adc	r25, r25
     e30:	1a f0       	brmi	.+6      	; 0xe38 <__fixunssfsi+0x24>
     e32:	ba 95       	dec	r27
     e34:	c9 f7       	brne	.-14     	; 0xe28 <__fixunssfsi+0x14>
     e36:	14 c0       	rjmp	.+40     	; 0xe60 <__fixunssfsi+0x4c>
     e38:	b1 30       	cpi	r27, 0x01	; 1
     e3a:	91 f0       	breq	.+36     	; 0xe60 <__fixunssfsi+0x4c>
     e3c:	0e 94 c0 07 	call	0xf80	; 0xf80 <__fp_zero>
     e40:	b1 e0       	ldi	r27, 0x01	; 1
     e42:	08 95       	ret
     e44:	0c 94 c0 07 	jmp	0xf80	; 0xf80 <__fp_zero>
     e48:	67 2f       	mov	r22, r23
     e4a:	78 2f       	mov	r23, r24
     e4c:	88 27       	eor	r24, r24
     e4e:	b8 5f       	subi	r27, 0xF8	; 248
     e50:	39 f0       	breq	.+14     	; 0xe60 <__fixunssfsi+0x4c>
     e52:	b9 3f       	cpi	r27, 0xF9	; 249
     e54:	cc f3       	brlt	.-14     	; 0xe48 <__fixunssfsi+0x34>
     e56:	86 95       	lsr	r24
     e58:	77 95       	ror	r23
     e5a:	67 95       	ror	r22
     e5c:	b3 95       	inc	r27
     e5e:	d9 f7       	brne	.-10     	; 0xe56 <__fixunssfsi+0x42>
     e60:	3e f4       	brtc	.+14     	; 0xe70 <__fixunssfsi+0x5c>
     e62:	90 95       	com	r25
     e64:	80 95       	com	r24
     e66:	70 95       	com	r23
     e68:	61 95       	neg	r22
     e6a:	7f 4f       	sbci	r23, 0xFF	; 255
     e6c:	8f 4f       	sbci	r24, 0xFF	; 255
     e6e:	9f 4f       	sbci	r25, 0xFF	; 255
     e70:	08 95       	ret

00000e72 <__floatunsisf>:
     e72:	e8 94       	clt
     e74:	09 c0       	rjmp	.+18     	; 0xe88 <__floatsisf+0x12>

00000e76 <__floatsisf>:
     e76:	97 fb       	bst	r25, 7
     e78:	3e f4       	brtc	.+14     	; 0xe88 <__floatsisf+0x12>
     e7a:	90 95       	com	r25
     e7c:	80 95       	com	r24
     e7e:	70 95       	com	r23
     e80:	61 95       	neg	r22
     e82:	7f 4f       	sbci	r23, 0xFF	; 255
     e84:	8f 4f       	sbci	r24, 0xFF	; 255
     e86:	9f 4f       	sbci	r25, 0xFF	; 255
     e88:	99 23       	and	r25, r25
     e8a:	a9 f0       	breq	.+42     	; 0xeb6 <__floatsisf+0x40>
     e8c:	f9 2f       	mov	r31, r25
     e8e:	96 e9       	ldi	r25, 0x96	; 150
     e90:	bb 27       	eor	r27, r27
     e92:	93 95       	inc	r25
     e94:	f6 95       	lsr	r31
     e96:	87 95       	ror	r24
     e98:	77 95       	ror	r23
     e9a:	67 95       	ror	r22
     e9c:	b7 95       	ror	r27
     e9e:	f1 11       	cpse	r31, r1
     ea0:	f8 cf       	rjmp	.-16     	; 0xe92 <__floatsisf+0x1c>
     ea2:	fa f4       	brpl	.+62     	; 0xee2 <__floatsisf+0x6c>
     ea4:	bb 0f       	add	r27, r27
     ea6:	11 f4       	brne	.+4      	; 0xeac <__floatsisf+0x36>
     ea8:	60 ff       	sbrs	r22, 0
     eaa:	1b c0       	rjmp	.+54     	; 0xee2 <__floatsisf+0x6c>
     eac:	6f 5f       	subi	r22, 0xFF	; 255
     eae:	7f 4f       	sbci	r23, 0xFF	; 255
     eb0:	8f 4f       	sbci	r24, 0xFF	; 255
     eb2:	9f 4f       	sbci	r25, 0xFF	; 255
     eb4:	16 c0       	rjmp	.+44     	; 0xee2 <__floatsisf+0x6c>
     eb6:	88 23       	and	r24, r24
     eb8:	11 f0       	breq	.+4      	; 0xebe <__floatsisf+0x48>
     eba:	96 e9       	ldi	r25, 0x96	; 150
     ebc:	11 c0       	rjmp	.+34     	; 0xee0 <__floatsisf+0x6a>
     ebe:	77 23       	and	r23, r23
     ec0:	21 f0       	breq	.+8      	; 0xeca <__floatsisf+0x54>
     ec2:	9e e8       	ldi	r25, 0x8E	; 142
     ec4:	87 2f       	mov	r24, r23
     ec6:	76 2f       	mov	r23, r22
     ec8:	05 c0       	rjmp	.+10     	; 0xed4 <__floatsisf+0x5e>
     eca:	66 23       	and	r22, r22
     ecc:	71 f0       	breq	.+28     	; 0xeea <__floatsisf+0x74>
     ece:	96 e8       	ldi	r25, 0x86	; 134
     ed0:	86 2f       	mov	r24, r22
     ed2:	70 e0       	ldi	r23, 0x00	; 0
     ed4:	60 e0       	ldi	r22, 0x00	; 0
     ed6:	2a f0       	brmi	.+10     	; 0xee2 <__floatsisf+0x6c>
     ed8:	9a 95       	dec	r25
     eda:	66 0f       	add	r22, r22
     edc:	77 1f       	adc	r23, r23
     ede:	88 1f       	adc	r24, r24
     ee0:	da f7       	brpl	.-10     	; 0xed8 <__floatsisf+0x62>
     ee2:	88 0f       	add	r24, r24
     ee4:	96 95       	lsr	r25
     ee6:	87 95       	ror	r24
     ee8:	97 f9       	bld	r25, 7
     eea:	08 95       	ret

00000eec <__fp_inf>:
     eec:	97 f9       	bld	r25, 7
     eee:	9f 67       	ori	r25, 0x7F	; 127
     ef0:	80 e8       	ldi	r24, 0x80	; 128
     ef2:	70 e0       	ldi	r23, 0x00	; 0
     ef4:	60 e0       	ldi	r22, 0x00	; 0
     ef6:	08 95       	ret

00000ef8 <__fp_nan>:
     ef8:	9f ef       	ldi	r25, 0xFF	; 255
     efa:	80 ec       	ldi	r24, 0xC0	; 192
     efc:	08 95       	ret

00000efe <__fp_pscA>:
     efe:	00 24       	eor	r0, r0
     f00:	0a 94       	dec	r0
     f02:	16 16       	cp	r1, r22
     f04:	17 06       	cpc	r1, r23
     f06:	18 06       	cpc	r1, r24
     f08:	09 06       	cpc	r0, r25
     f0a:	08 95       	ret

00000f0c <__fp_pscB>:
     f0c:	00 24       	eor	r0, r0
     f0e:	0a 94       	dec	r0
     f10:	12 16       	cp	r1, r18
     f12:	13 06       	cpc	r1, r19
     f14:	14 06       	cpc	r1, r20
     f16:	05 06       	cpc	r0, r21
     f18:	08 95       	ret

00000f1a <__fp_round>:
     f1a:	09 2e       	mov	r0, r25
     f1c:	03 94       	inc	r0
     f1e:	00 0c       	add	r0, r0
     f20:	11 f4       	brne	.+4      	; 0xf26 <__fp_round+0xc>
     f22:	88 23       	and	r24, r24
     f24:	52 f0       	brmi	.+20     	; 0xf3a <__fp_round+0x20>
     f26:	bb 0f       	add	r27, r27
     f28:	40 f4       	brcc	.+16     	; 0xf3a <__fp_round+0x20>
     f2a:	bf 2b       	or	r27, r31
     f2c:	11 f4       	brne	.+4      	; 0xf32 <__fp_round+0x18>
     f2e:	60 ff       	sbrs	r22, 0
     f30:	04 c0       	rjmp	.+8      	; 0xf3a <__fp_round+0x20>
     f32:	6f 5f       	subi	r22, 0xFF	; 255
     f34:	7f 4f       	sbci	r23, 0xFF	; 255
     f36:	8f 4f       	sbci	r24, 0xFF	; 255
     f38:	9f 4f       	sbci	r25, 0xFF	; 255
     f3a:	08 95       	ret

00000f3c <__fp_split3>:
     f3c:	57 fd       	sbrc	r21, 7
     f3e:	90 58       	subi	r25, 0x80	; 128
     f40:	44 0f       	add	r20, r20
     f42:	55 1f       	adc	r21, r21
     f44:	59 f0       	breq	.+22     	; 0xf5c <__fp_splitA+0x10>
     f46:	5f 3f       	cpi	r21, 0xFF	; 255
     f48:	71 f0       	breq	.+28     	; 0xf66 <__fp_splitA+0x1a>
     f4a:	47 95       	ror	r20

00000f4c <__fp_splitA>:
     f4c:	88 0f       	add	r24, r24
     f4e:	97 fb       	bst	r25, 7
     f50:	99 1f       	adc	r25, r25
     f52:	61 f0       	breq	.+24     	; 0xf6c <__fp_splitA+0x20>
     f54:	9f 3f       	cpi	r25, 0xFF	; 255
     f56:	79 f0       	breq	.+30     	; 0xf76 <__fp_splitA+0x2a>
     f58:	87 95       	ror	r24
     f5a:	08 95       	ret
     f5c:	12 16       	cp	r1, r18
     f5e:	13 06       	cpc	r1, r19
     f60:	14 06       	cpc	r1, r20
     f62:	55 1f       	adc	r21, r21
     f64:	f2 cf       	rjmp	.-28     	; 0xf4a <__fp_split3+0xe>
     f66:	46 95       	lsr	r20
     f68:	f1 df       	rcall	.-30     	; 0xf4c <__fp_splitA>
     f6a:	08 c0       	rjmp	.+16     	; 0xf7c <__fp_splitA+0x30>
     f6c:	16 16       	cp	r1, r22
     f6e:	17 06       	cpc	r1, r23
     f70:	18 06       	cpc	r1, r24
     f72:	99 1f       	adc	r25, r25
     f74:	f1 cf       	rjmp	.-30     	; 0xf58 <__fp_splitA+0xc>
     f76:	86 95       	lsr	r24
     f78:	71 05       	cpc	r23, r1
     f7a:	61 05       	cpc	r22, r1
     f7c:	08 94       	sec
     f7e:	08 95       	ret

00000f80 <__fp_zero>:
     f80:	e8 94       	clt

00000f82 <__fp_szero>:
     f82:	bb 27       	eor	r27, r27
     f84:	66 27       	eor	r22, r22
     f86:	77 27       	eor	r23, r23
     f88:	cb 01       	movw	r24, r22
     f8a:	97 f9       	bld	r25, 7
     f8c:	08 95       	ret

00000f8e <__mulsf3>:
     f8e:	0e 94 da 07 	call	0xfb4	; 0xfb4 <__mulsf3x>
     f92:	0c 94 8d 07 	jmp	0xf1a	; 0xf1a <__fp_round>
     f96:	0e 94 7f 07 	call	0xefe	; 0xefe <__fp_pscA>
     f9a:	38 f0       	brcs	.+14     	; 0xfaa <__mulsf3+0x1c>
     f9c:	0e 94 86 07 	call	0xf0c	; 0xf0c <__fp_pscB>
     fa0:	20 f0       	brcs	.+8      	; 0xfaa <__mulsf3+0x1c>
     fa2:	95 23       	and	r25, r21
     fa4:	11 f0       	breq	.+4      	; 0xfaa <__mulsf3+0x1c>
     fa6:	0c 94 76 07 	jmp	0xeec	; 0xeec <__fp_inf>
     faa:	0c 94 7c 07 	jmp	0xef8	; 0xef8 <__fp_nan>
     fae:	11 24       	eor	r1, r1
     fb0:	0c 94 c1 07 	jmp	0xf82	; 0xf82 <__fp_szero>

00000fb4 <__mulsf3x>:
     fb4:	0e 94 9e 07 	call	0xf3c	; 0xf3c <__fp_split3>
     fb8:	70 f3       	brcs	.-36     	; 0xf96 <__mulsf3+0x8>

00000fba <__mulsf3_pse>:
     fba:	95 9f       	mul	r25, r21
     fbc:	c1 f3       	breq	.-16     	; 0xfae <__mulsf3+0x20>
     fbe:	95 0f       	add	r25, r21
     fc0:	50 e0       	ldi	r21, 0x00	; 0
     fc2:	55 1f       	adc	r21, r21
     fc4:	62 9f       	mul	r22, r18
     fc6:	f0 01       	movw	r30, r0
     fc8:	72 9f       	mul	r23, r18
     fca:	bb 27       	eor	r27, r27
     fcc:	f0 0d       	add	r31, r0
     fce:	b1 1d       	adc	r27, r1
     fd0:	63 9f       	mul	r22, r19
     fd2:	aa 27       	eor	r26, r26
     fd4:	f0 0d       	add	r31, r0
     fd6:	b1 1d       	adc	r27, r1
     fd8:	aa 1f       	adc	r26, r26
     fda:	64 9f       	mul	r22, r20
     fdc:	66 27       	eor	r22, r22
     fde:	b0 0d       	add	r27, r0
     fe0:	a1 1d       	adc	r26, r1
     fe2:	66 1f       	adc	r22, r22
     fe4:	82 9f       	mul	r24, r18
     fe6:	22 27       	eor	r18, r18
     fe8:	b0 0d       	add	r27, r0
     fea:	a1 1d       	adc	r26, r1
     fec:	62 1f       	adc	r22, r18
     fee:	73 9f       	mul	r23, r19
     ff0:	b0 0d       	add	r27, r0
     ff2:	a1 1d       	adc	r26, r1
     ff4:	62 1f       	adc	r22, r18
     ff6:	83 9f       	mul	r24, r19
     ff8:	a0 0d       	add	r26, r0
     ffa:	61 1d       	adc	r22, r1
     ffc:	22 1f       	adc	r18, r18
     ffe:	74 9f       	mul	r23, r20
    1000:	33 27       	eor	r19, r19
    1002:	a0 0d       	add	r26, r0
    1004:	61 1d       	adc	r22, r1
    1006:	23 1f       	adc	r18, r19
    1008:	84 9f       	mul	r24, r20
    100a:	60 0d       	add	r22, r0
    100c:	21 1d       	adc	r18, r1
    100e:	82 2f       	mov	r24, r18
    1010:	76 2f       	mov	r23, r22
    1012:	6a 2f       	mov	r22, r26
    1014:	11 24       	eor	r1, r1
    1016:	9f 57       	subi	r25, 0x7F	; 127
    1018:	50 40       	sbci	r21, 0x00	; 0
    101a:	9a f0       	brmi	.+38     	; 0x1042 <__mulsf3_pse+0x88>
    101c:	f1 f0       	breq	.+60     	; 0x105a <__mulsf3_pse+0xa0>
    101e:	88 23       	and	r24, r24
    1020:	4a f0       	brmi	.+18     	; 0x1034 <__mulsf3_pse+0x7a>
    1022:	ee 0f       	add	r30, r30
    1024:	ff 1f       	adc	r31, r31
    1026:	bb 1f       	adc	r27, r27
    1028:	66 1f       	adc	r22, r22
    102a:	77 1f       	adc	r23, r23
    102c:	88 1f       	adc	r24, r24
    102e:	91 50       	subi	r25, 0x01	; 1
    1030:	50 40       	sbci	r21, 0x00	; 0
    1032:	a9 f7       	brne	.-22     	; 0x101e <__mulsf3_pse+0x64>
    1034:	9e 3f       	cpi	r25, 0xFE	; 254
    1036:	51 05       	cpc	r21, r1
    1038:	80 f0       	brcs	.+32     	; 0x105a <__mulsf3_pse+0xa0>
    103a:	0c 94 76 07 	jmp	0xeec	; 0xeec <__fp_inf>
    103e:	0c 94 c1 07 	jmp	0xf82	; 0xf82 <__fp_szero>
    1042:	5f 3f       	cpi	r21, 0xFF	; 255
    1044:	e4 f3       	brlt	.-8      	; 0x103e <__mulsf3_pse+0x84>
    1046:	98 3e       	cpi	r25, 0xE8	; 232
    1048:	d4 f3       	brlt	.-12     	; 0x103e <__mulsf3_pse+0x84>
    104a:	86 95       	lsr	r24
    104c:	77 95       	ror	r23
    104e:	67 95       	ror	r22
    1050:	b7 95       	ror	r27
    1052:	f7 95       	ror	r31
    1054:	e7 95       	ror	r30
    1056:	9f 5f       	subi	r25, 0xFF	; 255
    1058:	c1 f7       	brne	.-16     	; 0x104a <__mulsf3_pse+0x90>
    105a:	fe 2b       	or	r31, r30
    105c:	88 0f       	add	r24, r24
    105e:	91 1d       	adc	r25, r1
    1060:	96 95       	lsr	r25
    1062:	87 95       	ror	r24
    1064:	97 f9       	bld	r25, 7
    1066:	08 95       	ret

00001068 <__udivmodsi4>:
    1068:	a1 e2       	ldi	r26, 0x21	; 33
    106a:	1a 2e       	mov	r1, r26
    106c:	aa 1b       	sub	r26, r26
    106e:	bb 1b       	sub	r27, r27
    1070:	fd 01       	movw	r30, r26
    1072:	0d c0       	rjmp	.+26     	; 0x108e <__udivmodsi4_ep>

00001074 <__udivmodsi4_loop>:
    1074:	aa 1f       	adc	r26, r26
    1076:	bb 1f       	adc	r27, r27
    1078:	ee 1f       	adc	r30, r30
    107a:	ff 1f       	adc	r31, r31
    107c:	a2 17       	cp	r26, r18
    107e:	b3 07       	cpc	r27, r19
    1080:	e4 07       	cpc	r30, r20
    1082:	f5 07       	cpc	r31, r21
    1084:	20 f0       	brcs	.+8      	; 0x108e <__udivmodsi4_ep>
    1086:	a2 1b       	sub	r26, r18
    1088:	b3 0b       	sbc	r27, r19
    108a:	e4 0b       	sbc	r30, r20
    108c:	f5 0b       	sbc	r31, r21

0000108e <__udivmodsi4_ep>:
    108e:	66 1f       	adc	r22, r22
    1090:	77 1f       	adc	r23, r23
    1092:	88 1f       	adc	r24, r24
    1094:	99 1f       	adc	r25, r25
    1096:	1a 94       	dec	r1
    1098:	69 f7       	brne	.-38     	; 0x1074 <__udivmodsi4_loop>
    109a:	60 95       	com	r22
    109c:	70 95       	com	r23
    109e:	80 95       	com	r24
    10a0:	90 95       	com	r25
    10a2:	9b 01       	movw	r18, r22
    10a4:	ac 01       	movw	r20, r24
    10a6:	bd 01       	movw	r22, r26
    10a8:	cf 01       	movw	r24, r30
    10aa:	08 95       	ret

000010ac <_exit>:
    10ac:	f8 94       	cli

000010ae <__stop_program>:
    10ae:	ff cf       	rjmp	.-2      	; 0x10ae <__stop_program>
