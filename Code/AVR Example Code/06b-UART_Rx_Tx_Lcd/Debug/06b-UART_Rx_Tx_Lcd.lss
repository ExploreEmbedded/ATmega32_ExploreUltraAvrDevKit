
06b-UART_Rx_Tx_Lcd.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000081e  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000024  00800060  0000081e  000008b2  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000010  00800084  00800084  000008d6  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000008d6  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00000908  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000180  00000000  00000000  00000944  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00001d44  00000000  00000000  00000ac4  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000812  00000000  00000000  00002808  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000008bc  00000000  00000000  0000301a  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000004fc  00000000  00000000  000038d8  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000078b  00000000  00000000  00003dd4  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00002184  00000000  00000000  0000455f  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000178  00000000  00000000  000066e3  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
   4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
   8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
   c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  1c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
  54:	11 24       	eor	r1, r1
  56:	1f be       	out	0x3f, r1	; 63
  58:	cf e5       	ldi	r28, 0x5F	; 95
  5a:	d8 e0       	ldi	r29, 0x08	; 8
  5c:	de bf       	out	0x3e, r29	; 62
  5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
  60:	10 e0       	ldi	r17, 0x00	; 0
  62:	a0 e6       	ldi	r26, 0x60	; 96
  64:	b0 e0       	ldi	r27, 0x00	; 0
  66:	ee e1       	ldi	r30, 0x1E	; 30
  68:	f8 e0       	ldi	r31, 0x08	; 8
  6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
  6c:	05 90       	lpm	r0, Z+
  6e:	0d 92       	st	X+, r0
  70:	a4 38       	cpi	r26, 0x84	; 132
  72:	b1 07       	cpc	r27, r17
  74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
  76:	20 e0       	ldi	r18, 0x00	; 0
  78:	a4 e8       	ldi	r26, 0x84	; 132
  7a:	b0 e0       	ldi	r27, 0x00	; 0
  7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
  7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
  80:	a4 39       	cpi	r26, 0x94	; 148
  82:	b2 07       	cpc	r27, r18
  84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
  86:	0e 94 9a 03 	call	0x734	; 0x734 <main>
  8a:	0c 94 0d 04 	jmp	0x81a	; 0x81a <_exit>

0000008e <__bad_interrupt>:
  8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <DELAY_us>:
         if 5000 is passed as the argument then it generates a delay of 5ms.		  

 ***************************************************************************************************/
void DELAY_us(uint16_t us_count) 
{
    while (us_count != 0) 
  92:	00 97       	sbiw	r24, 0x00	; 0
  94:	31 f0       	breq	.+12     	; 0xa2 <DELAY_us+0x10>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
  96:	25 e0       	ldi	r18, 0x05	; 5
  98:	2a 95       	dec	r18
  9a:	f1 f7       	brne	.-4      	; 0x98 <DELAY_us+0x6>
  9c:	00 00       	nop
    {
        _delay_us(1);
		us_count--;
  9e:	01 97       	sbiw	r24, 0x01	; 1
  a0:	f8 cf       	rjmp	.-16     	; 0x92 <DELAY_us>
    }
}
  a2:	08 95       	ret

000000a4 <DELAY_ms>:
     It generates a delay of 1ms for each count,
     if 1000 is passed as the argument then it generates delay of 1000ms(1sec)
 ***************************************************************************************************/
void DELAY_ms(uint16_t ms_count) 
{
    while (ms_count != 0) 
  a4:	00 97       	sbiw	r24, 0x00	; 0
  a6:	41 f0       	breq	.+16     	; 0xb8 <DELAY_ms+0x14>
  a8:	ef e9       	ldi	r30, 0x9F	; 159
  aa:	ff e0       	ldi	r31, 0x0F	; 15
  ac:	31 97       	sbiw	r30, 0x01	; 1
  ae:	f1 f7       	brne	.-4      	; 0xac <DELAY_ms+0x8>
  b0:	00 c0       	rjmp	.+0      	; 0xb2 <DELAY_ms+0xe>
  b2:	00 00       	nop
    {
        _delay_us(1000); //DELAY_us is called to generate 1ms delay
        ms_count--;
  b4:	01 97       	sbiw	r24, 0x01	; 1
  b6:	f6 cf       	rjmp	.-20     	; 0xa4 <DELAY_ms>
    }
}
  b8:	08 95       	ret

000000ba <GPIO_PinDirection>:

    uint8_t v_portNumber_u8;


    v_portNumber_u8 =  (enm_pinNumber>>3);  // Divide the pin number by 8 go get the PORT number
    enm_pinNumber  =   enm_pinNumber & 0x07;  // lower 3-bits contains the bit number of a byte 
  ba:	98 2f       	mov	r25, r24
  bc:	97 70       	andi	r25, 0x07	; 7
{

    uint8_t v_portNumber_u8;


    v_portNumber_u8 =  (enm_pinNumber>>3);  // Divide the pin number by 8 go get the PORT number
  be:	86 95       	lsr	r24
  c0:	86 95       	lsr	r24
  c2:	86 95       	lsr	r24
    enm_pinNumber  =   enm_pinNumber & 0x07;  // lower 3-bits contains the bit number of a byte 

    /* Go to particular port after decoding from the pin number and 
        set the direction as specified*/
    switch(v_portNumber_u8)
  c4:	81 30       	cpi	r24, 0x01	; 1
  c6:	01 f1       	breq	.+64     	; 0x108 <GPIO_PinDirection+0x4e>
  c8:	30 f0       	brcs	.+12     	; 0xd6 <GPIO_PinDirection+0x1c>
  ca:	82 30       	cpi	r24, 0x02	; 2
  cc:	b1 f1       	breq	.+108    	; 0x13a <GPIO_PinDirection+0x80>
  ce:	83 30       	cpi	r24, 0x03	; 3
  d0:	09 f4       	brne	.+2      	; 0xd4 <GPIO_PinDirection+0x1a>
  d2:	4c c0       	rjmp	.+152    	; 0x16c <GPIO_PinDirection+0xb2>
  d4:	08 95       	ret
    {
#ifdef DDRA        
    case 0:
        util_UpdateBit(DDRA,enm_pinNumber,v_pinDirn_u8);
  d6:	4a b3       	in	r20, 0x1a	; 26
  d8:	21 e0       	ldi	r18, 0x01	; 1
  da:	30 e0       	ldi	r19, 0x00	; 0
  dc:	66 23       	and	r22, r22
  de:	49 f0       	breq	.+18     	; 0xf2 <GPIO_PinDirection+0x38>
  e0:	b9 01       	movw	r22, r18
  e2:	02 c0       	rjmp	.+4      	; 0xe8 <GPIO_PinDirection+0x2e>
  e4:	66 0f       	add	r22, r22
  e6:	77 1f       	adc	r23, r23
  e8:	9a 95       	dec	r25
  ea:	e2 f7       	brpl	.-8      	; 0xe4 <GPIO_PinDirection+0x2a>
  ec:	cb 01       	movw	r24, r22
  ee:	84 2b       	or	r24, r20
  f0:	09 c0       	rjmp	.+18     	; 0x104 <GPIO_PinDirection+0x4a>
  f2:	b9 01       	movw	r22, r18
  f4:	02 c0       	rjmp	.+4      	; 0xfa <GPIO_PinDirection+0x40>
  f6:	66 0f       	add	r22, r22
  f8:	77 1f       	adc	r23, r23
  fa:	9a 95       	dec	r25
  fc:	e2 f7       	brpl	.-8      	; 0xf6 <GPIO_PinDirection+0x3c>
  fe:	cb 01       	movw	r24, r22
 100:	80 95       	com	r24
 102:	84 23       	and	r24, r20
 104:	8a bb       	out	0x1a, r24	; 26
 106:	08 95       	ret
#endif        


#ifdef DDRB
    case 1:
        util_UpdateBit(DDRB,enm_pinNumber,v_pinDirn_u8);
 108:	47 b3       	in	r20, 0x17	; 23
 10a:	21 e0       	ldi	r18, 0x01	; 1
 10c:	30 e0       	ldi	r19, 0x00	; 0
 10e:	66 23       	and	r22, r22
 110:	49 f0       	breq	.+18     	; 0x124 <GPIO_PinDirection+0x6a>
 112:	b9 01       	movw	r22, r18
 114:	02 c0       	rjmp	.+4      	; 0x11a <GPIO_PinDirection+0x60>
 116:	66 0f       	add	r22, r22
 118:	77 1f       	adc	r23, r23
 11a:	9a 95       	dec	r25
 11c:	e2 f7       	brpl	.-8      	; 0x116 <GPIO_PinDirection+0x5c>
 11e:	cb 01       	movw	r24, r22
 120:	84 2b       	or	r24, r20
 122:	09 c0       	rjmp	.+18     	; 0x136 <GPIO_PinDirection+0x7c>
 124:	b9 01       	movw	r22, r18
 126:	02 c0       	rjmp	.+4      	; 0x12c <GPIO_PinDirection+0x72>
 128:	66 0f       	add	r22, r22
 12a:	77 1f       	adc	r23, r23
 12c:	9a 95       	dec	r25
 12e:	e2 f7       	brpl	.-8      	; 0x128 <GPIO_PinDirection+0x6e>
 130:	cb 01       	movw	r24, r22
 132:	80 95       	com	r24
 134:	84 23       	and	r24, r20
 136:	87 bb       	out	0x17, r24	; 23
 138:	08 95       	ret
#endif 

        
#ifdef DDRC
    case 2:
        util_UpdateBit(DDRC,enm_pinNumber,v_pinDirn_u8);
 13a:	44 b3       	in	r20, 0x14	; 20
 13c:	21 e0       	ldi	r18, 0x01	; 1
 13e:	30 e0       	ldi	r19, 0x00	; 0
 140:	66 23       	and	r22, r22
 142:	49 f0       	breq	.+18     	; 0x156 <GPIO_PinDirection+0x9c>
 144:	b9 01       	movw	r22, r18
 146:	02 c0       	rjmp	.+4      	; 0x14c <GPIO_PinDirection+0x92>
 148:	66 0f       	add	r22, r22
 14a:	77 1f       	adc	r23, r23
 14c:	9a 95       	dec	r25
 14e:	e2 f7       	brpl	.-8      	; 0x148 <GPIO_PinDirection+0x8e>
 150:	cb 01       	movw	r24, r22
 152:	84 2b       	or	r24, r20
 154:	09 c0       	rjmp	.+18     	; 0x168 <GPIO_PinDirection+0xae>
 156:	b9 01       	movw	r22, r18
 158:	02 c0       	rjmp	.+4      	; 0x15e <GPIO_PinDirection+0xa4>
 15a:	66 0f       	add	r22, r22
 15c:	77 1f       	adc	r23, r23
 15e:	9a 95       	dec	r25
 160:	e2 f7       	brpl	.-8      	; 0x15a <GPIO_PinDirection+0xa0>
 162:	cb 01       	movw	r24, r22
 164:	80 95       	com	r24
 166:	84 23       	and	r24, r20
 168:	84 bb       	out	0x14, r24	; 20
 16a:	08 95       	ret
#endif 

        
#ifdef DDRD        
    case 3:
        util_UpdateBit(DDRD,enm_pinNumber,v_pinDirn_u8);
 16c:	41 b3       	in	r20, 0x11	; 17
 16e:	21 e0       	ldi	r18, 0x01	; 1
 170:	30 e0       	ldi	r19, 0x00	; 0
 172:	66 23       	and	r22, r22
 174:	49 f0       	breq	.+18     	; 0x188 <GPIO_PinDirection+0xce>
 176:	b9 01       	movw	r22, r18
 178:	02 c0       	rjmp	.+4      	; 0x17e <GPIO_PinDirection+0xc4>
 17a:	66 0f       	add	r22, r22
 17c:	77 1f       	adc	r23, r23
 17e:	9a 95       	dec	r25
 180:	e2 f7       	brpl	.-8      	; 0x17a <GPIO_PinDirection+0xc0>
 182:	cb 01       	movw	r24, r22
 184:	84 2b       	or	r24, r20
 186:	09 c0       	rjmp	.+18     	; 0x19a <GPIO_PinDirection+0xe0>
 188:	b9 01       	movw	r22, r18
 18a:	02 c0       	rjmp	.+4      	; 0x190 <GPIO_PinDirection+0xd6>
 18c:	66 0f       	add	r22, r22
 18e:	77 1f       	adc	r23, r23
 190:	9a 95       	dec	r25
 192:	e2 f7       	brpl	.-8      	; 0x18c <GPIO_PinDirection+0xd2>
 194:	cb 01       	movw	r24, r22
 196:	80 95       	com	r24
 198:	84 23       	and	r24, r20
 19a:	81 bb       	out	0x11, r24	; 17
 19c:	08 95       	ret

0000019e <GPIO_PinWrite>:

    uint8_t v_portNumber_u8;


    v_portNumber_u8 =  (enm_pinNumber>>3);  // Divide the pin number by 8 go get the PORT number
    enm_pinNumber  =   enm_pinNumber & 0x07;  // lower 3-bits contains the bit number of a byte 
 19e:	98 2f       	mov	r25, r24
 1a0:	97 70       	andi	r25, 0x07	; 7
{

    uint8_t v_portNumber_u8;


    v_portNumber_u8 =  (enm_pinNumber>>3);  // Divide the pin number by 8 go get the PORT number
 1a2:	86 95       	lsr	r24
 1a4:	86 95       	lsr	r24
 1a6:	86 95       	lsr	r24
    enm_pinNumber  =   enm_pinNumber & 0x07;  // lower 3-bits contains the bit number of a byte 

    /* Go to particular port after decoding from the pin number and 
        update the value of the specified pin*/
    switch(v_portNumber_u8)
 1a8:	81 30       	cpi	r24, 0x01	; 1
 1aa:	01 f1       	breq	.+64     	; 0x1ec <GPIO_PinWrite+0x4e>
 1ac:	30 f0       	brcs	.+12     	; 0x1ba <GPIO_PinWrite+0x1c>
 1ae:	82 30       	cpi	r24, 0x02	; 2
 1b0:	b1 f1       	breq	.+108    	; 0x21e <GPIO_PinWrite+0x80>
 1b2:	83 30       	cpi	r24, 0x03	; 3
 1b4:	09 f4       	brne	.+2      	; 0x1b8 <GPIO_PinWrite+0x1a>
 1b6:	4c c0       	rjmp	.+152    	; 0x250 <GPIO_PinWrite+0xb2>
 1b8:	08 95       	ret
    {
#ifdef PORTA        
    case 0:
        util_UpdateBit(PORTA,enm_pinNumber,v_pinValue_u8);
 1ba:	4b b3       	in	r20, 0x1b	; 27
 1bc:	21 e0       	ldi	r18, 0x01	; 1
 1be:	30 e0       	ldi	r19, 0x00	; 0
 1c0:	66 23       	and	r22, r22
 1c2:	49 f0       	breq	.+18     	; 0x1d6 <GPIO_PinWrite+0x38>
 1c4:	b9 01       	movw	r22, r18
 1c6:	02 c0       	rjmp	.+4      	; 0x1cc <GPIO_PinWrite+0x2e>
 1c8:	66 0f       	add	r22, r22
 1ca:	77 1f       	adc	r23, r23
 1cc:	9a 95       	dec	r25
 1ce:	e2 f7       	brpl	.-8      	; 0x1c8 <GPIO_PinWrite+0x2a>
 1d0:	cb 01       	movw	r24, r22
 1d2:	84 2b       	or	r24, r20
 1d4:	09 c0       	rjmp	.+18     	; 0x1e8 <GPIO_PinWrite+0x4a>
 1d6:	b9 01       	movw	r22, r18
 1d8:	02 c0       	rjmp	.+4      	; 0x1de <GPIO_PinWrite+0x40>
 1da:	66 0f       	add	r22, r22
 1dc:	77 1f       	adc	r23, r23
 1de:	9a 95       	dec	r25
 1e0:	e2 f7       	brpl	.-8      	; 0x1da <GPIO_PinWrite+0x3c>
 1e2:	cb 01       	movw	r24, r22
 1e4:	80 95       	com	r24
 1e6:	84 23       	and	r24, r20
 1e8:	8b bb       	out	0x1b, r24	; 27
 1ea:	08 95       	ret
#endif        

        
#ifdef PORTB
    case 1:
        util_UpdateBit(PORTB,enm_pinNumber,v_pinValue_u8);
 1ec:	48 b3       	in	r20, 0x18	; 24
 1ee:	21 e0       	ldi	r18, 0x01	; 1
 1f0:	30 e0       	ldi	r19, 0x00	; 0
 1f2:	66 23       	and	r22, r22
 1f4:	49 f0       	breq	.+18     	; 0x208 <GPIO_PinWrite+0x6a>
 1f6:	b9 01       	movw	r22, r18
 1f8:	02 c0       	rjmp	.+4      	; 0x1fe <GPIO_PinWrite+0x60>
 1fa:	66 0f       	add	r22, r22
 1fc:	77 1f       	adc	r23, r23
 1fe:	9a 95       	dec	r25
 200:	e2 f7       	brpl	.-8      	; 0x1fa <GPIO_PinWrite+0x5c>
 202:	cb 01       	movw	r24, r22
 204:	84 2b       	or	r24, r20
 206:	09 c0       	rjmp	.+18     	; 0x21a <GPIO_PinWrite+0x7c>
 208:	b9 01       	movw	r22, r18
 20a:	02 c0       	rjmp	.+4      	; 0x210 <GPIO_PinWrite+0x72>
 20c:	66 0f       	add	r22, r22
 20e:	77 1f       	adc	r23, r23
 210:	9a 95       	dec	r25
 212:	e2 f7       	brpl	.-8      	; 0x20c <GPIO_PinWrite+0x6e>
 214:	cb 01       	movw	r24, r22
 216:	80 95       	com	r24
 218:	84 23       	and	r24, r20
 21a:	88 bb       	out	0x18, r24	; 24
 21c:	08 95       	ret
#endif        

        
#ifdef PORTC        
    case 2:
        util_UpdateBit(PORTC,enm_pinNumber,v_pinValue_u8);
 21e:	45 b3       	in	r20, 0x15	; 21
 220:	21 e0       	ldi	r18, 0x01	; 1
 222:	30 e0       	ldi	r19, 0x00	; 0
 224:	66 23       	and	r22, r22
 226:	49 f0       	breq	.+18     	; 0x23a <GPIO_PinWrite+0x9c>
 228:	b9 01       	movw	r22, r18
 22a:	02 c0       	rjmp	.+4      	; 0x230 <GPIO_PinWrite+0x92>
 22c:	66 0f       	add	r22, r22
 22e:	77 1f       	adc	r23, r23
 230:	9a 95       	dec	r25
 232:	e2 f7       	brpl	.-8      	; 0x22c <GPIO_PinWrite+0x8e>
 234:	cb 01       	movw	r24, r22
 236:	84 2b       	or	r24, r20
 238:	09 c0       	rjmp	.+18     	; 0x24c <GPIO_PinWrite+0xae>
 23a:	b9 01       	movw	r22, r18
 23c:	02 c0       	rjmp	.+4      	; 0x242 <GPIO_PinWrite+0xa4>
 23e:	66 0f       	add	r22, r22
 240:	77 1f       	adc	r23, r23
 242:	9a 95       	dec	r25
 244:	e2 f7       	brpl	.-8      	; 0x23e <GPIO_PinWrite+0xa0>
 246:	cb 01       	movw	r24, r22
 248:	80 95       	com	r24
 24a:	84 23       	and	r24, r20
 24c:	85 bb       	out	0x15, r24	; 21
 24e:	08 95       	ret
#endif        

        
#ifdef PORTD        
    case 3:
        util_UpdateBit(PORTD,enm_pinNumber,v_pinValue_u8);
 250:	42 b3       	in	r20, 0x12	; 18
 252:	21 e0       	ldi	r18, 0x01	; 1
 254:	30 e0       	ldi	r19, 0x00	; 0
 256:	66 23       	and	r22, r22
 258:	49 f0       	breq	.+18     	; 0x26c <GPIO_PinWrite+0xce>
 25a:	b9 01       	movw	r22, r18
 25c:	02 c0       	rjmp	.+4      	; 0x262 <GPIO_PinWrite+0xc4>
 25e:	66 0f       	add	r22, r22
 260:	77 1f       	adc	r23, r23
 262:	9a 95       	dec	r25
 264:	e2 f7       	brpl	.-8      	; 0x25e <GPIO_PinWrite+0xc0>
 266:	cb 01       	movw	r24, r22
 268:	84 2b       	or	r24, r20
 26a:	09 c0       	rjmp	.+18     	; 0x27e <GPIO_PinWrite+0xe0>
 26c:	b9 01       	movw	r22, r18
 26e:	02 c0       	rjmp	.+4      	; 0x274 <GPIO_PinWrite+0xd6>
 270:	66 0f       	add	r22, r22
 272:	77 1f       	adc	r23, r23
 274:	9a 95       	dec	r25
 276:	e2 f7       	brpl	.-8      	; 0x270 <GPIO_PinWrite+0xd2>
 278:	cb 01       	movw	r24, r22
 27a:	80 95       	com	r24
 27c:	84 23       	and	r24, r20
 27e:	82 bb       	out	0x12, r24	; 18
 280:	08 95       	ret

00000282 <GPIO_PinRead>:
{
    uint8_t v_portNumber_u8;
    uint8_t returnStatus = 0;

    v_portNumber_u8 =  (enm_pinNumber>>3); // Divide the pin number by 8 go get the PORT number
    enm_pinNumber  =     enm_pinNumber & 0x07; // lower 3-bits contains the bit number of a byte 
 282:	28 2f       	mov	r18, r24
 284:	27 70       	andi	r18, 0x07	; 7
uint8_t GPIO_PinRead(gpioPins_et enm_pinNumber)
{
    uint8_t v_portNumber_u8;
    uint8_t returnStatus = 0;

    v_portNumber_u8 =  (enm_pinNumber>>3); // Divide the pin number by 8 go get the PORT number
 286:	86 95       	lsr	r24
 288:	86 95       	lsr	r24
 28a:	86 95       	lsr	r24
    enm_pinNumber  =     enm_pinNumber & 0x07; // lower 3-bits contains the bit number of a byte 

    /* Go to particular port after decoding from the pin number and read the pins status */
    switch(v_portNumber_u8)     
 28c:	81 30       	cpi	r24, 0x01	; 1
 28e:	49 f0       	breq	.+18     	; 0x2a2 <GPIO_PinRead+0x20>
 290:	30 f0       	brcs	.+12     	; 0x29e <GPIO_PinRead+0x1c>
 292:	82 30       	cpi	r24, 0x02	; 2
 294:	41 f0       	breq	.+16     	; 0x2a6 <GPIO_PinRead+0x24>
 296:	83 30       	cpi	r24, 0x03	; 3
 298:	79 f4       	brne	.+30     	; 0x2b8 <GPIO_PinRead+0x36>
#endif        
        
        
#ifdef PIND
    case 3:
        returnStatus = util_IsBitSet(PIND,enm_pinNumber);
 29a:	80 b3       	in	r24, 0x10	; 16
 29c:	05 c0       	rjmp	.+10     	; 0x2a8 <GPIO_PinRead+0x26>
    /* Go to particular port after decoding from the pin number and read the pins status */
    switch(v_portNumber_u8)     
    { 
#ifdef PINA    
    case 0: 
        returnStatus = util_IsBitSet(PINA,enm_pinNumber);
 29e:	89 b3       	in	r24, 0x19	; 25
 2a0:	03 c0       	rjmp	.+6      	; 0x2a8 <GPIO_PinRead+0x26>
        break;
#endif        

#ifdef PINB
    case 1:
        returnStatus = util_IsBitSet(PINB,enm_pinNumber);
 2a2:	86 b3       	in	r24, 0x16	; 22
 2a4:	01 c0       	rjmp	.+2      	; 0x2a8 <GPIO_PinRead+0x26>
        break;
#endif          

#ifdef PINC
    case 2:
        returnStatus = util_IsBitSet(PINC,enm_pinNumber);
 2a6:	83 b3       	in	r24, 0x13	; 19
#endif        
        
        
#ifdef PIND
    case 3:
        returnStatus = util_IsBitSet(PIND,enm_pinNumber);
 2a8:	90 e0       	ldi	r25, 0x00	; 0
 2aa:	02 c0       	rjmp	.+4      	; 0x2b0 <GPIO_PinRead+0x2e>
 2ac:	95 95       	asr	r25
 2ae:	87 95       	ror	r24
 2b0:	2a 95       	dec	r18
 2b2:	e2 f7       	brpl	.-8      	; 0x2ac <GPIO_PinRead+0x2a>
 2b4:	81 70       	andi	r24, 0x01	; 1
        break;
 2b6:	08 95       	ret
                Before reading the pins status, the pin should be configured as INPUT 
 ***************************************************************************************************/
uint8_t GPIO_PinRead(gpioPins_et enm_pinNumber)
{
    uint8_t v_portNumber_u8;
    uint8_t returnStatus = 0;
 2b8:	80 e0       	ldi	r24, 0x00	; 0
        returnStatus = util_IsBitSet(PING,enm_pinNumber);
        break;
#endif             
    }                         
    return returnStatus;
}
 2ba:	08 95       	ret

000002bc <lcd_SendHigherNibble>:
 * Return value    : none

 * description : This functions is used to send the higher nibble of the data to LCD in 4-bit mode
**************************************************************************************************/
static void lcd_SendHigherNibble(uint8_t dataByte)
{
 2bc:	0f 93       	push	r16
 2be:	1f 93       	push	r17
 2c0:	cf 93       	push	r28
 2c2:	c8 2f       	mov	r28, r24
    GPIO_PinWrite(LCDConfig.D4,util_IsBitSet(dataByte,4));
 2c4:	84 fb       	bst	r24, 4
 2c6:	66 27       	eor	r22, r22
 2c8:	60 f9       	bld	r22, 0
 2ca:	04 e8       	ldi	r16, 0x84	; 132
 2cc:	10 e0       	ldi	r17, 0x00	; 0
 2ce:	f8 01       	movw	r30, r16
 2d0:	82 85       	ldd	r24, Z+10	; 0x0a
 2d2:	0e 94 cf 00 	call	0x19e	; 0x19e <GPIO_PinWrite>
    GPIO_PinWrite(LCDConfig.D5,util_IsBitSet(dataByte,5));
 2d6:	c5 fb       	bst	r28, 5
 2d8:	66 27       	eor	r22, r22
 2da:	60 f9       	bld	r22, 0
 2dc:	f8 01       	movw	r30, r16
 2de:	83 85       	ldd	r24, Z+11	; 0x0b
 2e0:	0e 94 cf 00 	call	0x19e	; 0x19e <GPIO_PinWrite>
    GPIO_PinWrite(LCDConfig.D6,util_IsBitSet(dataByte,6));
 2e4:	c6 fb       	bst	r28, 6
 2e6:	66 27       	eor	r22, r22
 2e8:	60 f9       	bld	r22, 0
 2ea:	f8 01       	movw	r30, r16
 2ec:	84 85       	ldd	r24, Z+12	; 0x0c
 2ee:	0e 94 cf 00 	call	0x19e	; 0x19e <GPIO_PinWrite>
    GPIO_PinWrite(LCDConfig.D7,util_IsBitSet(dataByte,7));
 2f2:	6c 2f       	mov	r22, r28
 2f4:	66 1f       	adc	r22, r22
 2f6:	66 27       	eor	r22, r22
 2f8:	66 1f       	adc	r22, r22
 2fa:	f8 01       	movw	r30, r16
 2fc:	85 85       	ldd	r24, Z+13	; 0x0d
}
 2fe:	cf 91       	pop	r28
 300:	1f 91       	pop	r17
 302:	0f 91       	pop	r16
static void lcd_SendHigherNibble(uint8_t dataByte)
{
    GPIO_PinWrite(LCDConfig.D4,util_IsBitSet(dataByte,4));
    GPIO_PinWrite(LCDConfig.D5,util_IsBitSet(dataByte,5));
    GPIO_PinWrite(LCDConfig.D6,util_IsBitSet(dataByte,6));
    GPIO_PinWrite(LCDConfig.D7,util_IsBitSet(dataByte,7));
 304:	0c 94 cf 00 	jmp	0x19e	; 0x19e <GPIO_PinWrite>

00000308 <lcd_SendCmdSignals>:
 * Return value    : none

 * description : This functions generates the signals for sending the v_lcdCmd_u8 to LCD
**************************************************************************************************/
static void lcd_SendCmdSignals(void)
{
 308:	cf 93       	push	r28
 30a:	df 93       	push	r29
     GPIO_PinWrite(LCDConfig.RS,0);
 30c:	c4 e8       	ldi	r28, 0x84	; 132
 30e:	d0 e0       	ldi	r29, 0x00	; 0
 310:	60 e0       	ldi	r22, 0x00	; 0
 312:	8b 81       	ldd	r24, Y+3	; 0x03
 314:	0e 94 cf 00 	call	0x19e	; 0x19e <GPIO_PinWrite>
     GPIO_PinWrite(LCDConfig.RW,0);
 318:	60 e0       	ldi	r22, 0x00	; 0
 31a:	8c 81       	ldd	r24, Y+4	; 0x04
 31c:	0e 94 cf 00 	call	0x19e	; 0x19e <GPIO_PinWrite>
     GPIO_PinWrite(LCDConfig.EN,1);
 320:	61 e0       	ldi	r22, 0x01	; 1
 322:	8d 81       	ldd	r24, Y+5	; 0x05
 324:	0e 94 cf 00 	call	0x19e	; 0x19e <GPIO_PinWrite>
     DELAY_us(10);
 328:	8a e0       	ldi	r24, 0x0A	; 10
 32a:	90 e0       	ldi	r25, 0x00	; 0
 32c:	0e 94 49 00 	call	0x92	; 0x92 <DELAY_us>
     GPIO_PinWrite(LCDConfig.EN,0);
 330:	60 e0       	ldi	r22, 0x00	; 0
 332:	8d 81       	ldd	r24, Y+5	; 0x05
  
}
 334:	df 91       	pop	r29
 336:	cf 91       	pop	r28
{
     GPIO_PinWrite(LCDConfig.RS,0);
     GPIO_PinWrite(LCDConfig.RW,0);
     GPIO_PinWrite(LCDConfig.EN,1);
     DELAY_us(10);
     GPIO_PinWrite(LCDConfig.EN,0);
 338:	0c 94 cf 00 	jmp	0x19e	; 0x19e <GPIO_PinWrite>

0000033c <lcd_SendLowerNibble>:
 * Return value    : none

 * description : This functions is used to send the lower nibble of the data to LCD
**************************************************************************************************/
static void lcd_SendLowerNibble(uint8_t dataByte)
{
 33c:	0f 93       	push	r16
 33e:	1f 93       	push	r17
 340:	cf 93       	push	r28
 342:	c8 2f       	mov	r28, r24
    GPIO_PinWrite(LCDConfig.D0,util_IsBitSet(dataByte,0));
 344:	68 2f       	mov	r22, r24
 346:	61 70       	andi	r22, 0x01	; 1
 348:	04 e8       	ldi	r16, 0x84	; 132
 34a:	10 e0       	ldi	r17, 0x00	; 0
 34c:	f8 01       	movw	r30, r16
 34e:	86 81       	ldd	r24, Z+6	; 0x06
 350:	0e 94 cf 00 	call	0x19e	; 0x19e <GPIO_PinWrite>
    GPIO_PinWrite(LCDConfig.D1,util_IsBitSet(dataByte,1));
 354:	c1 fb       	bst	r28, 1
 356:	66 27       	eor	r22, r22
 358:	60 f9       	bld	r22, 0
 35a:	f8 01       	movw	r30, r16
 35c:	87 81       	ldd	r24, Z+7	; 0x07
 35e:	0e 94 cf 00 	call	0x19e	; 0x19e <GPIO_PinWrite>
    GPIO_PinWrite(LCDConfig.D2,util_IsBitSet(dataByte,2));
 362:	c2 fb       	bst	r28, 2
 364:	66 27       	eor	r22, r22
 366:	60 f9       	bld	r22, 0
 368:	f8 01       	movw	r30, r16
 36a:	80 85       	ldd	r24, Z+8	; 0x08
 36c:	0e 94 cf 00 	call	0x19e	; 0x19e <GPIO_PinWrite>
    GPIO_PinWrite(LCDConfig.D3,util_IsBitSet(dataByte,3));
 370:	c3 fb       	bst	r28, 3
 372:	66 27       	eor	r22, r22
 374:	60 f9       	bld	r22, 0
 376:	f8 01       	movw	r30, r16
 378:	81 85       	ldd	r24, Z+9	; 0x09
}
 37a:	cf 91       	pop	r28
 37c:	1f 91       	pop	r17
 37e:	0f 91       	pop	r16
static void lcd_SendLowerNibble(uint8_t dataByte)
{
    GPIO_PinWrite(LCDConfig.D0,util_IsBitSet(dataByte,0));
    GPIO_PinWrite(LCDConfig.D1,util_IsBitSet(dataByte,1));
    GPIO_PinWrite(LCDConfig.D2,util_IsBitSet(dataByte,2));
    GPIO_PinWrite(LCDConfig.D3,util_IsBitSet(dataByte,3));
 380:	0c 94 cf 00 	jmp	0x19e	; 0x19e <GPIO_PinWrite>

00000384 <lcd_SendDataSignals>:
 * Return value    : none

 * description : This functions generates the signals for sending the Data to LCD
**************************************************************************************************/
static void lcd_SendDataSignals(void)
{
 384:	cf 93       	push	r28
 386:	df 93       	push	r29
     GPIO_PinWrite(LCDConfig.RS,1);
 388:	c4 e8       	ldi	r28, 0x84	; 132
 38a:	d0 e0       	ldi	r29, 0x00	; 0
 38c:	61 e0       	ldi	r22, 0x01	; 1
 38e:	8b 81       	ldd	r24, Y+3	; 0x03
 390:	0e 94 cf 00 	call	0x19e	; 0x19e <GPIO_PinWrite>
     GPIO_PinWrite(LCDConfig.RW,0);
 394:	60 e0       	ldi	r22, 0x00	; 0
 396:	8c 81       	ldd	r24, Y+4	; 0x04
 398:	0e 94 cf 00 	call	0x19e	; 0x19e <GPIO_PinWrite>
     GPIO_PinWrite(LCDConfig.EN,1);
 39c:	61 e0       	ldi	r22, 0x01	; 1
 39e:	8d 81       	ldd	r24, Y+5	; 0x05
 3a0:	0e 94 cf 00 	call	0x19e	; 0x19e <GPIO_PinWrite>
     DELAY_us(10);
 3a4:	8a e0       	ldi	r24, 0x0A	; 10
 3a6:	90 e0       	ldi	r25, 0x00	; 0
 3a8:	0e 94 49 00 	call	0x92	; 0x92 <DELAY_us>
     GPIO_PinWrite(LCDConfig.EN,0);
 3ac:	60 e0       	ldi	r22, 0x00	; 0
 3ae:	8d 81       	ldd	r24, Y+5	; 0x05
}
 3b0:	df 91       	pop	r29
 3b2:	cf 91       	pop	r28
{
     GPIO_PinWrite(LCDConfig.RS,1);
     GPIO_PinWrite(LCDConfig.RW,0);
     GPIO_PinWrite(LCDConfig.EN,1);
     DELAY_us(10);
     GPIO_PinWrite(LCDConfig.EN,0);
 3b4:	0c 94 cf 00 	jmp	0x19e	; 0x19e <GPIO_PinWrite>

000003b8 <lcd_BusyCheck>:
 * description : This functions is used check whether LCD is busy.
                 It waits till the LCD is busy by polling the LCD busy flag.
                 After completing the previous operation, LCDs clears its internal busy flag.
**************************************************************************************************/
static void lcd_BusyCheck(void)
{
 3b8:	cf 93       	push	r28
    uint8_t busyflag;
 
  if(LCDConfig.RW != P_NC)                         //Perform Busy check if RW pin is used
 3ba:	80 91 88 00 	lds	r24, 0x0088
 3be:	8f 3f       	cpi	r24, 0xFF	; 255
 3c0:	09 f4       	brne	.+2      	; 0x3c4 <lcd_BusyCheck+0xc>
 3c2:	44 c0       	rjmp	.+136    	; 0x44c <lcd_BusyCheck+0x94>
   {
    GPIO_PinDirection(LCDConfig.D7,INPUT); // Configure busy pin as input
 3c4:	60 e0       	ldi	r22, 0x00	; 0
 3c6:	80 91 91 00 	lds	r24, 0x0091
 3ca:	0e 94 5d 00 	call	0xba	; 0xba <GPIO_PinDirection>
    GPIO_PinWrite(LCDConfig.RS,0);           // Select the Command Register by pulling RS LOW
 3ce:	60 e0       	ldi	r22, 0x00	; 0
 3d0:	80 91 87 00 	lds	r24, 0x0087
 3d4:	0e 94 cf 00 	call	0x19e	; 0x19e <GPIO_PinWrite>
    GPIO_PinWrite(LCDConfig.RW,1);           // Select the Read Operation for busy flag by setting RW
 3d8:	61 e0       	ldi	r22, 0x01	; 1
 3da:	80 91 88 00 	lds	r24, 0x0088
 3de:	0e 94 cf 00 	call	0x19e	; 0x19e <GPIO_PinWrite>
    do
    {

        GPIO_PinWrite(LCDConfig.EN,0);
 3e2:	60 e0       	ldi	r22, 0x00	; 0
 3e4:	80 91 89 00 	lds	r24, 0x0089
 3e8:	0e 94 cf 00 	call	0x19e	; 0x19e <GPIO_PinWrite>
        DELAY_us(10);
 3ec:	8a e0       	ldi	r24, 0x0A	; 10
 3ee:	90 e0       	ldi	r25, 0x00	; 0
 3f0:	0e 94 49 00 	call	0x92	; 0x92 <DELAY_us>
        GPIO_PinWrite(LCDConfig.EN,1); 
 3f4:	61 e0       	ldi	r22, 0x01	; 1
 3f6:	80 91 89 00 	lds	r24, 0x0089
 3fa:	0e 94 cf 00 	call	0x19e	; 0x19e <GPIO_PinWrite>
        DELAY_us(10);
 3fe:	8a e0       	ldi	r24, 0x0A	; 10
 400:	90 e0       	ldi	r25, 0x00	; 0
 402:	0e 94 49 00 	call	0x92	; 0x92 <DELAY_us>
        busyflag = GPIO_PinRead(LCDConfig.D7);
 406:	80 91 91 00 	lds	r24, 0x0091
 40a:	0e 94 41 01 	call	0x282	; 0x282 <GPIO_PinRead>
 40e:	c8 2f       	mov	r28, r24


        if(LCDConfig.v_LcdMode_U8 == 4)
 410:	80 91 86 00 	lds	r24, 0x0086
 414:	84 30       	cpi	r24, 0x04	; 4
 416:	91 f4       	brne	.+36     	; 0x43c <lcd_BusyCheck+0x84>
        {
            /* Perform extra dummy read for 4-bit */            
            GPIO_PinWrite(LCDConfig.EN,0);
 418:	60 e0       	ldi	r22, 0x00	; 0
 41a:	80 91 89 00 	lds	r24, 0x0089
 41e:	0e 94 cf 00 	call	0x19e	; 0x19e <GPIO_PinWrite>
            DELAY_us(10);
 422:	8a e0       	ldi	r24, 0x0A	; 10
 424:	90 e0       	ldi	r25, 0x00	; 0
 426:	0e 94 49 00 	call	0x92	; 0x92 <DELAY_us>
            GPIO_PinWrite(LCDConfig.EN,1); 
 42a:	61 e0       	ldi	r22, 0x01	; 1
 42c:	80 91 89 00 	lds	r24, 0x0089
 430:	0e 94 cf 00 	call	0x19e	; 0x19e <GPIO_PinWrite>
            DELAY_us(10);
 434:	8a e0       	ldi	r24, 0x0A	; 10
 436:	90 e0       	ldi	r25, 0x00	; 0
 438:	0e 94 49 00 	call	0x92	; 0x92 <DELAY_us>
        }    
    }while(busyflag!=0);
 43c:	c1 11       	cpse	r28, r1
 43e:	d1 cf       	rjmp	.-94     	; 0x3e2 <lcd_BusyCheck+0x2a>

    GPIO_PinDirection(LCDConfig.D7,OUTPUT); // Configure busy pin as Output
 440:	61 e0       	ldi	r22, 0x01	; 1
 442:	80 91 91 00 	lds	r24, 0x0091
 {
    /* Busy flag cannot be read as RW is not available hence Extra delay of 1ms is added 
      to ensure the LCD completes previous operation and ready to receive new commands/data */
    DELAY_ms(1);  
 }
}
 446:	cf 91       	pop	r28
            GPIO_PinWrite(LCDConfig.EN,1); 
            DELAY_us(10);
        }    
    }while(busyflag!=0);

    GPIO_PinDirection(LCDConfig.D7,OUTPUT); // Configure busy pin as Output
 448:	0c 94 5d 00 	jmp	0xba	; 0xba <GPIO_PinDirection>
  }
else
 {
    /* Busy flag cannot be read as RW is not available hence Extra delay of 1ms is added 
      to ensure the LCD completes previous operation and ready to receive new commands/data */
    DELAY_ms(1);  
 44c:	81 e0       	ldi	r24, 0x01	; 1
 44e:	90 e0       	ldi	r25, 0x00	; 0
 }
}
 450:	cf 91       	pop	r28
  }
else
 {
    /* Busy flag cannot be read as RW is not available hence Extra delay of 1ms is added 
      to ensure the LCD completes previous operation and ready to receive new commands/data */
    DELAY_ms(1);  
 452:	0c 94 52 00 	jmp	0xa4	; 0xa4 <DELAY_ms>

00000456 <LCD_SetUp>:
               gpioPins_et D3,
               gpioPins_et D4,
               gpioPins_et D5,
               gpioPins_et D6,
               gpioPins_et D7 )
{
 456:	8f 92       	push	r8
 458:	9f 92       	push	r9
 45a:	af 92       	push	r10
 45c:	bf 92       	push	r11
 45e:	cf 92       	push	r12
 460:	df 92       	push	r13
 462:	ef 92       	push	r14
 464:	ff 92       	push	r15
 466:	0f 93       	push	r16
 468:	1f 93       	push	r17
 46a:	cf 93       	push	r28
 46c:	df 93       	push	r29
 46e:	cd b7       	in	r28, 0x3d	; 61
 470:	de b7       	in	r29, 0x3e	; 62
 472:	98 2e       	mov	r9, r24
 474:	b6 2e       	mov	r11, r22
 476:	d4 2e       	mov	r13, r20
 478:	ff 84       	ldd	r15, Y+15	; 0x0f
 47a:	18 89       	ldd	r17, Y+16	; 0x10
  /* Copy the PIN numbers where the LCD is connected */
    LCDConfig.RS = RS;
 47c:	80 93 87 00 	sts	0x0087, r24
    LCDConfig.RW = RW;
 480:	60 93 88 00 	sts	0x0088, r22
    LCDConfig.EN = EN;
 484:	40 93 89 00 	sts	0x0089, r20

    LCDConfig.D0 = D0;
 488:	20 93 8a 00 	sts	0x008A, r18
    LCDConfig.D1 = D1;
 48c:	00 93 8b 00 	sts	0x008B, r16
    LCDConfig.D2 = D2;
 490:	e0 92 8c 00 	sts	0x008C, r14
    LCDConfig.D3 = D3;
 494:	c0 92 8d 00 	sts	0x008D, r12
    LCDConfig.D4 = D4;
 498:	a0 92 8e 00 	sts	0x008E, r10
    LCDConfig.D5 = D5;
 49c:	80 92 8f 00 	sts	0x008F, r8
    LCDConfig.D6 = D6;
 4a0:	f0 92 90 00 	sts	0x0090, r15
    LCDConfig.D7 = D7;
 4a4:	10 93 91 00 	sts	0x0091, r17


    if((D0 == P_NC) || (D1 == P_NC) || (D2 == P_NC) || (D3 == P_NC))
 4a8:	2f 3f       	cpi	r18, 0xFF	; 255
 4aa:	39 f0       	breq	.+14     	; 0x4ba <LCD_SetUp+0x64>
 4ac:	0f 3f       	cpi	r16, 0xFF	; 255
 4ae:	29 f0       	breq	.+10     	; 0x4ba <LCD_SetUp+0x64>
 4b0:	8f ef       	ldi	r24, 0xFF	; 255
 4b2:	e8 16       	cp	r14, r24
 4b4:	11 f0       	breq	.+4      	; 0x4ba <LCD_SetUp+0x64>
 4b6:	c8 12       	cpse	r12, r24
 4b8:	04 c0       	rjmp	.+8      	; 0x4c2 <LCD_SetUp+0x6c>
    {
        LCDConfig.v_LcdMode_U8 = 4; // Select 4-bit mode as D0-D3 are not used(P_NC)
 4ba:	84 e0       	ldi	r24, 0x04	; 4
 4bc:	80 93 86 00 	sts	0x0086, r24
 4c0:	13 c0       	rjmp	.+38     	; 0x4e8 <LCD_SetUp+0x92>
    }
    else
    {
        LCDConfig.v_LcdMode_U8 = 8; // 8-bit mode configure D0-D3 as output.      
 4c2:	88 e0       	ldi	r24, 0x08	; 8
 4c4:	80 93 86 00 	sts	0x0086, r24
        GPIO_PinDirection(D0,OUTPUT);
 4c8:	61 e0       	ldi	r22, 0x01	; 1
 4ca:	82 2f       	mov	r24, r18
 4cc:	0e 94 5d 00 	call	0xba	; 0xba <GPIO_PinDirection>
        GPIO_PinDirection(D1,OUTPUT);
 4d0:	61 e0       	ldi	r22, 0x01	; 1
 4d2:	80 2f       	mov	r24, r16
 4d4:	0e 94 5d 00 	call	0xba	; 0xba <GPIO_PinDirection>
        GPIO_PinDirection(D2,OUTPUT);
 4d8:	61 e0       	ldi	r22, 0x01	; 1
 4da:	8e 2d       	mov	r24, r14
 4dc:	0e 94 5d 00 	call	0xba	; 0xba <GPIO_PinDirection>
        GPIO_PinDirection(D3,OUTPUT);
 4e0:	61 e0       	ldi	r22, 0x01	; 1
 4e2:	8c 2d       	mov	r24, r12
 4e4:	0e 94 5d 00 	call	0xba	; 0xba <GPIO_PinDirection>
    }

    /* Configure RS,RW,EN, D4-D7 as Output for both 4/8-bit mode.*/
    GPIO_PinDirection(RS,OUTPUT);
 4e8:	61 e0       	ldi	r22, 0x01	; 1
 4ea:	89 2d       	mov	r24, r9
 4ec:	0e 94 5d 00 	call	0xba	; 0xba <GPIO_PinDirection>
    GPIO_PinDirection(RW,OUTPUT);
 4f0:	61 e0       	ldi	r22, 0x01	; 1
 4f2:	8b 2d       	mov	r24, r11
 4f4:	0e 94 5d 00 	call	0xba	; 0xba <GPIO_PinDirection>
    GPIO_PinDirection(EN,OUTPUT);
 4f8:	61 e0       	ldi	r22, 0x01	; 1
 4fa:	8d 2d       	mov	r24, r13
 4fc:	0e 94 5d 00 	call	0xba	; 0xba <GPIO_PinDirection>

    GPIO_PinDirection(D4,OUTPUT);
 500:	61 e0       	ldi	r22, 0x01	; 1
 502:	8a 2d       	mov	r24, r10
 504:	0e 94 5d 00 	call	0xba	; 0xba <GPIO_PinDirection>
    GPIO_PinDirection(D5,OUTPUT);
 508:	61 e0       	ldi	r22, 0x01	; 1
 50a:	88 2d       	mov	r24, r8
 50c:	0e 94 5d 00 	call	0xba	; 0xba <GPIO_PinDirection>
    GPIO_PinDirection(D6,OUTPUT);
 510:	61 e0       	ldi	r22, 0x01	; 1
 512:	8f 2d       	mov	r24, r15
 514:	0e 94 5d 00 	call	0xba	; 0xba <GPIO_PinDirection>
    GPIO_PinDirection(D7,OUTPUT);  
 518:	61 e0       	ldi	r22, 0x01	; 1
 51a:	81 2f       	mov	r24, r17
}
 51c:	df 91       	pop	r29
 51e:	cf 91       	pop	r28
 520:	1f 91       	pop	r17
 522:	0f 91       	pop	r16
 524:	ff 90       	pop	r15
 526:	ef 90       	pop	r14
 528:	df 90       	pop	r13
 52a:	cf 90       	pop	r12
 52c:	bf 90       	pop	r11
 52e:	af 90       	pop	r10
 530:	9f 90       	pop	r9
 532:	8f 90       	pop	r8
    GPIO_PinDirection(EN,OUTPUT);

    GPIO_PinDirection(D4,OUTPUT);
    GPIO_PinDirection(D5,OUTPUT);
    GPIO_PinDirection(D6,OUTPUT);
    GPIO_PinDirection(D7,OUTPUT);  
 534:	0c 94 5d 00 	jmp	0xba	; 0xba <GPIO_PinDirection>

00000538 <LCD_CmdWrite>:
                Some of the commonly used commands are defined in lcd.h.
                For more commands refer the data sheet and send the supported command.                
                The behaviour is undefined if unsupported commands are sent.    
****************************************************************************************************/
void LCD_CmdWrite( uint8_t v_lcdCmd_u8)
{
 538:	cf 93       	push	r28
 53a:	c8 2f       	mov	r28, r24
    lcd_BusyCheck();
 53c:	0e 94 dc 01 	call	0x3b8	; 0x3b8 <lcd_BusyCheck>
    if(LCDConfig.v_LcdMode_U8 == C_EightBitMode_U8)
 540:	80 91 86 00 	lds	r24, 0x0086
 544:	88 30       	cpi	r24, 0x08	; 8
 546:	21 f4       	brne	.+8      	; 0x550 <LCD_CmdWrite+0x18>
     {
         lcd_SendLowerNibble(v_lcdCmd_u8);
 548:	8c 2f       	mov	r24, r28
 54a:	0e 94 9e 01 	call	0x33c	; 0x33c <lcd_SendLowerNibble>
 54e:	07 c0       	rjmp	.+14     	; 0x55e <LCD_CmdWrite+0x26>
     }
     else
     {
         lcd_SendHigherNibble(v_lcdCmd_u8);
 550:	8c 2f       	mov	r24, r28
 552:	0e 94 5e 01 	call	0x2bc	; 0x2bc <lcd_SendHigherNibble>
         lcd_SendCmdSignals();
 556:	0e 94 84 01 	call	0x308	; 0x308 <lcd_SendCmdSignals>
         v_lcdCmd_u8 = v_lcdCmd_u8 << 4;
 55a:	c2 95       	swap	r28
 55c:	c0 7f       	andi	r28, 0xF0	; 240
     }

     lcd_SendHigherNibble(v_lcdCmd_u8);
 55e:	8c 2f       	mov	r24, r28
 560:	0e 94 5e 01 	call	0x2bc	; 0x2bc <lcd_SendHigherNibble>
     lcd_SendCmdSignals();
}
 564:	cf 91       	pop	r28
         lcd_SendCmdSignals();
         v_lcdCmd_u8 = v_lcdCmd_u8 << 4;
     }

     lcd_SendHigherNibble(v_lcdCmd_u8);
     lcd_SendCmdSignals();
 566:	0c 94 84 01 	jmp	0x308	; 0x308 <lcd_SendCmdSignals>

0000056a <LCD_GoToLine>:
           C_LcdLineThree,

****************************************************************************************************/
void LCD_GoToLine(uint8_t v_lineNumber_u8)
{
    if(v_lineNumber_u8 < LCDConfig.v_MaxSupportedLines_U8)
 56a:	90 91 84 00 	lds	r25, 0x0084
 56e:	89 17       	cp	r24, r25
 570:	58 f4       	brcc	.+22     	; 0x588 <LCD_GoToLine+0x1e>
    {
        /* If the line number is within range then
           Move the Cursor to beginning of the specified line */
        v_LcdTrackCursorPos_U8 = 0x00;
 572:	10 92 92 00 	sts	0x0092, r1
        v_LcdTrackLineNum_U8 = v_lineNumber_u8;
 576:	80 93 93 00 	sts	0x0093, r24
        LCD_CmdWrite(ARR_LcdLineNumAddress_U8[v_lineNumber_u8]);
 57a:	e8 2f       	mov	r30, r24
 57c:	f0 e0       	ldi	r31, 0x00	; 0
 57e:	e0 5a       	subi	r30, 0xA0	; 160
 580:	ff 4f       	sbci	r31, 0xFF	; 255
 582:	80 81       	ld	r24, Z
 584:	0c 94 9c 02 	jmp	0x538	; 0x538 <LCD_CmdWrite>
 588:	08 95       	ret

0000058a <LCD_Clear>:

 * description  :This function clears the LCD and moves the cursor to beginning of first line
****************************************************************************************************/
void LCD_Clear()
{
    LCD_CmdWrite(CMD_LCD_CLEAR);    // Clear the LCD and go to First line First Position
 58a:	81 e0       	ldi	r24, 0x01	; 1
 58c:	0e 94 9c 02 	call	0x538	; 0x538 <LCD_CmdWrite>
    LCD_GoToLine(C_LcdLineZero);
 590:	80 e0       	ldi	r24, 0x00	; 0
 592:	0c 94 b5 02 	jmp	0x56a	; 0x56a <LCD_GoToLine>

00000596 <LCD_Init>:
**************************************************************************************************/
void LCD_Init(uint8_t v_lcdNoOfLines_u8, uint8_t v_MaxCharsPerLine_u8)
{


    LCDConfig.v_MaxSupportedChars_U8 = v_MaxCharsPerLine_u8; //Maintaian the LCD type
 596:	60 93 85 00 	sts	0x0085, r22
    LCDConfig.v_MaxSupportedLines_U8 = v_lcdNoOfLines_u8;
 59a:	80 93 84 00 	sts	0x0084, r24
    if(v_lcdNoOfLines_u8 > C_LcdLineTwo)
 59e:	83 30       	cpi	r24, 0x03	; 3
 5a0:	40 f0       	brcs	.+16     	; 0x5b2 <LCD_Init+0x1c>
    {
        ARR_LcdLineNumAddress_U8[C_LcdLineTwo] =  0x90 + (v_MaxCharsPerLine_u8 & 0x0fu);
 5a2:	6f 70       	andi	r22, 0x0F	; 15
 5a4:	80 e9       	ldi	r24, 0x90	; 144
 5a6:	86 0f       	add	r24, r22
 5a8:	80 93 62 00 	sts	0x0062, r24
        ARR_LcdLineNumAddress_U8[C_LcdLineThree] =  0xd0 + (v_MaxCharsPerLine_u8 & 0x0fu);
 5ac:	60 53       	subi	r22, 0x30	; 48
 5ae:	60 93 63 00 	sts	0x0063, r22
    }

    DELAY_ms(100);
 5b2:	84 e6       	ldi	r24, 0x64	; 100
 5b4:	90 e0       	ldi	r25, 0x00	; 0
 5b6:	0e 94 52 00 	call	0xa4	; 0xa4 <DELAY_ms>

    if(LCDConfig.v_LcdMode_U8 == C_EightBitMode_U8)
 5ba:	80 91 86 00 	lds	r24, 0x0086
 5be:	88 30       	cpi	r24, 0x08	; 8
 5c0:	11 f4       	brne	.+4      	; 0x5c6 <LCD_Init+0x30>
    {
        LCD_CmdWrite(CMD_LCD_EIGHT_BIT_MODE); // Initialize the LCD for 8-bit 5x7 matrix type
 5c2:	88 e3       	ldi	r24, 0x38	; 56
 5c4:	27 c0       	rjmp	.+78     	; 0x614 <LCD_Init+0x7e>
    }
    else if(LCDConfig.v_LcdMode_U8 == C_FourBitMode_U8)
 5c6:	84 30       	cpi	r24, 0x04	; 4
 5c8:	39 f5       	brne	.+78     	; 0x618 <LCD_Init+0x82>
                 This is used only in 4-bit mode as the LCD by default boots in 8-Bit mode.
----------------------------------------------------------------------------------*/
static void lcd_Reset(void)
{
    /* LCD reset sequence for 4-bit mode, refer data sheet for more info */
    lcd_SendHigherNibble(0x30);
 5ca:	80 e3       	ldi	r24, 0x30	; 48
 5cc:	0e 94 5e 01 	call	0x2bc	; 0x2bc <lcd_SendHigherNibble>
    lcd_SendCmdSignals();
 5d0:	0e 94 84 01 	call	0x308	; 0x308 <lcd_SendCmdSignals>
    DELAY_ms(100);
 5d4:	84 e6       	ldi	r24, 0x64	; 100
 5d6:	90 e0       	ldi	r25, 0x00	; 0
 5d8:	0e 94 52 00 	call	0xa4	; 0xa4 <DELAY_ms>
    lcd_SendHigherNibble(0x30);
 5dc:	80 e3       	ldi	r24, 0x30	; 48
 5de:	0e 94 5e 01 	call	0x2bc	; 0x2bc <lcd_SendHigherNibble>
    lcd_SendCmdSignals();
 5e2:	0e 94 84 01 	call	0x308	; 0x308 <lcd_SendCmdSignals>
    DELAY_us(200);
 5e6:	88 ec       	ldi	r24, 0xC8	; 200
 5e8:	90 e0       	ldi	r25, 0x00	; 0
 5ea:	0e 94 49 00 	call	0x92	; 0x92 <DELAY_us>
    lcd_SendHigherNibble(0x30);
 5ee:	80 e3       	ldi	r24, 0x30	; 48
 5f0:	0e 94 5e 01 	call	0x2bc	; 0x2bc <lcd_SendHigherNibble>
    lcd_SendCmdSignals();
 5f4:	0e 94 84 01 	call	0x308	; 0x308 <lcd_SendCmdSignals>
    DELAY_us(200);
 5f8:	88 ec       	ldi	r24, 0xC8	; 200
 5fa:	90 e0       	ldi	r25, 0x00	; 0
 5fc:	0e 94 49 00 	call	0x92	; 0x92 <DELAY_us>
    lcd_SendHigherNibble(0x20);
 600:	80 e2       	ldi	r24, 0x20	; 32
 602:	0e 94 5e 01 	call	0x2bc	; 0x2bc <lcd_SendHigherNibble>
    lcd_SendCmdSignals();
 606:	0e 94 84 01 	call	0x308	; 0x308 <lcd_SendCmdSignals>
    DELAY_us(200);
 60a:	88 ec       	ldi	r24, 0xC8	; 200
 60c:	90 e0       	ldi	r25, 0x00	; 0
 60e:	0e 94 49 00 	call	0x92	; 0x92 <DELAY_us>
        LCD_CmdWrite(CMD_LCD_EIGHT_BIT_MODE); // Initialize the LCD for 8-bit 5x7 matrix type
    }
    else if(LCDConfig.v_LcdMode_U8 == C_FourBitMode_U8)
    {
        lcd_Reset();
        LCD_CmdWrite(CMD_LCD_FOUR_BIT_MODE); // Initialize the LCD for 4-bit 5x7 matrix type 
 612:	88 e2       	ldi	r24, 0x28	; 40
 614:	0e 94 9c 02 	call	0x538	; 0x538 <LCD_CmdWrite>
    }

    LCD_CmdWrite(CMD_DISPLAY_ON_CURSOR_ON);     // Display ON cursor ON
 618:	8e e0       	ldi	r24, 0x0E	; 14
 61a:	0e 94 9c 02 	call	0x538	; 0x538 <LCD_CmdWrite>
    LCD_Clear();                             // Clear the LCD and go to First line First Position
 61e:	0c 94 c5 02 	jmp	0x58a	; 0x58a <LCD_Clear>

00000622 <LCD_GoToNextLine>:
****************************************************************************************************/
void  LCD_GoToNextLine(void)
{
    /*Increment the current line number.
      In case it exceeds the limit, rool it back to first line */
    v_LcdTrackLineNum_U8++;
 622:	80 91 93 00 	lds	r24, 0x0093
 626:	8f 5f       	subi	r24, 0xFF	; 255
 628:	80 93 93 00 	sts	0x0093, r24
    v_LcdTrackCursorPos_U8 = 0x00;
 62c:	10 92 92 00 	sts	0x0092, r1
    if(v_LcdTrackLineNum_U8 >= LCDConfig.v_MaxSupportedLines_U8)
 630:	90 91 84 00 	lds	r25, 0x0084
 634:	89 17       	cp	r24, r25
 636:	10 f0       	brcs	.+4      	; 0x63c <LCD_GoToNextLine+0x1a>
        v_LcdTrackLineNum_U8 = C_LcdLineZero;
 638:	10 92 93 00 	sts	0x0093, r1
    LCD_CmdWrite(ARR_LcdLineNumAddress_U8[v_LcdTrackLineNum_U8]);
 63c:	e0 91 93 00 	lds	r30, 0x0093
 640:	f0 e0       	ldi	r31, 0x00	; 0
 642:	e0 5a       	subi	r30, 0xA0	; 160
 644:	ff 4f       	sbci	r31, 0xFF	; 255
 646:	80 81       	ld	r24, Z
 648:	0c 94 9c 02 	jmp	0x538	; 0x538 <LCD_CmdWrite>

0000064c <LCD_DisplayChar>:
 * description  : This function sends a character to be displayed on LCD.
                  Any valid ascii value can be passed to display respective character

****************************************************************************************************/
void LCD_DisplayChar(char v_lcdData_u8)
{
 64c:	cf 93       	push	r28
 64e:	c8 2f       	mov	r28, r24
    if((v_LcdTrackCursorPos_U8>=LCDConfig.v_MaxSupportedChars_U8) || (v_lcdData_u8=='\n'))
 650:	90 91 92 00 	lds	r25, 0x0092
 654:	80 91 85 00 	lds	r24, 0x0085
 658:	98 17       	cp	r25, r24
 65a:	60 f4       	brcc	.+24     	; 0x674 <LCD_DisplayChar+0x28>
 65c:	ca 30       	cpi	r28, 0x0A	; 10
 65e:	51 f0       	breq	.+20     	; 0x674 <LCD_DisplayChar+0x28>

 * description : This functions is used to send a byte of data to LCD.                 .    
**************************************************************************************************/
static void lcd_DataWrite( uint8_t dataByte)
{
    lcd_BusyCheck();
 660:	0e 94 dc 01 	call	0x3b8	; 0x3b8 <lcd_BusyCheck>
    if(LCDConfig.v_LcdMode_U8 == C_EightBitMode_U8)
 664:	80 91 86 00 	lds	r24, 0x0086
 668:	88 30       	cpi	r24, 0x08	; 8
 66a:	49 f4       	brne	.+18     	; 0x67e <LCD_DisplayChar+0x32>
     {
         lcd_SendLowerNibble(dataByte);
 66c:	8c 2f       	mov	r24, r28
 66e:	0e 94 9e 01 	call	0x33c	; 0x33c <lcd_SendLowerNibble>
 672:	0c c0       	rjmp	.+24     	; 0x68c <LCD_DisplayChar+0x40>
{
    if((v_LcdTrackCursorPos_U8>=LCDConfig.v_MaxSupportedChars_U8) || (v_lcdData_u8=='\n'))
    {
        /* If the cursor has reached to end of line on page1
        OR NewLine command is issued Then Move the cursor to next line */
        LCD_GoToNextLine();
 674:	0e 94 11 03 	call	0x622	; 0x622 <LCD_GoToNextLine>
    }
    if(v_lcdData_u8!='\n') /* Display the character if its not newLine Char */
 678:	ca 30       	cpi	r28, 0x0A	; 10
 67a:	91 f0       	breq	.+36     	; 0x6a0 <LCD_DisplayChar+0x54>
 67c:	f1 cf       	rjmp	.-30     	; 0x660 <LCD_DisplayChar+0x14>
     {
         lcd_SendLowerNibble(dataByte);
     }
     else
     {
         lcd_SendHigherNibble(dataByte);
 67e:	8c 2f       	mov	r24, r28
 680:	0e 94 5e 01 	call	0x2bc	; 0x2bc <lcd_SendHigherNibble>
         lcd_SendDataSignals();
 684:	0e 94 c2 01 	call	0x384	; 0x384 <lcd_SendDataSignals>
         dataByte = dataByte << 4;
 688:	c2 95       	swap	r28
 68a:	c0 7f       	andi	r28, 0xF0	; 240
     }

     lcd_SendHigherNibble(dataByte);
 68c:	8c 2f       	mov	r24, r28
 68e:	0e 94 5e 01 	call	0x2bc	; 0x2bc <lcd_SendHigherNibble>
     lcd_SendDataSignals();
 692:	0e 94 c2 01 	call	0x384	; 0x384 <lcd_SendDataSignals>
    }
    if(v_lcdData_u8!='\n') /* Display the character if its not newLine Char */
    {

        lcd_DataWrite(v_lcdData_u8); /* Display the data and keep track of cursor */
        v_LcdTrackCursorPos_U8++;
 696:	80 91 92 00 	lds	r24, 0x0092
 69a:	8f 5f       	subi	r24, 0xFF	; 255
 69c:	80 93 92 00 	sts	0x0092, r24
    }
}
 6a0:	cf 91       	pop	r28
 6a2:	08 95       	ret

000006a4 <LCD_DisplayString>:
                    and traverses till the end(NULL CHAR)and displays a char each time.

****************************************************************************************************/
#if (Enable_LCD_DisplayString==1)
void LCD_DisplayString(const char *ptr_stringPointer_u8)
{
 6a4:	cf 93       	push	r28
 6a6:	df 93       	push	r29
 6a8:	ec 01       	movw	r28, r24
    while((*ptr_stringPointer_u8)!=0)
 6aa:	89 91       	ld	r24, Y+
 6ac:	88 23       	and	r24, r24
 6ae:	19 f0       	breq	.+6      	; 0x6b6 <LCD_DisplayString+0x12>
        LCD_DisplayChar(*ptr_stringPointer_u8++); // Loop through the string and display char by char
 6b0:	0e 94 26 03 	call	0x64c	; 0x64c <LCD_DisplayChar>
 6b4:	fa cf       	rjmp	.-12     	; 0x6aa <LCD_DisplayString+0x6>
}
 6b6:	df 91       	pop	r29
 6b8:	cf 91       	pop	r28
 6ba:	08 95       	ret

000006bc <UART_SetBaudRate>:
                 the default baudrate of 9600 is set.

		    Refer uart.h file for Supported range of baud rates.
***************************************************************************************************/
void UART_SetBaudRate(uint32_t v_baudRate_u32)
{
 6bc:	cf 92       	push	r12
 6be:	df 92       	push	r13
 6c0:	ef 92       	push	r14
 6c2:	ff 92       	push	r15
 6c4:	6b 01       	movw	r12, r22
 6c6:	7c 01       	movw	r14, r24
	uint16_t RegValue;

	if((v_baudRate_u32 >= C_MinBaudRate_U32) && (v_baudRate_u32<=C_MaxBaudRate_U32))
 6c8:	dc 01       	movw	r26, r24
 6ca:	cb 01       	movw	r24, r22
 6cc:	80 56       	subi	r24, 0x60	; 96
 6ce:	99 40       	sbci	r25, 0x09	; 9
 6d0:	a1 09       	sbc	r26, r1
 6d2:	b1 09       	sbc	r27, r1
 6d4:	81 3a       	cpi	r24, 0xA1	; 161
 6d6:	98 4b       	sbci	r25, 0xB8	; 184
 6d8:	a1 40       	sbci	r26, 0x01	; 1
 6da:	b1 05       	cpc	r27, r1
 6dc:	98 f4       	brcc	.+38     	; 0x704 <UART_SetBaudRate+0x48>
	{
		/* Check if the requested baudate is within range,
	     If yes then calculate the value to be loaded into baud rate generator. */
		RegValue = M_GetBaudRateGeneratorValue(v_baudRate_u32);
 6de:	a8 ef       	ldi	r26, 0xF8	; 248
 6e0:	bf ef       	ldi	r27, 0xFF	; 255
 6e2:	a7 01       	movw	r20, r14
 6e4:	96 01       	movw	r18, r12
 6e6:	0e 94 ee 03 	call	0x7dc	; 0x7dc <__mulohisi3>
 6ea:	7c 5d       	subi	r23, 0xDC	; 220
 6ec:	8b 40       	sbci	r24, 0x0B	; 11
 6ee:	9f 4f       	sbci	r25, 0xFF	; 255
 6f0:	e4 e0       	ldi	r30, 0x04	; 4
 6f2:	22 0f       	add	r18, r18
 6f4:	33 1f       	adc	r19, r19
 6f6:	44 1f       	adc	r20, r20
 6f8:	55 1f       	adc	r21, r21
 6fa:	ea 95       	dec	r30
 6fc:	d1 f7       	brne	.-12     	; 0x6f2 <UART_SetBaudRate+0x36>
 6fe:	0e 94 c9 03 	call	0x792	; 0x792 <__udivmodsi4>
 702:	02 c0       	rjmp	.+4      	; 0x708 <UART_SetBaudRate+0x4c>
	}
	else
	{
		/*	 Invalid baudrate requested, hence set it to default baudrate of 9600 */
		RegValue = M_GetBaudRateGeneratorValue(9600);
 704:	27 e6       	ldi	r18, 0x67	; 103
 706:	30 e0       	ldi	r19, 0x00	; 0
	}

	UBRRL = util_ExtractByte0to8(RegValue);
 708:	29 b9       	out	0x09, r18	; 9
	UBRRH = util_ExtractByte8to16(RegValue);
 70a:	30 bd       	out	0x20, r19	; 32
}
 70c:	ff 90       	pop	r15
 70e:	ef 90       	pop	r14
 710:	df 90       	pop	r13
 712:	cf 90       	pop	r12
 714:	08 95       	ret

00000716 <UART_Init>:

		    Refer uart.h file for Supported(range) baud rates.		
***************************************************************************************************/
void UART_Init(uint32_t v_baudRate_u32)
{
	UCSRB= (1<<RXEN) | (1<<TXEN);                  // Enable Receiver and Transmitter
 716:	28 e1       	ldi	r18, 0x18	; 24
 718:	2a b9       	out	0x0a, r18	; 10
	UCSRC= (1<<URSEL) | (1<<UCSZ1) | (1<<UCSZ0);   // Asynchronous mode 8-bit data and 1-stop bit
 71a:	26 e8       	ldi	r18, 0x86	; 134
 71c:	20 bd       	out	0x20, r18	; 32
	UCSRA= 0x00;                                   // Clear the UASRT status register
 71e:	1b b8       	out	0x0b, r1	; 11
	UART_SetBaudRate(v_baudRate_u32);
 720:	0c 94 5e 03 	jmp	0x6bc	; 0x6bc <UART_SetBaudRate>

00000724 <UART_RxChar>:
 * description :This function is used to receive a char from UART module.
                It waits till a char is received and returns it after reception.
***************************************************************************************************/
char UART_RxChar(void)
{
	while(util_IsBitCleared(UCSRA,RXC));  // Wait till the data is received
 724:	5f 9b       	sbis	0x0b, 7	; 11
 726:	fe cf       	rjmp	.-4      	; 0x724 <UART_RxChar>
	return(UDR);                          // return the received char
 728:	8c b1       	in	r24, 0x0c	; 12
}
 72a:	08 95       	ret

0000072c <UART_TxChar>:

 * description  :This function is used to transmit a char through UART module.
***************************************************************************************************/
void UART_TxChar(char v_uartData_u8)
{
	while(util_IsBitCleared(UCSRA,UDRE)); // Wait till Transmitter(UDR) register becomes Empty
 72c:	5d 9b       	sbis	0x0b, 5	; 11
 72e:	fe cf       	rjmp	.-4      	; 0x72c <UART_TxChar>
	UDR =v_uartData_u8;                              // Load the data to be transmitted
 730:	8c b9       	out	0x0c, r24	; 12
 732:	08 95       	ret

00000734 <main>:

int main() 
{
    char ch;
    /*Connect RS->PB0, RW->PB1, EN->PB2 and data bus to PORTB.4 to PORTB.7*/
    LCD_SetUp(PB_0,PB_1,PB_2,P_NC,P_NC,P_NC,P_NC,PB_4,PB_5,PB_6,PB_7);
 734:	8f e0       	ldi	r24, 0x0F	; 15
 736:	8f 93       	push	r24
 738:	8e e0       	ldi	r24, 0x0E	; 14
 73a:	8f 93       	push	r24
 73c:	8d e0       	ldi	r24, 0x0D	; 13
 73e:	88 2e       	mov	r8, r24
 740:	9c e0       	ldi	r25, 0x0C	; 12
 742:	a9 2e       	mov	r10, r25
 744:	cc 24       	eor	r12, r12
 746:	ca 94       	dec	r12
 748:	ee 24       	eor	r14, r14
 74a:	ea 94       	dec	r14
 74c:	0f ef       	ldi	r16, 0xFF	; 255
 74e:	2f ef       	ldi	r18, 0xFF	; 255
 750:	4a e0       	ldi	r20, 0x0A	; 10
 752:	69 e0       	ldi	r22, 0x09	; 9
 754:	88 e0       	ldi	r24, 0x08	; 8
 756:	0e 94 2b 02 	call	0x456	; 0x456 <LCD_SetUp>
    LCD_Init(2,16);
 75a:	60 e1       	ldi	r22, 0x10	; 16
 75c:	82 e0       	ldi	r24, 0x02	; 2
 75e:	0e 94 cb 02 	call	0x596	; 0x596 <LCD_Init>
    UART_Init(9600);
 762:	60 e8       	ldi	r22, 0x80	; 128
 764:	75 e2       	ldi	r23, 0x25	; 37
 766:	80 e0       	ldi	r24, 0x00	; 0
 768:	90 e0       	ldi	r25, 0x00	; 0
 76a:	0e 94 8b 03 	call	0x716	; 0x716 <UART_Init>
    LCD_DisplayString("send data from  serial terminal");
 76e:	84 e6       	ldi	r24, 0x64	; 100
 770:	90 e0       	ldi	r25, 0x00	; 0
 772:	0e 94 52 03 	call	0x6a4	; 0x6a4 <LCD_DisplayString>
    LCD_GoToLine(0);
 776:	80 e0       	ldi	r24, 0x00	; 0
 778:	0e 94 b5 02 	call	0x56a	; 0x56a <LCD_GoToLine>
 77c:	0f 90       	pop	r0
 77e:	0f 90       	pop	r0
    while(1)
    {
        ch = UART_RxChar();
 780:	0e 94 92 03 	call	0x724	; 0x724 <UART_RxChar>
 784:	c8 2f       	mov	r28, r24
        UART_TxChar(ch);
 786:	0e 94 96 03 	call	0x72c	; 0x72c <UART_TxChar>
        LCD_DisplayChar(ch);
 78a:	8c 2f       	mov	r24, r28
 78c:	0e 94 26 03 	call	0x64c	; 0x64c <LCD_DisplayChar>
    }
 790:	f7 cf       	rjmp	.-18     	; 0x780 <main+0x4c>

00000792 <__udivmodsi4>:
 792:	a1 e2       	ldi	r26, 0x21	; 33
 794:	1a 2e       	mov	r1, r26
 796:	aa 1b       	sub	r26, r26
 798:	bb 1b       	sub	r27, r27
 79a:	fd 01       	movw	r30, r26
 79c:	0d c0       	rjmp	.+26     	; 0x7b8 <__udivmodsi4_ep>

0000079e <__udivmodsi4_loop>:
 79e:	aa 1f       	adc	r26, r26
 7a0:	bb 1f       	adc	r27, r27
 7a2:	ee 1f       	adc	r30, r30
 7a4:	ff 1f       	adc	r31, r31
 7a6:	a2 17       	cp	r26, r18
 7a8:	b3 07       	cpc	r27, r19
 7aa:	e4 07       	cpc	r30, r20
 7ac:	f5 07       	cpc	r31, r21
 7ae:	20 f0       	brcs	.+8      	; 0x7b8 <__udivmodsi4_ep>
 7b0:	a2 1b       	sub	r26, r18
 7b2:	b3 0b       	sbc	r27, r19
 7b4:	e4 0b       	sbc	r30, r20
 7b6:	f5 0b       	sbc	r31, r21

000007b8 <__udivmodsi4_ep>:
 7b8:	66 1f       	adc	r22, r22
 7ba:	77 1f       	adc	r23, r23
 7bc:	88 1f       	adc	r24, r24
 7be:	99 1f       	adc	r25, r25
 7c0:	1a 94       	dec	r1
 7c2:	69 f7       	brne	.-38     	; 0x79e <__udivmodsi4_loop>
 7c4:	60 95       	com	r22
 7c6:	70 95       	com	r23
 7c8:	80 95       	com	r24
 7ca:	90 95       	com	r25
 7cc:	9b 01       	movw	r18, r22
 7ce:	ac 01       	movw	r20, r24
 7d0:	bd 01       	movw	r22, r26
 7d2:	cf 01       	movw	r24, r30
 7d4:	08 95       	ret

000007d6 <__mulshisi3>:
 7d6:	b7 ff       	sbrs	r27, 7
 7d8:	0c 94 f3 03 	jmp	0x7e6	; 0x7e6 <__muluhisi3>

000007dc <__mulohisi3>:
 7dc:	0e 94 f3 03 	call	0x7e6	; 0x7e6 <__muluhisi3>
 7e0:	82 1b       	sub	r24, r18
 7e2:	93 0b       	sbc	r25, r19
 7e4:	08 95       	ret

000007e6 <__muluhisi3>:
 7e6:	0e 94 fe 03 	call	0x7fc	; 0x7fc <__umulhisi3>
 7ea:	a5 9f       	mul	r26, r21
 7ec:	90 0d       	add	r25, r0
 7ee:	b4 9f       	mul	r27, r20
 7f0:	90 0d       	add	r25, r0
 7f2:	a4 9f       	mul	r26, r20
 7f4:	80 0d       	add	r24, r0
 7f6:	91 1d       	adc	r25, r1
 7f8:	11 24       	eor	r1, r1
 7fa:	08 95       	ret

000007fc <__umulhisi3>:
 7fc:	a2 9f       	mul	r26, r18
 7fe:	b0 01       	movw	r22, r0
 800:	b3 9f       	mul	r27, r19
 802:	c0 01       	movw	r24, r0
 804:	a3 9f       	mul	r26, r19
 806:	70 0d       	add	r23, r0
 808:	81 1d       	adc	r24, r1
 80a:	11 24       	eor	r1, r1
 80c:	91 1d       	adc	r25, r1
 80e:	b2 9f       	mul	r27, r18
 810:	70 0d       	add	r23, r0
 812:	81 1d       	adc	r24, r1
 814:	11 24       	eor	r1, r1
 816:	91 1d       	adc	r25, r1
 818:	08 95       	ret

0000081a <_exit>:
 81a:	f8 94       	cli

0000081c <__stop_program>:
 81c:	ff cf       	rjmp	.-2      	; 0x81c <__stop_program>
