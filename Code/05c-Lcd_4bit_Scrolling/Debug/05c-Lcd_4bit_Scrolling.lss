
05c-Lcd_4bit_Scrolling.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000076e  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000003c  00800060  0000076e  00000802  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000010  0080009c  0080009c  0000083e  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  0000083e  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00000870  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000120  00000000  00000000  000008ac  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000017c2  00000000  00000000  000009cc  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000059a  00000000  00000000  0000218e  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000652  00000000  00000000  00002728  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000374  00000000  00000000  00002d7c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000006c1  00000000  00000000  000030f0  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000166d  00000000  00000000  000037b1  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000128  00000000  00000000  00004e1e  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
   4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
   8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
   c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  1c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
  54:	11 24       	eor	r1, r1
  56:	1f be       	out	0x3f, r1	; 63
  58:	cf e5       	ldi	r28, 0x5F	; 95
  5a:	d8 e0       	ldi	r29, 0x08	; 8
  5c:	de bf       	out	0x3e, r29	; 62
  5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
  60:	10 e0       	ldi	r17, 0x00	; 0
  62:	a0 e6       	ldi	r26, 0x60	; 96
  64:	b0 e0       	ldi	r27, 0x00	; 0
  66:	ee e6       	ldi	r30, 0x6E	; 110
  68:	f7 e0       	ldi	r31, 0x07	; 7
  6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
  6c:	05 90       	lpm	r0, Z+
  6e:	0d 92       	st	X+, r0
  70:	ac 39       	cpi	r26, 0x9C	; 156
  72:	b1 07       	cpc	r27, r17
  74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
  76:	20 e0       	ldi	r18, 0x00	; 0
  78:	ac e9       	ldi	r26, 0x9C	; 156
  7a:	b0 e0       	ldi	r27, 0x00	; 0
  7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
  7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
  80:	ac 3a       	cpi	r26, 0xAC	; 172
  82:	b2 07       	cpc	r27, r18
  84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
  86:	0e 94 96 03 	call	0x72c	; 0x72c <main>
  8a:	0c 94 b5 03 	jmp	0x76a	; 0x76a <_exit>

0000008e <__bad_interrupt>:
  8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <DELAY_us>:
         if 5000 is passed as the argument then it generates a delay of 5ms.		  

 ***************************************************************************************************/
void DELAY_us(uint16_t us_count) 
{
    while (us_count != 0) 
  92:	00 97       	sbiw	r24, 0x00	; 0
  94:	31 f0       	breq	.+12     	; 0xa2 <DELAY_us+0x10>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
  96:	25 e0       	ldi	r18, 0x05	; 5
  98:	2a 95       	dec	r18
  9a:	f1 f7       	brne	.-4      	; 0x98 <DELAY_us+0x6>
  9c:	00 00       	nop
    {
        _delay_us(1);
		us_count--;
  9e:	01 97       	sbiw	r24, 0x01	; 1
  a0:	f8 cf       	rjmp	.-16     	; 0x92 <DELAY_us>
    }
}
  a2:	08 95       	ret

000000a4 <DELAY_ms>:
     It generates a delay of 1ms for each count,
     if 1000 is passed as the argument then it generates delay of 1000ms(1sec)
 ***************************************************************************************************/
void DELAY_ms(uint16_t ms_count) 
{
    while (ms_count != 0) 
  a4:	00 97       	sbiw	r24, 0x00	; 0
  a6:	41 f0       	breq	.+16     	; 0xb8 <DELAY_ms+0x14>
  a8:	ef e9       	ldi	r30, 0x9F	; 159
  aa:	ff e0       	ldi	r31, 0x0F	; 15
  ac:	31 97       	sbiw	r30, 0x01	; 1
  ae:	f1 f7       	brne	.-4      	; 0xac <DELAY_ms+0x8>
  b0:	00 c0       	rjmp	.+0      	; 0xb2 <DELAY_ms+0xe>
  b2:	00 00       	nop
    {
        _delay_us(1000); //DELAY_us is called to generate 1ms delay
        ms_count--;
  b4:	01 97       	sbiw	r24, 0x01	; 1
  b6:	f6 cf       	rjmp	.-20     	; 0xa4 <DELAY_ms>
    }
}
  b8:	08 95       	ret

000000ba <GPIO_PinDirection>:

    uint8_t v_portNumber_u8;


    v_portNumber_u8 =  (enm_pinNumber>>3);  // Divide the pin number by 8 go get the PORT number
    enm_pinNumber  =   enm_pinNumber & 0x07;  // lower 3-bits contains the bit number of a byte 
  ba:	98 2f       	mov	r25, r24
  bc:	97 70       	andi	r25, 0x07	; 7
{

    uint8_t v_portNumber_u8;


    v_portNumber_u8 =  (enm_pinNumber>>3);  // Divide the pin number by 8 go get the PORT number
  be:	86 95       	lsr	r24
  c0:	86 95       	lsr	r24
  c2:	86 95       	lsr	r24
    enm_pinNumber  =   enm_pinNumber & 0x07;  // lower 3-bits contains the bit number of a byte 

    /* Go to particular port after decoding from the pin number and 
        set the direction as specified*/
    switch(v_portNumber_u8)
  c4:	81 30       	cpi	r24, 0x01	; 1
  c6:	01 f1       	breq	.+64     	; 0x108 <GPIO_PinDirection+0x4e>
  c8:	30 f0       	brcs	.+12     	; 0xd6 <GPIO_PinDirection+0x1c>
  ca:	82 30       	cpi	r24, 0x02	; 2
  cc:	b1 f1       	breq	.+108    	; 0x13a <GPIO_PinDirection+0x80>
  ce:	83 30       	cpi	r24, 0x03	; 3
  d0:	09 f4       	brne	.+2      	; 0xd4 <GPIO_PinDirection+0x1a>
  d2:	4c c0       	rjmp	.+152    	; 0x16c <GPIO_PinDirection+0xb2>
  d4:	08 95       	ret
    {
#ifdef DDRA        
    case 0:
        util_UpdateBit(DDRA,enm_pinNumber,v_pinDirn_u8);
  d6:	4a b3       	in	r20, 0x1a	; 26
  d8:	21 e0       	ldi	r18, 0x01	; 1
  da:	30 e0       	ldi	r19, 0x00	; 0
  dc:	66 23       	and	r22, r22
  de:	49 f0       	breq	.+18     	; 0xf2 <GPIO_PinDirection+0x38>
  e0:	b9 01       	movw	r22, r18
  e2:	02 c0       	rjmp	.+4      	; 0xe8 <GPIO_PinDirection+0x2e>
  e4:	66 0f       	add	r22, r22
  e6:	77 1f       	adc	r23, r23
  e8:	9a 95       	dec	r25
  ea:	e2 f7       	brpl	.-8      	; 0xe4 <GPIO_PinDirection+0x2a>
  ec:	cb 01       	movw	r24, r22
  ee:	84 2b       	or	r24, r20
  f0:	09 c0       	rjmp	.+18     	; 0x104 <GPIO_PinDirection+0x4a>
  f2:	b9 01       	movw	r22, r18
  f4:	02 c0       	rjmp	.+4      	; 0xfa <GPIO_PinDirection+0x40>
  f6:	66 0f       	add	r22, r22
  f8:	77 1f       	adc	r23, r23
  fa:	9a 95       	dec	r25
  fc:	e2 f7       	brpl	.-8      	; 0xf6 <GPIO_PinDirection+0x3c>
  fe:	cb 01       	movw	r24, r22
 100:	80 95       	com	r24
 102:	84 23       	and	r24, r20
 104:	8a bb       	out	0x1a, r24	; 26
 106:	08 95       	ret
#endif        


#ifdef DDRB
    case 1:
        util_UpdateBit(DDRB,enm_pinNumber,v_pinDirn_u8);
 108:	47 b3       	in	r20, 0x17	; 23
 10a:	21 e0       	ldi	r18, 0x01	; 1
 10c:	30 e0       	ldi	r19, 0x00	; 0
 10e:	66 23       	and	r22, r22
 110:	49 f0       	breq	.+18     	; 0x124 <GPIO_PinDirection+0x6a>
 112:	b9 01       	movw	r22, r18
 114:	02 c0       	rjmp	.+4      	; 0x11a <GPIO_PinDirection+0x60>
 116:	66 0f       	add	r22, r22
 118:	77 1f       	adc	r23, r23
 11a:	9a 95       	dec	r25
 11c:	e2 f7       	brpl	.-8      	; 0x116 <GPIO_PinDirection+0x5c>
 11e:	cb 01       	movw	r24, r22
 120:	84 2b       	or	r24, r20
 122:	09 c0       	rjmp	.+18     	; 0x136 <GPIO_PinDirection+0x7c>
 124:	b9 01       	movw	r22, r18
 126:	02 c0       	rjmp	.+4      	; 0x12c <GPIO_PinDirection+0x72>
 128:	66 0f       	add	r22, r22
 12a:	77 1f       	adc	r23, r23
 12c:	9a 95       	dec	r25
 12e:	e2 f7       	brpl	.-8      	; 0x128 <GPIO_PinDirection+0x6e>
 130:	cb 01       	movw	r24, r22
 132:	80 95       	com	r24
 134:	84 23       	and	r24, r20
 136:	87 bb       	out	0x17, r24	; 23
 138:	08 95       	ret
#endif 

        
#ifdef DDRC
    case 2:
        util_UpdateBit(DDRC,enm_pinNumber,v_pinDirn_u8);
 13a:	44 b3       	in	r20, 0x14	; 20
 13c:	21 e0       	ldi	r18, 0x01	; 1
 13e:	30 e0       	ldi	r19, 0x00	; 0
 140:	66 23       	and	r22, r22
 142:	49 f0       	breq	.+18     	; 0x156 <GPIO_PinDirection+0x9c>
 144:	b9 01       	movw	r22, r18
 146:	02 c0       	rjmp	.+4      	; 0x14c <GPIO_PinDirection+0x92>
 148:	66 0f       	add	r22, r22
 14a:	77 1f       	adc	r23, r23
 14c:	9a 95       	dec	r25
 14e:	e2 f7       	brpl	.-8      	; 0x148 <GPIO_PinDirection+0x8e>
 150:	cb 01       	movw	r24, r22
 152:	84 2b       	or	r24, r20
 154:	09 c0       	rjmp	.+18     	; 0x168 <GPIO_PinDirection+0xae>
 156:	b9 01       	movw	r22, r18
 158:	02 c0       	rjmp	.+4      	; 0x15e <GPIO_PinDirection+0xa4>
 15a:	66 0f       	add	r22, r22
 15c:	77 1f       	adc	r23, r23
 15e:	9a 95       	dec	r25
 160:	e2 f7       	brpl	.-8      	; 0x15a <GPIO_PinDirection+0xa0>
 162:	cb 01       	movw	r24, r22
 164:	80 95       	com	r24
 166:	84 23       	and	r24, r20
 168:	84 bb       	out	0x14, r24	; 20
 16a:	08 95       	ret
#endif 

        
#ifdef DDRD        
    case 3:
        util_UpdateBit(DDRD,enm_pinNumber,v_pinDirn_u8);
 16c:	41 b3       	in	r20, 0x11	; 17
 16e:	21 e0       	ldi	r18, 0x01	; 1
 170:	30 e0       	ldi	r19, 0x00	; 0
 172:	66 23       	and	r22, r22
 174:	49 f0       	breq	.+18     	; 0x188 <GPIO_PinDirection+0xce>
 176:	b9 01       	movw	r22, r18
 178:	02 c0       	rjmp	.+4      	; 0x17e <GPIO_PinDirection+0xc4>
 17a:	66 0f       	add	r22, r22
 17c:	77 1f       	adc	r23, r23
 17e:	9a 95       	dec	r25
 180:	e2 f7       	brpl	.-8      	; 0x17a <GPIO_PinDirection+0xc0>
 182:	cb 01       	movw	r24, r22
 184:	84 2b       	or	r24, r20
 186:	09 c0       	rjmp	.+18     	; 0x19a <GPIO_PinDirection+0xe0>
 188:	b9 01       	movw	r22, r18
 18a:	02 c0       	rjmp	.+4      	; 0x190 <GPIO_PinDirection+0xd6>
 18c:	66 0f       	add	r22, r22
 18e:	77 1f       	adc	r23, r23
 190:	9a 95       	dec	r25
 192:	e2 f7       	brpl	.-8      	; 0x18c <GPIO_PinDirection+0xd2>
 194:	cb 01       	movw	r24, r22
 196:	80 95       	com	r24
 198:	84 23       	and	r24, r20
 19a:	81 bb       	out	0x11, r24	; 17
 19c:	08 95       	ret

0000019e <GPIO_PinWrite>:

    uint8_t v_portNumber_u8;


    v_portNumber_u8 =  (enm_pinNumber>>3);  // Divide the pin number by 8 go get the PORT number
    enm_pinNumber  =   enm_pinNumber & 0x07;  // lower 3-bits contains the bit number of a byte 
 19e:	98 2f       	mov	r25, r24
 1a0:	97 70       	andi	r25, 0x07	; 7
{

    uint8_t v_portNumber_u8;


    v_portNumber_u8 =  (enm_pinNumber>>3);  // Divide the pin number by 8 go get the PORT number
 1a2:	86 95       	lsr	r24
 1a4:	86 95       	lsr	r24
 1a6:	86 95       	lsr	r24
    enm_pinNumber  =   enm_pinNumber & 0x07;  // lower 3-bits contains the bit number of a byte 

    /* Go to particular port after decoding from the pin number and 
        update the value of the specified pin*/
    switch(v_portNumber_u8)
 1a8:	81 30       	cpi	r24, 0x01	; 1
 1aa:	01 f1       	breq	.+64     	; 0x1ec <GPIO_PinWrite+0x4e>
 1ac:	30 f0       	brcs	.+12     	; 0x1ba <GPIO_PinWrite+0x1c>
 1ae:	82 30       	cpi	r24, 0x02	; 2
 1b0:	b1 f1       	breq	.+108    	; 0x21e <GPIO_PinWrite+0x80>
 1b2:	83 30       	cpi	r24, 0x03	; 3
 1b4:	09 f4       	brne	.+2      	; 0x1b8 <GPIO_PinWrite+0x1a>
 1b6:	4c c0       	rjmp	.+152    	; 0x250 <GPIO_PinWrite+0xb2>
 1b8:	08 95       	ret
    {
#ifdef PORTA        
    case 0:
        util_UpdateBit(PORTA,enm_pinNumber,v_pinValue_u8);
 1ba:	4b b3       	in	r20, 0x1b	; 27
 1bc:	21 e0       	ldi	r18, 0x01	; 1
 1be:	30 e0       	ldi	r19, 0x00	; 0
 1c0:	66 23       	and	r22, r22
 1c2:	49 f0       	breq	.+18     	; 0x1d6 <GPIO_PinWrite+0x38>
 1c4:	b9 01       	movw	r22, r18
 1c6:	02 c0       	rjmp	.+4      	; 0x1cc <GPIO_PinWrite+0x2e>
 1c8:	66 0f       	add	r22, r22
 1ca:	77 1f       	adc	r23, r23
 1cc:	9a 95       	dec	r25
 1ce:	e2 f7       	brpl	.-8      	; 0x1c8 <GPIO_PinWrite+0x2a>
 1d0:	cb 01       	movw	r24, r22
 1d2:	84 2b       	or	r24, r20
 1d4:	09 c0       	rjmp	.+18     	; 0x1e8 <GPIO_PinWrite+0x4a>
 1d6:	b9 01       	movw	r22, r18
 1d8:	02 c0       	rjmp	.+4      	; 0x1de <GPIO_PinWrite+0x40>
 1da:	66 0f       	add	r22, r22
 1dc:	77 1f       	adc	r23, r23
 1de:	9a 95       	dec	r25
 1e0:	e2 f7       	brpl	.-8      	; 0x1da <GPIO_PinWrite+0x3c>
 1e2:	cb 01       	movw	r24, r22
 1e4:	80 95       	com	r24
 1e6:	84 23       	and	r24, r20
 1e8:	8b bb       	out	0x1b, r24	; 27
 1ea:	08 95       	ret
#endif        

        
#ifdef PORTB
    case 1:
        util_UpdateBit(PORTB,enm_pinNumber,v_pinValue_u8);
 1ec:	48 b3       	in	r20, 0x18	; 24
 1ee:	21 e0       	ldi	r18, 0x01	; 1
 1f0:	30 e0       	ldi	r19, 0x00	; 0
 1f2:	66 23       	and	r22, r22
 1f4:	49 f0       	breq	.+18     	; 0x208 <GPIO_PinWrite+0x6a>
 1f6:	b9 01       	movw	r22, r18
 1f8:	02 c0       	rjmp	.+4      	; 0x1fe <GPIO_PinWrite+0x60>
 1fa:	66 0f       	add	r22, r22
 1fc:	77 1f       	adc	r23, r23
 1fe:	9a 95       	dec	r25
 200:	e2 f7       	brpl	.-8      	; 0x1fa <GPIO_PinWrite+0x5c>
 202:	cb 01       	movw	r24, r22
 204:	84 2b       	or	r24, r20
 206:	09 c0       	rjmp	.+18     	; 0x21a <GPIO_PinWrite+0x7c>
 208:	b9 01       	movw	r22, r18
 20a:	02 c0       	rjmp	.+4      	; 0x210 <GPIO_PinWrite+0x72>
 20c:	66 0f       	add	r22, r22
 20e:	77 1f       	adc	r23, r23
 210:	9a 95       	dec	r25
 212:	e2 f7       	brpl	.-8      	; 0x20c <GPIO_PinWrite+0x6e>
 214:	cb 01       	movw	r24, r22
 216:	80 95       	com	r24
 218:	84 23       	and	r24, r20
 21a:	88 bb       	out	0x18, r24	; 24
 21c:	08 95       	ret
#endif        

        
#ifdef PORTC        
    case 2:
        util_UpdateBit(PORTC,enm_pinNumber,v_pinValue_u8);
 21e:	45 b3       	in	r20, 0x15	; 21
 220:	21 e0       	ldi	r18, 0x01	; 1
 222:	30 e0       	ldi	r19, 0x00	; 0
 224:	66 23       	and	r22, r22
 226:	49 f0       	breq	.+18     	; 0x23a <GPIO_PinWrite+0x9c>
 228:	b9 01       	movw	r22, r18
 22a:	02 c0       	rjmp	.+4      	; 0x230 <GPIO_PinWrite+0x92>
 22c:	66 0f       	add	r22, r22
 22e:	77 1f       	adc	r23, r23
 230:	9a 95       	dec	r25
 232:	e2 f7       	brpl	.-8      	; 0x22c <GPIO_PinWrite+0x8e>
 234:	cb 01       	movw	r24, r22
 236:	84 2b       	or	r24, r20
 238:	09 c0       	rjmp	.+18     	; 0x24c <GPIO_PinWrite+0xae>
 23a:	b9 01       	movw	r22, r18
 23c:	02 c0       	rjmp	.+4      	; 0x242 <GPIO_PinWrite+0xa4>
 23e:	66 0f       	add	r22, r22
 240:	77 1f       	adc	r23, r23
 242:	9a 95       	dec	r25
 244:	e2 f7       	brpl	.-8      	; 0x23e <GPIO_PinWrite+0xa0>
 246:	cb 01       	movw	r24, r22
 248:	80 95       	com	r24
 24a:	84 23       	and	r24, r20
 24c:	85 bb       	out	0x15, r24	; 21
 24e:	08 95       	ret
#endif        

        
#ifdef PORTD        
    case 3:
        util_UpdateBit(PORTD,enm_pinNumber,v_pinValue_u8);
 250:	42 b3       	in	r20, 0x12	; 18
 252:	21 e0       	ldi	r18, 0x01	; 1
 254:	30 e0       	ldi	r19, 0x00	; 0
 256:	66 23       	and	r22, r22
 258:	49 f0       	breq	.+18     	; 0x26c <GPIO_PinWrite+0xce>
 25a:	b9 01       	movw	r22, r18
 25c:	02 c0       	rjmp	.+4      	; 0x262 <GPIO_PinWrite+0xc4>
 25e:	66 0f       	add	r22, r22
 260:	77 1f       	adc	r23, r23
 262:	9a 95       	dec	r25
 264:	e2 f7       	brpl	.-8      	; 0x25e <GPIO_PinWrite+0xc0>
 266:	cb 01       	movw	r24, r22
 268:	84 2b       	or	r24, r20
 26a:	09 c0       	rjmp	.+18     	; 0x27e <GPIO_PinWrite+0xe0>
 26c:	b9 01       	movw	r22, r18
 26e:	02 c0       	rjmp	.+4      	; 0x274 <GPIO_PinWrite+0xd6>
 270:	66 0f       	add	r22, r22
 272:	77 1f       	adc	r23, r23
 274:	9a 95       	dec	r25
 276:	e2 f7       	brpl	.-8      	; 0x270 <GPIO_PinWrite+0xd2>
 278:	cb 01       	movw	r24, r22
 27a:	80 95       	com	r24
 27c:	84 23       	and	r24, r20
 27e:	82 bb       	out	0x12, r24	; 18
 280:	08 95       	ret

00000282 <GPIO_PinRead>:
{
    uint8_t v_portNumber_u8;
    uint8_t returnStatus = 0;

    v_portNumber_u8 =  (enm_pinNumber>>3); // Divide the pin number by 8 go get the PORT number
    enm_pinNumber  =     enm_pinNumber & 0x07; // lower 3-bits contains the bit number of a byte 
 282:	28 2f       	mov	r18, r24
 284:	27 70       	andi	r18, 0x07	; 7
uint8_t GPIO_PinRead(gpioPins_et enm_pinNumber)
{
    uint8_t v_portNumber_u8;
    uint8_t returnStatus = 0;

    v_portNumber_u8 =  (enm_pinNumber>>3); // Divide the pin number by 8 go get the PORT number
 286:	86 95       	lsr	r24
 288:	86 95       	lsr	r24
 28a:	86 95       	lsr	r24
    enm_pinNumber  =     enm_pinNumber & 0x07; // lower 3-bits contains the bit number of a byte 

    /* Go to particular port after decoding from the pin number and read the pins status */
    switch(v_portNumber_u8)     
 28c:	81 30       	cpi	r24, 0x01	; 1
 28e:	49 f0       	breq	.+18     	; 0x2a2 <GPIO_PinRead+0x20>
 290:	30 f0       	brcs	.+12     	; 0x29e <GPIO_PinRead+0x1c>
 292:	82 30       	cpi	r24, 0x02	; 2
 294:	41 f0       	breq	.+16     	; 0x2a6 <GPIO_PinRead+0x24>
 296:	83 30       	cpi	r24, 0x03	; 3
 298:	79 f4       	brne	.+30     	; 0x2b8 <GPIO_PinRead+0x36>
#endif        
        
        
#ifdef PIND
    case 3:
        returnStatus = util_IsBitSet(PIND,enm_pinNumber);
 29a:	80 b3       	in	r24, 0x10	; 16
 29c:	05 c0       	rjmp	.+10     	; 0x2a8 <GPIO_PinRead+0x26>
    /* Go to particular port after decoding from the pin number and read the pins status */
    switch(v_portNumber_u8)     
    { 
#ifdef PINA    
    case 0: 
        returnStatus = util_IsBitSet(PINA,enm_pinNumber);
 29e:	89 b3       	in	r24, 0x19	; 25
 2a0:	03 c0       	rjmp	.+6      	; 0x2a8 <GPIO_PinRead+0x26>
        break;
#endif        

#ifdef PINB
    case 1:
        returnStatus = util_IsBitSet(PINB,enm_pinNumber);
 2a2:	86 b3       	in	r24, 0x16	; 22
 2a4:	01 c0       	rjmp	.+2      	; 0x2a8 <GPIO_PinRead+0x26>
        break;
#endif          

#ifdef PINC
    case 2:
        returnStatus = util_IsBitSet(PINC,enm_pinNumber);
 2a6:	83 b3       	in	r24, 0x13	; 19
#endif        
        
        
#ifdef PIND
    case 3:
        returnStatus = util_IsBitSet(PIND,enm_pinNumber);
 2a8:	90 e0       	ldi	r25, 0x00	; 0
 2aa:	02 c0       	rjmp	.+4      	; 0x2b0 <GPIO_PinRead+0x2e>
 2ac:	95 95       	asr	r25
 2ae:	87 95       	ror	r24
 2b0:	2a 95       	dec	r18
 2b2:	e2 f7       	brpl	.-8      	; 0x2ac <GPIO_PinRead+0x2a>
 2b4:	81 70       	andi	r24, 0x01	; 1
        break;
 2b6:	08 95       	ret
                Before reading the pins status, the pin should be configured as INPUT 
 ***************************************************************************************************/
uint8_t GPIO_PinRead(gpioPins_et enm_pinNumber)
{
    uint8_t v_portNumber_u8;
    uint8_t returnStatus = 0;
 2b8:	80 e0       	ldi	r24, 0x00	; 0
        returnStatus = util_IsBitSet(PING,enm_pinNumber);
        break;
#endif             
    }                         
    return returnStatus;
}
 2ba:	08 95       	ret

000002bc <lcd_SendHigherNibble>:
 * Return value    : none

 * description : This functions is used to send the higher nibble of the data to LCD in 4-bit mode
**************************************************************************************************/
static void lcd_SendHigherNibble(uint8_t dataByte)
{
 2bc:	0f 93       	push	r16
 2be:	1f 93       	push	r17
 2c0:	cf 93       	push	r28
 2c2:	c8 2f       	mov	r28, r24
    GPIO_PinWrite(LCDConfig.D4,util_IsBitSet(dataByte,4));
 2c4:	84 fb       	bst	r24, 4
 2c6:	66 27       	eor	r22, r22
 2c8:	60 f9       	bld	r22, 0
 2ca:	0c e9       	ldi	r16, 0x9C	; 156
 2cc:	10 e0       	ldi	r17, 0x00	; 0
 2ce:	f8 01       	movw	r30, r16
 2d0:	82 85       	ldd	r24, Z+10	; 0x0a
 2d2:	0e 94 cf 00 	call	0x19e	; 0x19e <GPIO_PinWrite>
    GPIO_PinWrite(LCDConfig.D5,util_IsBitSet(dataByte,5));
 2d6:	c5 fb       	bst	r28, 5
 2d8:	66 27       	eor	r22, r22
 2da:	60 f9       	bld	r22, 0
 2dc:	f8 01       	movw	r30, r16
 2de:	83 85       	ldd	r24, Z+11	; 0x0b
 2e0:	0e 94 cf 00 	call	0x19e	; 0x19e <GPIO_PinWrite>
    GPIO_PinWrite(LCDConfig.D6,util_IsBitSet(dataByte,6));
 2e4:	c6 fb       	bst	r28, 6
 2e6:	66 27       	eor	r22, r22
 2e8:	60 f9       	bld	r22, 0
 2ea:	f8 01       	movw	r30, r16
 2ec:	84 85       	ldd	r24, Z+12	; 0x0c
 2ee:	0e 94 cf 00 	call	0x19e	; 0x19e <GPIO_PinWrite>
    GPIO_PinWrite(LCDConfig.D7,util_IsBitSet(dataByte,7));
 2f2:	6c 2f       	mov	r22, r28
 2f4:	66 1f       	adc	r22, r22
 2f6:	66 27       	eor	r22, r22
 2f8:	66 1f       	adc	r22, r22
 2fa:	f8 01       	movw	r30, r16
 2fc:	85 85       	ldd	r24, Z+13	; 0x0d
}
 2fe:	cf 91       	pop	r28
 300:	1f 91       	pop	r17
 302:	0f 91       	pop	r16
static void lcd_SendHigherNibble(uint8_t dataByte)
{
    GPIO_PinWrite(LCDConfig.D4,util_IsBitSet(dataByte,4));
    GPIO_PinWrite(LCDConfig.D5,util_IsBitSet(dataByte,5));
    GPIO_PinWrite(LCDConfig.D6,util_IsBitSet(dataByte,6));
    GPIO_PinWrite(LCDConfig.D7,util_IsBitSet(dataByte,7));
 304:	0c 94 cf 00 	jmp	0x19e	; 0x19e <GPIO_PinWrite>

00000308 <lcd_SendCmdSignals>:
 * Return value    : none

 * description : This functions generates the signals for sending the v_lcdCmd_u8 to LCD
**************************************************************************************************/
static void lcd_SendCmdSignals(void)
{
 308:	cf 93       	push	r28
 30a:	df 93       	push	r29
     GPIO_PinWrite(LCDConfig.RS,0);
 30c:	cc e9       	ldi	r28, 0x9C	; 156
 30e:	d0 e0       	ldi	r29, 0x00	; 0
 310:	60 e0       	ldi	r22, 0x00	; 0
 312:	8b 81       	ldd	r24, Y+3	; 0x03
 314:	0e 94 cf 00 	call	0x19e	; 0x19e <GPIO_PinWrite>
     GPIO_PinWrite(LCDConfig.RW,0);
 318:	60 e0       	ldi	r22, 0x00	; 0
 31a:	8c 81       	ldd	r24, Y+4	; 0x04
 31c:	0e 94 cf 00 	call	0x19e	; 0x19e <GPIO_PinWrite>
     GPIO_PinWrite(LCDConfig.EN,1);
 320:	61 e0       	ldi	r22, 0x01	; 1
 322:	8d 81       	ldd	r24, Y+5	; 0x05
 324:	0e 94 cf 00 	call	0x19e	; 0x19e <GPIO_PinWrite>
     DELAY_us(10);
 328:	8a e0       	ldi	r24, 0x0A	; 10
 32a:	90 e0       	ldi	r25, 0x00	; 0
 32c:	0e 94 49 00 	call	0x92	; 0x92 <DELAY_us>
     GPIO_PinWrite(LCDConfig.EN,0);
 330:	60 e0       	ldi	r22, 0x00	; 0
 332:	8d 81       	ldd	r24, Y+5	; 0x05
  
}
 334:	df 91       	pop	r29
 336:	cf 91       	pop	r28
{
     GPIO_PinWrite(LCDConfig.RS,0);
     GPIO_PinWrite(LCDConfig.RW,0);
     GPIO_PinWrite(LCDConfig.EN,1);
     DELAY_us(10);
     GPIO_PinWrite(LCDConfig.EN,0);
 338:	0c 94 cf 00 	jmp	0x19e	; 0x19e <GPIO_PinWrite>

0000033c <lcd_SendLowerNibble>:
 * Return value    : none

 * description : This functions is used to send the lower nibble of the data to LCD
**************************************************************************************************/
static void lcd_SendLowerNibble(uint8_t dataByte)
{
 33c:	0f 93       	push	r16
 33e:	1f 93       	push	r17
 340:	cf 93       	push	r28
 342:	c8 2f       	mov	r28, r24
    GPIO_PinWrite(LCDConfig.D0,util_IsBitSet(dataByte,0));
 344:	68 2f       	mov	r22, r24
 346:	61 70       	andi	r22, 0x01	; 1
 348:	0c e9       	ldi	r16, 0x9C	; 156
 34a:	10 e0       	ldi	r17, 0x00	; 0
 34c:	f8 01       	movw	r30, r16
 34e:	86 81       	ldd	r24, Z+6	; 0x06
 350:	0e 94 cf 00 	call	0x19e	; 0x19e <GPIO_PinWrite>
    GPIO_PinWrite(LCDConfig.D1,util_IsBitSet(dataByte,1));
 354:	c1 fb       	bst	r28, 1
 356:	66 27       	eor	r22, r22
 358:	60 f9       	bld	r22, 0
 35a:	f8 01       	movw	r30, r16
 35c:	87 81       	ldd	r24, Z+7	; 0x07
 35e:	0e 94 cf 00 	call	0x19e	; 0x19e <GPIO_PinWrite>
    GPIO_PinWrite(LCDConfig.D2,util_IsBitSet(dataByte,2));
 362:	c2 fb       	bst	r28, 2
 364:	66 27       	eor	r22, r22
 366:	60 f9       	bld	r22, 0
 368:	f8 01       	movw	r30, r16
 36a:	80 85       	ldd	r24, Z+8	; 0x08
 36c:	0e 94 cf 00 	call	0x19e	; 0x19e <GPIO_PinWrite>
    GPIO_PinWrite(LCDConfig.D3,util_IsBitSet(dataByte,3));
 370:	c3 fb       	bst	r28, 3
 372:	66 27       	eor	r22, r22
 374:	60 f9       	bld	r22, 0
 376:	f8 01       	movw	r30, r16
 378:	81 85       	ldd	r24, Z+9	; 0x09
}
 37a:	cf 91       	pop	r28
 37c:	1f 91       	pop	r17
 37e:	0f 91       	pop	r16
static void lcd_SendLowerNibble(uint8_t dataByte)
{
    GPIO_PinWrite(LCDConfig.D0,util_IsBitSet(dataByte,0));
    GPIO_PinWrite(LCDConfig.D1,util_IsBitSet(dataByte,1));
    GPIO_PinWrite(LCDConfig.D2,util_IsBitSet(dataByte,2));
    GPIO_PinWrite(LCDConfig.D3,util_IsBitSet(dataByte,3));
 380:	0c 94 cf 00 	jmp	0x19e	; 0x19e <GPIO_PinWrite>

00000384 <lcd_SendDataSignals>:
 * Return value    : none

 * description : This functions generates the signals for sending the Data to LCD
**************************************************************************************************/
static void lcd_SendDataSignals(void)
{
 384:	cf 93       	push	r28
 386:	df 93       	push	r29
     GPIO_PinWrite(LCDConfig.RS,1);
 388:	cc e9       	ldi	r28, 0x9C	; 156
 38a:	d0 e0       	ldi	r29, 0x00	; 0
 38c:	61 e0       	ldi	r22, 0x01	; 1
 38e:	8b 81       	ldd	r24, Y+3	; 0x03
 390:	0e 94 cf 00 	call	0x19e	; 0x19e <GPIO_PinWrite>
     GPIO_PinWrite(LCDConfig.RW,0);
 394:	60 e0       	ldi	r22, 0x00	; 0
 396:	8c 81       	ldd	r24, Y+4	; 0x04
 398:	0e 94 cf 00 	call	0x19e	; 0x19e <GPIO_PinWrite>
     GPIO_PinWrite(LCDConfig.EN,1);
 39c:	61 e0       	ldi	r22, 0x01	; 1
 39e:	8d 81       	ldd	r24, Y+5	; 0x05
 3a0:	0e 94 cf 00 	call	0x19e	; 0x19e <GPIO_PinWrite>
     DELAY_us(10);
 3a4:	8a e0       	ldi	r24, 0x0A	; 10
 3a6:	90 e0       	ldi	r25, 0x00	; 0
 3a8:	0e 94 49 00 	call	0x92	; 0x92 <DELAY_us>
     GPIO_PinWrite(LCDConfig.EN,0);
 3ac:	60 e0       	ldi	r22, 0x00	; 0
 3ae:	8d 81       	ldd	r24, Y+5	; 0x05
}
 3b0:	df 91       	pop	r29
 3b2:	cf 91       	pop	r28
{
     GPIO_PinWrite(LCDConfig.RS,1);
     GPIO_PinWrite(LCDConfig.RW,0);
     GPIO_PinWrite(LCDConfig.EN,1);
     DELAY_us(10);
     GPIO_PinWrite(LCDConfig.EN,0);
 3b4:	0c 94 cf 00 	jmp	0x19e	; 0x19e <GPIO_PinWrite>

000003b8 <lcd_BusyCheck>:
 * description : This functions is used check whether LCD is busy.
                 It waits till the LCD is busy by polling the LCD busy flag.
                 After completing the previous operation, LCDs clears its internal busy flag.
**************************************************************************************************/
static void lcd_BusyCheck(void)
{
 3b8:	cf 93       	push	r28
    uint8_t busyflag;
 
  if(LCDConfig.RW != P_NC)                         //Perform Busy check if RW pin is used
 3ba:	80 91 a0 00 	lds	r24, 0x00A0
 3be:	8f 3f       	cpi	r24, 0xFF	; 255
 3c0:	09 f4       	brne	.+2      	; 0x3c4 <lcd_BusyCheck+0xc>
 3c2:	44 c0       	rjmp	.+136    	; 0x44c <lcd_BusyCheck+0x94>
   {
    GPIO_PinDirection(LCDConfig.D7,INPUT); // Configure busy pin as input
 3c4:	60 e0       	ldi	r22, 0x00	; 0
 3c6:	80 91 a9 00 	lds	r24, 0x00A9
 3ca:	0e 94 5d 00 	call	0xba	; 0xba <GPIO_PinDirection>
    GPIO_PinWrite(LCDConfig.RS,0);           // Select the Command Register by pulling RS LOW
 3ce:	60 e0       	ldi	r22, 0x00	; 0
 3d0:	80 91 9f 00 	lds	r24, 0x009F
 3d4:	0e 94 cf 00 	call	0x19e	; 0x19e <GPIO_PinWrite>
    GPIO_PinWrite(LCDConfig.RW,1);           // Select the Read Operation for busy flag by setting RW
 3d8:	61 e0       	ldi	r22, 0x01	; 1
 3da:	80 91 a0 00 	lds	r24, 0x00A0
 3de:	0e 94 cf 00 	call	0x19e	; 0x19e <GPIO_PinWrite>
    do
    {

        GPIO_PinWrite(LCDConfig.EN,0);
 3e2:	60 e0       	ldi	r22, 0x00	; 0
 3e4:	80 91 a1 00 	lds	r24, 0x00A1
 3e8:	0e 94 cf 00 	call	0x19e	; 0x19e <GPIO_PinWrite>
        DELAY_us(10);
 3ec:	8a e0       	ldi	r24, 0x0A	; 10
 3ee:	90 e0       	ldi	r25, 0x00	; 0
 3f0:	0e 94 49 00 	call	0x92	; 0x92 <DELAY_us>
        GPIO_PinWrite(LCDConfig.EN,1); 
 3f4:	61 e0       	ldi	r22, 0x01	; 1
 3f6:	80 91 a1 00 	lds	r24, 0x00A1
 3fa:	0e 94 cf 00 	call	0x19e	; 0x19e <GPIO_PinWrite>
        DELAY_us(10);
 3fe:	8a e0       	ldi	r24, 0x0A	; 10
 400:	90 e0       	ldi	r25, 0x00	; 0
 402:	0e 94 49 00 	call	0x92	; 0x92 <DELAY_us>
        busyflag = GPIO_PinRead(LCDConfig.D7);
 406:	80 91 a9 00 	lds	r24, 0x00A9
 40a:	0e 94 41 01 	call	0x282	; 0x282 <GPIO_PinRead>
 40e:	c8 2f       	mov	r28, r24


        if(LCDConfig.v_LcdMode_U8 == 4)
 410:	80 91 9e 00 	lds	r24, 0x009E
 414:	84 30       	cpi	r24, 0x04	; 4
 416:	91 f4       	brne	.+36     	; 0x43c <lcd_BusyCheck+0x84>
        {
            /* Perform extra dummy read for 4-bit */            
            GPIO_PinWrite(LCDConfig.EN,0);
 418:	60 e0       	ldi	r22, 0x00	; 0
 41a:	80 91 a1 00 	lds	r24, 0x00A1
 41e:	0e 94 cf 00 	call	0x19e	; 0x19e <GPIO_PinWrite>
            DELAY_us(10);
 422:	8a e0       	ldi	r24, 0x0A	; 10
 424:	90 e0       	ldi	r25, 0x00	; 0
 426:	0e 94 49 00 	call	0x92	; 0x92 <DELAY_us>
            GPIO_PinWrite(LCDConfig.EN,1); 
 42a:	61 e0       	ldi	r22, 0x01	; 1
 42c:	80 91 a1 00 	lds	r24, 0x00A1
 430:	0e 94 cf 00 	call	0x19e	; 0x19e <GPIO_PinWrite>
            DELAY_us(10);
 434:	8a e0       	ldi	r24, 0x0A	; 10
 436:	90 e0       	ldi	r25, 0x00	; 0
 438:	0e 94 49 00 	call	0x92	; 0x92 <DELAY_us>
        }    
    }while(busyflag!=0);
 43c:	c1 11       	cpse	r28, r1
 43e:	d1 cf       	rjmp	.-94     	; 0x3e2 <lcd_BusyCheck+0x2a>

    GPIO_PinDirection(LCDConfig.D7,OUTPUT); // Configure busy pin as Output
 440:	61 e0       	ldi	r22, 0x01	; 1
 442:	80 91 a9 00 	lds	r24, 0x00A9
 {
    /* Busy flag cannot be read as RW is not available hence Extra delay of 1ms is added 
      to ensure the LCD completes previous operation and ready to receive new commands/data */
    DELAY_ms(1);  
 }
}
 446:	cf 91       	pop	r28
            GPIO_PinWrite(LCDConfig.EN,1); 
            DELAY_us(10);
        }    
    }while(busyflag!=0);

    GPIO_PinDirection(LCDConfig.D7,OUTPUT); // Configure busy pin as Output
 448:	0c 94 5d 00 	jmp	0xba	; 0xba <GPIO_PinDirection>
  }
else
 {
    /* Busy flag cannot be read as RW is not available hence Extra delay of 1ms is added 
      to ensure the LCD completes previous operation and ready to receive new commands/data */
    DELAY_ms(1);  
 44c:	81 e0       	ldi	r24, 0x01	; 1
 44e:	90 e0       	ldi	r25, 0x00	; 0
 }
}
 450:	cf 91       	pop	r28
  }
else
 {
    /* Busy flag cannot be read as RW is not available hence Extra delay of 1ms is added 
      to ensure the LCD completes previous operation and ready to receive new commands/data */
    DELAY_ms(1);  
 452:	0c 94 52 00 	jmp	0xa4	; 0xa4 <DELAY_ms>

00000456 <LCD_SetUp>:
               gpioPins_et D3,
               gpioPins_et D4,
               gpioPins_et D5,
               gpioPins_et D6,
               gpioPins_et D7 )
{
 456:	8f 92       	push	r8
 458:	9f 92       	push	r9
 45a:	af 92       	push	r10
 45c:	bf 92       	push	r11
 45e:	cf 92       	push	r12
 460:	df 92       	push	r13
 462:	ef 92       	push	r14
 464:	ff 92       	push	r15
 466:	0f 93       	push	r16
 468:	1f 93       	push	r17
 46a:	cf 93       	push	r28
 46c:	df 93       	push	r29
 46e:	cd b7       	in	r28, 0x3d	; 61
 470:	de b7       	in	r29, 0x3e	; 62
 472:	98 2e       	mov	r9, r24
 474:	b6 2e       	mov	r11, r22
 476:	d4 2e       	mov	r13, r20
 478:	ff 84       	ldd	r15, Y+15	; 0x0f
 47a:	18 89       	ldd	r17, Y+16	; 0x10
  /* Copy the PIN numbers where the LCD is connected */
    LCDConfig.RS = RS;
 47c:	80 93 9f 00 	sts	0x009F, r24
    LCDConfig.RW = RW;
 480:	60 93 a0 00 	sts	0x00A0, r22
    LCDConfig.EN = EN;
 484:	40 93 a1 00 	sts	0x00A1, r20

    LCDConfig.D0 = D0;
 488:	20 93 a2 00 	sts	0x00A2, r18
    LCDConfig.D1 = D1;
 48c:	00 93 a3 00 	sts	0x00A3, r16
    LCDConfig.D2 = D2;
 490:	e0 92 a4 00 	sts	0x00A4, r14
    LCDConfig.D3 = D3;
 494:	c0 92 a5 00 	sts	0x00A5, r12
    LCDConfig.D4 = D4;
 498:	a0 92 a6 00 	sts	0x00A6, r10
    LCDConfig.D5 = D5;
 49c:	80 92 a7 00 	sts	0x00A7, r8
    LCDConfig.D6 = D6;
 4a0:	f0 92 a8 00 	sts	0x00A8, r15
    LCDConfig.D7 = D7;
 4a4:	10 93 a9 00 	sts	0x00A9, r17


    if((D0 == P_NC) || (D1 == P_NC) || (D2 == P_NC) || (D3 == P_NC))
 4a8:	2f 3f       	cpi	r18, 0xFF	; 255
 4aa:	39 f0       	breq	.+14     	; 0x4ba <LCD_SetUp+0x64>
 4ac:	0f 3f       	cpi	r16, 0xFF	; 255
 4ae:	29 f0       	breq	.+10     	; 0x4ba <LCD_SetUp+0x64>
 4b0:	8f ef       	ldi	r24, 0xFF	; 255
 4b2:	e8 16       	cp	r14, r24
 4b4:	11 f0       	breq	.+4      	; 0x4ba <LCD_SetUp+0x64>
 4b6:	c8 12       	cpse	r12, r24
 4b8:	04 c0       	rjmp	.+8      	; 0x4c2 <LCD_SetUp+0x6c>
    {
        LCDConfig.v_LcdMode_U8 = 4; // Select 4-bit mode as D0-D3 are not used(P_NC)
 4ba:	84 e0       	ldi	r24, 0x04	; 4
 4bc:	80 93 9e 00 	sts	0x009E, r24
 4c0:	13 c0       	rjmp	.+38     	; 0x4e8 <LCD_SetUp+0x92>
    }
    else
    {
        LCDConfig.v_LcdMode_U8 = 8; // 8-bit mode configure D0-D3 as output.      
 4c2:	88 e0       	ldi	r24, 0x08	; 8
 4c4:	80 93 9e 00 	sts	0x009E, r24
        GPIO_PinDirection(D0,OUTPUT);
 4c8:	61 e0       	ldi	r22, 0x01	; 1
 4ca:	82 2f       	mov	r24, r18
 4cc:	0e 94 5d 00 	call	0xba	; 0xba <GPIO_PinDirection>
        GPIO_PinDirection(D1,OUTPUT);
 4d0:	61 e0       	ldi	r22, 0x01	; 1
 4d2:	80 2f       	mov	r24, r16
 4d4:	0e 94 5d 00 	call	0xba	; 0xba <GPIO_PinDirection>
        GPIO_PinDirection(D2,OUTPUT);
 4d8:	61 e0       	ldi	r22, 0x01	; 1
 4da:	8e 2d       	mov	r24, r14
 4dc:	0e 94 5d 00 	call	0xba	; 0xba <GPIO_PinDirection>
        GPIO_PinDirection(D3,OUTPUT);
 4e0:	61 e0       	ldi	r22, 0x01	; 1
 4e2:	8c 2d       	mov	r24, r12
 4e4:	0e 94 5d 00 	call	0xba	; 0xba <GPIO_PinDirection>
    }

    /* Configure RS,RW,EN, D4-D7 as Output for both 4/8-bit mode.*/
    GPIO_PinDirection(RS,OUTPUT);
 4e8:	61 e0       	ldi	r22, 0x01	; 1
 4ea:	89 2d       	mov	r24, r9
 4ec:	0e 94 5d 00 	call	0xba	; 0xba <GPIO_PinDirection>
    GPIO_PinDirection(RW,OUTPUT);
 4f0:	61 e0       	ldi	r22, 0x01	; 1
 4f2:	8b 2d       	mov	r24, r11
 4f4:	0e 94 5d 00 	call	0xba	; 0xba <GPIO_PinDirection>
    GPIO_PinDirection(EN,OUTPUT);
 4f8:	61 e0       	ldi	r22, 0x01	; 1
 4fa:	8d 2d       	mov	r24, r13
 4fc:	0e 94 5d 00 	call	0xba	; 0xba <GPIO_PinDirection>

    GPIO_PinDirection(D4,OUTPUT);
 500:	61 e0       	ldi	r22, 0x01	; 1
 502:	8a 2d       	mov	r24, r10
 504:	0e 94 5d 00 	call	0xba	; 0xba <GPIO_PinDirection>
    GPIO_PinDirection(D5,OUTPUT);
 508:	61 e0       	ldi	r22, 0x01	; 1
 50a:	88 2d       	mov	r24, r8
 50c:	0e 94 5d 00 	call	0xba	; 0xba <GPIO_PinDirection>
    GPIO_PinDirection(D6,OUTPUT);
 510:	61 e0       	ldi	r22, 0x01	; 1
 512:	8f 2d       	mov	r24, r15
 514:	0e 94 5d 00 	call	0xba	; 0xba <GPIO_PinDirection>
    GPIO_PinDirection(D7,OUTPUT);  
 518:	61 e0       	ldi	r22, 0x01	; 1
 51a:	81 2f       	mov	r24, r17
}
 51c:	df 91       	pop	r29
 51e:	cf 91       	pop	r28
 520:	1f 91       	pop	r17
 522:	0f 91       	pop	r16
 524:	ff 90       	pop	r15
 526:	ef 90       	pop	r14
 528:	df 90       	pop	r13
 52a:	cf 90       	pop	r12
 52c:	bf 90       	pop	r11
 52e:	af 90       	pop	r10
 530:	9f 90       	pop	r9
 532:	8f 90       	pop	r8
    GPIO_PinDirection(EN,OUTPUT);

    GPIO_PinDirection(D4,OUTPUT);
    GPIO_PinDirection(D5,OUTPUT);
    GPIO_PinDirection(D6,OUTPUT);
    GPIO_PinDirection(D7,OUTPUT);  
 534:	0c 94 5d 00 	jmp	0xba	; 0xba <GPIO_PinDirection>

00000538 <LCD_CmdWrite>:
                Some of the commonly used commands are defined in lcd.h.
                For more commands refer the data sheet and send the supported command.                
                The behaviour is undefined if unsupported commands are sent.    
****************************************************************************************************/
void LCD_CmdWrite( uint8_t v_lcdCmd_u8)
{
 538:	cf 93       	push	r28
 53a:	c8 2f       	mov	r28, r24
    lcd_BusyCheck();
 53c:	0e 94 dc 01 	call	0x3b8	; 0x3b8 <lcd_BusyCheck>
    if(LCDConfig.v_LcdMode_U8 == C_EightBitMode_U8)
 540:	80 91 9e 00 	lds	r24, 0x009E
 544:	88 30       	cpi	r24, 0x08	; 8
 546:	21 f4       	brne	.+8      	; 0x550 <LCD_CmdWrite+0x18>
     {
         lcd_SendLowerNibble(v_lcdCmd_u8);
 548:	8c 2f       	mov	r24, r28
 54a:	0e 94 9e 01 	call	0x33c	; 0x33c <lcd_SendLowerNibble>
 54e:	07 c0       	rjmp	.+14     	; 0x55e <LCD_CmdWrite+0x26>
     }
     else
     {
         lcd_SendHigherNibble(v_lcdCmd_u8);
 550:	8c 2f       	mov	r24, r28
 552:	0e 94 5e 01 	call	0x2bc	; 0x2bc <lcd_SendHigherNibble>
         lcd_SendCmdSignals();
 556:	0e 94 84 01 	call	0x308	; 0x308 <lcd_SendCmdSignals>
         v_lcdCmd_u8 = v_lcdCmd_u8 << 4;
 55a:	c2 95       	swap	r28
 55c:	c0 7f       	andi	r28, 0xF0	; 240
     }

     lcd_SendHigherNibble(v_lcdCmd_u8);
 55e:	8c 2f       	mov	r24, r28
 560:	0e 94 5e 01 	call	0x2bc	; 0x2bc <lcd_SendHigherNibble>
     lcd_SendCmdSignals();
}
 564:	cf 91       	pop	r28
         lcd_SendCmdSignals();
         v_lcdCmd_u8 = v_lcdCmd_u8 << 4;
     }

     lcd_SendHigherNibble(v_lcdCmd_u8);
     lcd_SendCmdSignals();
 566:	0c 94 84 01 	jmp	0x308	; 0x308 <lcd_SendCmdSignals>

0000056a <LCD_GoToLine>:
           C_LcdLineThree,

****************************************************************************************************/
void LCD_GoToLine(uint8_t v_lineNumber_u8)
{
    if(v_lineNumber_u8 < LCDConfig.v_MaxSupportedLines_U8)
 56a:	90 91 9c 00 	lds	r25, 0x009C
 56e:	89 17       	cp	r24, r25
 570:	58 f4       	brcc	.+22     	; 0x588 <LCD_GoToLine+0x1e>
    {
        /* If the line number is within range then
           Move the Cursor to beginning of the specified line */
        v_LcdTrackCursorPos_U8 = 0x00;
 572:	10 92 aa 00 	sts	0x00AA, r1
        v_LcdTrackLineNum_U8 = v_lineNumber_u8;
 576:	80 93 ab 00 	sts	0x00AB, r24
        LCD_CmdWrite(ARR_LcdLineNumAddress_U8[v_lineNumber_u8]);
 57a:	e8 2f       	mov	r30, r24
 57c:	f0 e0       	ldi	r31, 0x00	; 0
 57e:	e0 5a       	subi	r30, 0xA0	; 160
 580:	ff 4f       	sbci	r31, 0xFF	; 255
 582:	80 81       	ld	r24, Z
 584:	0c 94 9c 02 	jmp	0x538	; 0x538 <LCD_CmdWrite>
 588:	08 95       	ret

0000058a <LCD_Clear>:

 * description  :This function clears the LCD and moves the cursor to beginning of first line
****************************************************************************************************/
void LCD_Clear()
{
    LCD_CmdWrite(CMD_LCD_CLEAR);    // Clear the LCD and go to First line First Position
 58a:	81 e0       	ldi	r24, 0x01	; 1
 58c:	0e 94 9c 02 	call	0x538	; 0x538 <LCD_CmdWrite>
    LCD_GoToLine(C_LcdLineZero);
 590:	80 e0       	ldi	r24, 0x00	; 0
 592:	0c 94 b5 02 	jmp	0x56a	; 0x56a <LCD_GoToLine>

00000596 <LCD_Init>:
**************************************************************************************************/
void LCD_Init(uint8_t v_lcdNoOfLines_u8, uint8_t v_MaxCharsPerLine_u8)
{


    LCDConfig.v_MaxSupportedChars_U8 = v_MaxCharsPerLine_u8; //Maintaian the LCD type
 596:	60 93 9d 00 	sts	0x009D, r22
    LCDConfig.v_MaxSupportedLines_U8 = v_lcdNoOfLines_u8;
 59a:	80 93 9c 00 	sts	0x009C, r24
    if(v_lcdNoOfLines_u8 > C_LcdLineTwo)
 59e:	83 30       	cpi	r24, 0x03	; 3
 5a0:	40 f0       	brcs	.+16     	; 0x5b2 <LCD_Init+0x1c>
    {
        ARR_LcdLineNumAddress_U8[C_LcdLineTwo] =  0x90 + (v_MaxCharsPerLine_u8 & 0x0fu);
 5a2:	6f 70       	andi	r22, 0x0F	; 15
 5a4:	80 e9       	ldi	r24, 0x90	; 144
 5a6:	86 0f       	add	r24, r22
 5a8:	80 93 62 00 	sts	0x0062, r24
        ARR_LcdLineNumAddress_U8[C_LcdLineThree] =  0xd0 + (v_MaxCharsPerLine_u8 & 0x0fu);
 5ac:	60 53       	subi	r22, 0x30	; 48
 5ae:	60 93 63 00 	sts	0x0063, r22
    }

    DELAY_ms(100);
 5b2:	84 e6       	ldi	r24, 0x64	; 100
 5b4:	90 e0       	ldi	r25, 0x00	; 0
 5b6:	0e 94 52 00 	call	0xa4	; 0xa4 <DELAY_ms>

    if(LCDConfig.v_LcdMode_U8 == C_EightBitMode_U8)
 5ba:	80 91 9e 00 	lds	r24, 0x009E
 5be:	88 30       	cpi	r24, 0x08	; 8
 5c0:	11 f4       	brne	.+4      	; 0x5c6 <LCD_Init+0x30>
    {
        LCD_CmdWrite(CMD_LCD_EIGHT_BIT_MODE); // Initialize the LCD for 8-bit 5x7 matrix type
 5c2:	88 e3       	ldi	r24, 0x38	; 56
 5c4:	27 c0       	rjmp	.+78     	; 0x614 <LCD_Init+0x7e>
    }
    else if(LCDConfig.v_LcdMode_U8 == C_FourBitMode_U8)
 5c6:	84 30       	cpi	r24, 0x04	; 4
 5c8:	39 f5       	brne	.+78     	; 0x618 <LCD_Init+0x82>
                 This is used only in 4-bit mode as the LCD by default boots in 8-Bit mode.
----------------------------------------------------------------------------------*/
static void lcd_Reset(void)
{
    /* LCD reset sequence for 4-bit mode, refer data sheet for more info */
    lcd_SendHigherNibble(0x30);
 5ca:	80 e3       	ldi	r24, 0x30	; 48
 5cc:	0e 94 5e 01 	call	0x2bc	; 0x2bc <lcd_SendHigherNibble>
    lcd_SendCmdSignals();
 5d0:	0e 94 84 01 	call	0x308	; 0x308 <lcd_SendCmdSignals>
    DELAY_ms(100);
 5d4:	84 e6       	ldi	r24, 0x64	; 100
 5d6:	90 e0       	ldi	r25, 0x00	; 0
 5d8:	0e 94 52 00 	call	0xa4	; 0xa4 <DELAY_ms>
    lcd_SendHigherNibble(0x30);
 5dc:	80 e3       	ldi	r24, 0x30	; 48
 5de:	0e 94 5e 01 	call	0x2bc	; 0x2bc <lcd_SendHigherNibble>
    lcd_SendCmdSignals();
 5e2:	0e 94 84 01 	call	0x308	; 0x308 <lcd_SendCmdSignals>
    DELAY_us(200);
 5e6:	88 ec       	ldi	r24, 0xC8	; 200
 5e8:	90 e0       	ldi	r25, 0x00	; 0
 5ea:	0e 94 49 00 	call	0x92	; 0x92 <DELAY_us>
    lcd_SendHigherNibble(0x30);
 5ee:	80 e3       	ldi	r24, 0x30	; 48
 5f0:	0e 94 5e 01 	call	0x2bc	; 0x2bc <lcd_SendHigherNibble>
    lcd_SendCmdSignals();
 5f4:	0e 94 84 01 	call	0x308	; 0x308 <lcd_SendCmdSignals>
    DELAY_us(200);
 5f8:	88 ec       	ldi	r24, 0xC8	; 200
 5fa:	90 e0       	ldi	r25, 0x00	; 0
 5fc:	0e 94 49 00 	call	0x92	; 0x92 <DELAY_us>
    lcd_SendHigherNibble(0x20);
 600:	80 e2       	ldi	r24, 0x20	; 32
 602:	0e 94 5e 01 	call	0x2bc	; 0x2bc <lcd_SendHigherNibble>
    lcd_SendCmdSignals();
 606:	0e 94 84 01 	call	0x308	; 0x308 <lcd_SendCmdSignals>
    DELAY_us(200);
 60a:	88 ec       	ldi	r24, 0xC8	; 200
 60c:	90 e0       	ldi	r25, 0x00	; 0
 60e:	0e 94 49 00 	call	0x92	; 0x92 <DELAY_us>
        LCD_CmdWrite(CMD_LCD_EIGHT_BIT_MODE); // Initialize the LCD for 8-bit 5x7 matrix type
    }
    else if(LCDConfig.v_LcdMode_U8 == C_FourBitMode_U8)
    {
        lcd_Reset();
        LCD_CmdWrite(CMD_LCD_FOUR_BIT_MODE); // Initialize the LCD for 4-bit 5x7 matrix type 
 612:	88 e2       	ldi	r24, 0x28	; 40
 614:	0e 94 9c 02 	call	0x538	; 0x538 <LCD_CmdWrite>
    }

    LCD_CmdWrite(CMD_DISPLAY_ON_CURSOR_ON);     // Display ON cursor ON
 618:	8e e0       	ldi	r24, 0x0E	; 14
 61a:	0e 94 9c 02 	call	0x538	; 0x538 <LCD_CmdWrite>
    LCD_Clear();                             // Clear the LCD and go to First line First Position
 61e:	0c 94 c5 02 	jmp	0x58a	; 0x58a <LCD_Clear>

00000622 <LCD_GoToNextLine>:
****************************************************************************************************/
void  LCD_GoToNextLine(void)
{
    /*Increment the current line number.
      In case it exceeds the limit, rool it back to first line */
    v_LcdTrackLineNum_U8++;
 622:	80 91 ab 00 	lds	r24, 0x00AB
 626:	8f 5f       	subi	r24, 0xFF	; 255
 628:	80 93 ab 00 	sts	0x00AB, r24
    v_LcdTrackCursorPos_U8 = 0x00;
 62c:	10 92 aa 00 	sts	0x00AA, r1
    if(v_LcdTrackLineNum_U8 >= LCDConfig.v_MaxSupportedLines_U8)
 630:	90 91 9c 00 	lds	r25, 0x009C
 634:	89 17       	cp	r24, r25
 636:	10 f0       	brcs	.+4      	; 0x63c <LCD_GoToNextLine+0x1a>
        v_LcdTrackLineNum_U8 = C_LcdLineZero;
 638:	10 92 ab 00 	sts	0x00AB, r1
    LCD_CmdWrite(ARR_LcdLineNumAddress_U8[v_LcdTrackLineNum_U8]);
 63c:	e0 91 ab 00 	lds	r30, 0x00AB
 640:	f0 e0       	ldi	r31, 0x00	; 0
 642:	e0 5a       	subi	r30, 0xA0	; 160
 644:	ff 4f       	sbci	r31, 0xFF	; 255
 646:	80 81       	ld	r24, Z
 648:	0c 94 9c 02 	jmp	0x538	; 0x538 <LCD_CmdWrite>

0000064c <LCD_DisplayChar>:
 * description  : This function sends a character to be displayed on LCD.
                  Any valid ascii value can be passed to display respective character

****************************************************************************************************/
void LCD_DisplayChar(char v_lcdData_u8)
{
 64c:	cf 93       	push	r28
 64e:	c8 2f       	mov	r28, r24
    if((v_LcdTrackCursorPos_U8>=LCDConfig.v_MaxSupportedChars_U8) || (v_lcdData_u8=='\n'))
 650:	90 91 aa 00 	lds	r25, 0x00AA
 654:	80 91 9d 00 	lds	r24, 0x009D
 658:	98 17       	cp	r25, r24
 65a:	60 f4       	brcc	.+24     	; 0x674 <LCD_DisplayChar+0x28>
 65c:	ca 30       	cpi	r28, 0x0A	; 10
 65e:	51 f0       	breq	.+20     	; 0x674 <LCD_DisplayChar+0x28>

 * description : This functions is used to send a byte of data to LCD.                 .    
**************************************************************************************************/
static void lcd_DataWrite( uint8_t dataByte)
{
    lcd_BusyCheck();
 660:	0e 94 dc 01 	call	0x3b8	; 0x3b8 <lcd_BusyCheck>
    if(LCDConfig.v_LcdMode_U8 == C_EightBitMode_U8)
 664:	80 91 9e 00 	lds	r24, 0x009E
 668:	88 30       	cpi	r24, 0x08	; 8
 66a:	49 f4       	brne	.+18     	; 0x67e <LCD_DisplayChar+0x32>
     {
         lcd_SendLowerNibble(dataByte);
 66c:	8c 2f       	mov	r24, r28
 66e:	0e 94 9e 01 	call	0x33c	; 0x33c <lcd_SendLowerNibble>
 672:	0c c0       	rjmp	.+24     	; 0x68c <LCD_DisplayChar+0x40>
{
    if((v_LcdTrackCursorPos_U8>=LCDConfig.v_MaxSupportedChars_U8) || (v_lcdData_u8=='\n'))
    {
        /* If the cursor has reached to end of line on page1
        OR NewLine command is issued Then Move the cursor to next line */
        LCD_GoToNextLine();
 674:	0e 94 11 03 	call	0x622	; 0x622 <LCD_GoToNextLine>
    }
    if(v_lcdData_u8!='\n') /* Display the character if its not newLine Char */
 678:	ca 30       	cpi	r28, 0x0A	; 10
 67a:	91 f0       	breq	.+36     	; 0x6a0 <LCD_DisplayChar+0x54>
 67c:	f1 cf       	rjmp	.-30     	; 0x660 <LCD_DisplayChar+0x14>
     {
         lcd_SendLowerNibble(dataByte);
     }
     else
     {
         lcd_SendHigherNibble(dataByte);
 67e:	8c 2f       	mov	r24, r28
 680:	0e 94 5e 01 	call	0x2bc	; 0x2bc <lcd_SendHigherNibble>
         lcd_SendDataSignals();
 684:	0e 94 c2 01 	call	0x384	; 0x384 <lcd_SendDataSignals>
         dataByte = dataByte << 4;
 688:	c2 95       	swap	r28
 68a:	c0 7f       	andi	r28, 0xF0	; 240
     }

     lcd_SendHigherNibble(dataByte);
 68c:	8c 2f       	mov	r24, r28
 68e:	0e 94 5e 01 	call	0x2bc	; 0x2bc <lcd_SendHigherNibble>
     lcd_SendDataSignals();
 692:	0e 94 c2 01 	call	0x384	; 0x384 <lcd_SendDataSignals>
    }
    if(v_lcdData_u8!='\n') /* Display the character if its not newLine Char */
    {

        lcd_DataWrite(v_lcdData_u8); /* Display the data and keep track of cursor */
        v_LcdTrackCursorPos_U8++;
 696:	80 91 aa 00 	lds	r24, 0x00AA
 69a:	8f 5f       	subi	r24, 0xFF	; 255
 69c:	80 93 aa 00 	sts	0x00AA, r24
    }
}
 6a0:	cf 91       	pop	r28
 6a2:	08 95       	ret

000006a4 <LCD_ScrollMessage>:
                 If the specified line number is out of range then the message
                 will be scrolled on first line
****************************************************************************************************/
#if ( Enable_LCD_ScrollMessage  == 1 )
void LCD_ScrollMessage(uint8_t v_lineNumber_u8, char *ptr_msgPointer_u8)
{
 6a4:	cf 92       	push	r12
 6a6:	df 92       	push	r13
 6a8:	ff 92       	push	r15
 6aa:	0f 93       	push	r16
 6ac:	1f 93       	push	r17
 6ae:	cf 93       	push	r28
 6b0:	df 93       	push	r29
 6b2:	f8 2e       	mov	r15, r24
 6b4:	6b 01       	movw	r12, r22
    unsigned char i,j;


    if(v_lineNumber_u8 >= LCDConfig.v_MaxSupportedLines_U8)
 6b6:	80 91 9c 00 	lds	r24, 0x009C
 6ba:	f8 16       	cp	r15, r24
 6bc:	08 f0       	brcs	.+2      	; 0x6c0 <LCD_ScrollMessage+0x1c>
        v_lineNumber_u8 = C_LcdLineZero; // Select first line if the v_lineNumber_u8 is out of range
 6be:	f1 2c       	mov	r15, r1

    LCD_CmdWrite(CMD_DISPLAY_ON_CURSOR_OFF);             //Disable the Cursor
 6c0:	8c e0       	ldi	r24, 0x0C	; 12
 6c2:	0e 94 9c 02 	call	0x538	; 0x538 <LCD_CmdWrite>

    for(i=0;ptr_msgPointer_u8[i];i++)
 6c6:	d0 e0       	ldi	r29, 0x00	; 0
 6c8:	86 01       	movw	r16, r12
 6ca:	0d 0f       	add	r16, r29
 6cc:	11 1d       	adc	r17, r1
 6ce:	f8 01       	movw	r30, r16
 6d0:	80 81       	ld	r24, Z
 6d2:	88 23       	and	r24, r24
 6d4:	09 f1       	breq	.+66     	; 0x718 <LCD_ScrollMessage+0x74>
    {      
        /* Loop to display the complete string,    each time 16 chars are displayed and
        pointer is incremented to point to next char */


        LCD_GoToLine(v_lineNumber_u8);     //Move the Cursor to first line
 6d6:	8f 2d       	mov	r24, r15
 6d8:	0e 94 b5 02 	call	0x56a	; 0x56a <LCD_GoToLine>

        for(j=0;(j<LCDConfig.v_MaxSupportedChars_U8) && (ptr_msgPointer_u8[i+j]);j++)
 6dc:	c0 e0       	ldi	r28, 0x00	; 0
 6de:	80 91 9d 00 	lds	r24, 0x009D
 6e2:	c8 17       	cp	r28, r24
 6e4:	50 f4       	brcc	.+20     	; 0x6fa <LCD_ScrollMessage+0x56>
 6e6:	f8 01       	movw	r30, r16
 6e8:	ec 0f       	add	r30, r28
 6ea:	f1 1d       	adc	r31, r1
 6ec:	80 81       	ld	r24, Z
 6ee:	88 23       	and	r24, r24
 6f0:	21 f0       	breq	.+8      	; 0x6fa <LCD_ScrollMessage+0x56>
        {
            //Display first 16 Chars or till Null char is reached
            LCD_DisplayChar(ptr_msgPointer_u8[i+j]);
 6f2:	0e 94 26 03 	call	0x64c	; 0x64c <LCD_DisplayChar>
        pointer is incremented to point to next char */


        LCD_GoToLine(v_lineNumber_u8);     //Move the Cursor to first line

        for(j=0;(j<LCDConfig.v_MaxSupportedChars_U8) && (ptr_msgPointer_u8[i+j]);j++)
 6f6:	cf 5f       	subi	r28, 0xFF	; 255
 6f8:	f2 cf       	rjmp	.-28     	; 0x6de <LCD_ScrollMessage+0x3a>
            //Display first 16 Chars or till Null char is reached
            LCD_DisplayChar(ptr_msgPointer_u8[i+j]);
        }


        while( j<LCDConfig.v_MaxSupportedChars_U8)
 6fa:	80 91 9d 00 	lds	r24, 0x009D
 6fe:	c8 17       	cp	r28, r24
 700:	28 f4       	brcc	.+10     	; 0x70c <LCD_ScrollMessage+0x68>
        {
            /*If the chars to be scrolled are less than MaxLcdChars,
              then display remaining chars with blank spaces*/
            LCD_DisplayChar(' ');
 702:	80 e2       	ldi	r24, 0x20	; 32
 704:	0e 94 26 03 	call	0x64c	; 0x64c <LCD_DisplayChar>
            j++;
 708:	cf 5f       	subi	r28, 0xFF	; 255
 70a:	f7 cf       	rjmp	.-18     	; 0x6fa <LCD_ScrollMessage+0x56>
        }

        DELAY_ms(C_ScrollDelayTime_U8);
 70c:	88 ec       	ldi	r24, 0xC8	; 200
 70e:	90 e0       	ldi	r25, 0x00	; 0
 710:	0e 94 52 00 	call	0xa4	; 0xa4 <DELAY_ms>
    if(v_lineNumber_u8 >= LCDConfig.v_MaxSupportedLines_U8)
        v_lineNumber_u8 = C_LcdLineZero; // Select first line if the v_lineNumber_u8 is out of range

    LCD_CmdWrite(CMD_DISPLAY_ON_CURSOR_OFF);             //Disable the Cursor

    for(i=0;ptr_msgPointer_u8[i];i++)
 714:	df 5f       	subi	r29, 0xFF	; 255
 716:	d8 cf       	rjmp	.-80     	; 0x6c8 <LCD_ScrollMessage+0x24>
            j++;
        }

        DELAY_ms(C_ScrollDelayTime_U8);
    }
    LCD_CmdWrite(CMD_DISPLAY_ON_CURSOR_ON);              // Finally enable the Cursor
 718:	8e e0       	ldi	r24, 0x0E	; 14
}
 71a:	df 91       	pop	r29
 71c:	cf 91       	pop	r28
 71e:	1f 91       	pop	r17
 720:	0f 91       	pop	r16
 722:	ff 90       	pop	r15
 724:	df 90       	pop	r13
 726:	cf 90       	pop	r12
            j++;
        }

        DELAY_ms(C_ScrollDelayTime_U8);
    }
    LCD_CmdWrite(CMD_DISPLAY_ON_CURSOR_ON);              // Finally enable the Cursor
 728:	0c 94 9c 02 	jmp	0x538	; 0x538 <LCD_CmdWrite>

0000072c <main>:
 */
int main() 
{
    
    /*Connect RS->PB0, RW->PB1, EN->PB2 and data bus to PORTB.4 to PORTB.7*/
    LCD_SetUp(PB_0,PB_1,PB_2,P_NC,P_NC,P_NC,P_NC,PB_4,PB_5,PB_6,PB_7);
 72c:	8f e0       	ldi	r24, 0x0F	; 15
 72e:	8f 93       	push	r24
 730:	8e e0       	ldi	r24, 0x0E	; 14
 732:	8f 93       	push	r24
 734:	8d e0       	ldi	r24, 0x0D	; 13
 736:	88 2e       	mov	r8, r24
 738:	9c e0       	ldi	r25, 0x0C	; 12
 73a:	a9 2e       	mov	r10, r25
 73c:	cc 24       	eor	r12, r12
 73e:	ca 94       	dec	r12
 740:	ee 24       	eor	r14, r14
 742:	ea 94       	dec	r14
 744:	0f ef       	ldi	r16, 0xFF	; 255
 746:	2f ef       	ldi	r18, 0xFF	; 255
 748:	4a e0       	ldi	r20, 0x0A	; 10
 74a:	69 e0       	ldi	r22, 0x09	; 9
 74c:	88 e0       	ldi	r24, 0x08	; 8
 74e:	0e 94 2b 02 	call	0x456	; 0x456 <LCD_SetUp>
    LCD_Init(2,16);
 752:	60 e1       	ldi	r22, 0x10	; 16
 754:	82 e0       	ldi	r24, 0x02	; 2
 756:	0e 94 cb 02 	call	0x596	; 0x596 <LCD_Init>
 75a:	0f 90       	pop	r0
 75c:	0f 90       	pop	r0

    while(1)
    {
        LCD_ScrollMessage(0,"        Welcome to AVR programming by Explore Embedded ");
 75e:	64 e6       	ldi	r22, 0x64	; 100
 760:	70 e0       	ldi	r23, 0x00	; 0
 762:	80 e0       	ldi	r24, 0x00	; 0
 764:	0e 94 52 03 	call	0x6a4	; 0x6a4 <LCD_ScrollMessage>
    }
 768:	fa cf       	rjmp	.-12     	; 0x75e <main+0x32>

0000076a <_exit>:
 76a:	f8 94       	cli

0000076c <__stop_program>:
 76c:	ff cf       	rjmp	.-2      	; 0x76c <__stop_program>
