
05b-Lcd_4bit_UpCounter.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000f52  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000016  00800060  00000f52  00000fe6  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000010  00800076  00800076  00000ffc  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000ffc  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  0000102c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000120  00000000  00000000  00001068  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00001846  00000000  00000000  00001188  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000005d1  00000000  00000000  000029ce  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000671  00000000  00000000  00002f9f  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000380  00000000  00000000  00003610  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000006c1  00000000  00000000  00003990  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000016d2  00000000  00000000  00004051  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000128  00000000  00000000  00005723  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
   4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
   8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
   c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  1c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
  54:	11 24       	eor	r1, r1
  56:	1f be       	out	0x3f, r1	; 63
  58:	cf e5       	ldi	r28, 0x5F	; 95
  5a:	d8 e0       	ldi	r29, 0x08	; 8
  5c:	de bf       	out	0x3e, r29	; 62
  5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
  60:	10 e0       	ldi	r17, 0x00	; 0
  62:	a0 e6       	ldi	r26, 0x60	; 96
  64:	b0 e0       	ldi	r27, 0x00	; 0
  66:	e2 e5       	ldi	r30, 0x52	; 82
  68:	ff e0       	ldi	r31, 0x0F	; 15
  6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
  6c:	05 90       	lpm	r0, Z+
  6e:	0d 92       	st	X+, r0
  70:	a6 37       	cpi	r26, 0x76	; 118
  72:	b1 07       	cpc	r27, r17
  74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
  76:	20 e0       	ldi	r18, 0x00	; 0
  78:	a6 e7       	ldi	r26, 0x76	; 118
  7a:	b0 e0       	ldi	r27, 0x00	; 0
  7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
  7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
  80:	a6 38       	cpi	r26, 0x86	; 134
  82:	b2 07       	cpc	r27, r18
  84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
  86:	0e 94 ba 05 	call	0xb74	; 0xb74 <main>
  8a:	0c 94 a7 07 	jmp	0xf4e	; 0xf4e <_exit>

0000008e <__bad_interrupt>:
  8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <DELAY_us>:
         if 5000 is passed as the argument then it generates a delay of 5ms.		  

 ***************************************************************************************************/
void DELAY_us(uint16_t us_count) 
{
    while (us_count != 0) 
  92:	00 97       	sbiw	r24, 0x00	; 0
  94:	31 f0       	breq	.+12     	; 0xa2 <DELAY_us+0x10>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
  96:	25 e0       	ldi	r18, 0x05	; 5
  98:	2a 95       	dec	r18
  9a:	f1 f7       	brne	.-4      	; 0x98 <DELAY_us+0x6>
  9c:	00 00       	nop
    {
        _delay_us(1);
		us_count--;
  9e:	01 97       	sbiw	r24, 0x01	; 1
  a0:	f8 cf       	rjmp	.-16     	; 0x92 <DELAY_us>
    }
}
  a2:	08 95       	ret

000000a4 <DELAY_ms>:
     It generates a delay of 1ms for each count,
     if 1000 is passed as the argument then it generates delay of 1000ms(1sec)
 ***************************************************************************************************/
void DELAY_ms(uint16_t ms_count) 
{
    while (ms_count != 0) 
  a4:	00 97       	sbiw	r24, 0x00	; 0
  a6:	41 f0       	breq	.+16     	; 0xb8 <DELAY_ms+0x14>
  a8:	ef e9       	ldi	r30, 0x9F	; 159
  aa:	ff e0       	ldi	r31, 0x0F	; 15
  ac:	31 97       	sbiw	r30, 0x01	; 1
  ae:	f1 f7       	brne	.-4      	; 0xac <DELAY_ms+0x8>
  b0:	00 c0       	rjmp	.+0      	; 0xb2 <DELAY_ms+0xe>
  b2:	00 00       	nop
    {
        _delay_us(1000); //DELAY_us is called to generate 1ms delay
        ms_count--;
  b4:	01 97       	sbiw	r24, 0x01	; 1
  b6:	f6 cf       	rjmp	.-20     	; 0xa4 <DELAY_ms>
    }
}
  b8:	08 95       	ret

000000ba <GPIO_PinDirection>:

    uint8_t v_portNumber_u8;


    v_portNumber_u8 =  (enm_pinNumber>>3);  // Divide the pin number by 8 go get the PORT number
    enm_pinNumber  =   enm_pinNumber & 0x07;  // lower 3-bits contains the bit number of a byte 
  ba:	98 2f       	mov	r25, r24
  bc:	97 70       	andi	r25, 0x07	; 7
{

    uint8_t v_portNumber_u8;


    v_portNumber_u8 =  (enm_pinNumber>>3);  // Divide the pin number by 8 go get the PORT number
  be:	86 95       	lsr	r24
  c0:	86 95       	lsr	r24
  c2:	86 95       	lsr	r24
    enm_pinNumber  =   enm_pinNumber & 0x07;  // lower 3-bits contains the bit number of a byte 

    /* Go to particular port after decoding from the pin number and 
        set the direction as specified*/
    switch(v_portNumber_u8)
  c4:	81 30       	cpi	r24, 0x01	; 1
  c6:	01 f1       	breq	.+64     	; 0x108 <GPIO_PinDirection+0x4e>
  c8:	30 f0       	brcs	.+12     	; 0xd6 <GPIO_PinDirection+0x1c>
  ca:	82 30       	cpi	r24, 0x02	; 2
  cc:	b1 f1       	breq	.+108    	; 0x13a <GPIO_PinDirection+0x80>
  ce:	83 30       	cpi	r24, 0x03	; 3
  d0:	09 f4       	brne	.+2      	; 0xd4 <GPIO_PinDirection+0x1a>
  d2:	4c c0       	rjmp	.+152    	; 0x16c <GPIO_PinDirection+0xb2>
  d4:	08 95       	ret
    {
#ifdef DDRA        
    case 0:
        util_UpdateBit(DDRA,enm_pinNumber,v_pinDirn_u8);
  d6:	4a b3       	in	r20, 0x1a	; 26
  d8:	21 e0       	ldi	r18, 0x01	; 1
  da:	30 e0       	ldi	r19, 0x00	; 0
  dc:	66 23       	and	r22, r22
  de:	49 f0       	breq	.+18     	; 0xf2 <GPIO_PinDirection+0x38>
  e0:	b9 01       	movw	r22, r18
  e2:	02 c0       	rjmp	.+4      	; 0xe8 <GPIO_PinDirection+0x2e>
  e4:	66 0f       	add	r22, r22
  e6:	77 1f       	adc	r23, r23
  e8:	9a 95       	dec	r25
  ea:	e2 f7       	brpl	.-8      	; 0xe4 <GPIO_PinDirection+0x2a>
  ec:	cb 01       	movw	r24, r22
  ee:	84 2b       	or	r24, r20
  f0:	09 c0       	rjmp	.+18     	; 0x104 <GPIO_PinDirection+0x4a>
  f2:	b9 01       	movw	r22, r18
  f4:	02 c0       	rjmp	.+4      	; 0xfa <GPIO_PinDirection+0x40>
  f6:	66 0f       	add	r22, r22
  f8:	77 1f       	adc	r23, r23
  fa:	9a 95       	dec	r25
  fc:	e2 f7       	brpl	.-8      	; 0xf6 <GPIO_PinDirection+0x3c>
  fe:	cb 01       	movw	r24, r22
 100:	80 95       	com	r24
 102:	84 23       	and	r24, r20
 104:	8a bb       	out	0x1a, r24	; 26
 106:	08 95       	ret
#endif        


#ifdef DDRB
    case 1:
        util_UpdateBit(DDRB,enm_pinNumber,v_pinDirn_u8);
 108:	47 b3       	in	r20, 0x17	; 23
 10a:	21 e0       	ldi	r18, 0x01	; 1
 10c:	30 e0       	ldi	r19, 0x00	; 0
 10e:	66 23       	and	r22, r22
 110:	49 f0       	breq	.+18     	; 0x124 <GPIO_PinDirection+0x6a>
 112:	b9 01       	movw	r22, r18
 114:	02 c0       	rjmp	.+4      	; 0x11a <GPIO_PinDirection+0x60>
 116:	66 0f       	add	r22, r22
 118:	77 1f       	adc	r23, r23
 11a:	9a 95       	dec	r25
 11c:	e2 f7       	brpl	.-8      	; 0x116 <GPIO_PinDirection+0x5c>
 11e:	cb 01       	movw	r24, r22
 120:	84 2b       	or	r24, r20
 122:	09 c0       	rjmp	.+18     	; 0x136 <GPIO_PinDirection+0x7c>
 124:	b9 01       	movw	r22, r18
 126:	02 c0       	rjmp	.+4      	; 0x12c <GPIO_PinDirection+0x72>
 128:	66 0f       	add	r22, r22
 12a:	77 1f       	adc	r23, r23
 12c:	9a 95       	dec	r25
 12e:	e2 f7       	brpl	.-8      	; 0x128 <GPIO_PinDirection+0x6e>
 130:	cb 01       	movw	r24, r22
 132:	80 95       	com	r24
 134:	84 23       	and	r24, r20
 136:	87 bb       	out	0x17, r24	; 23
 138:	08 95       	ret
#endif 

        
#ifdef DDRC
    case 2:
        util_UpdateBit(DDRC,enm_pinNumber,v_pinDirn_u8);
 13a:	44 b3       	in	r20, 0x14	; 20
 13c:	21 e0       	ldi	r18, 0x01	; 1
 13e:	30 e0       	ldi	r19, 0x00	; 0
 140:	66 23       	and	r22, r22
 142:	49 f0       	breq	.+18     	; 0x156 <GPIO_PinDirection+0x9c>
 144:	b9 01       	movw	r22, r18
 146:	02 c0       	rjmp	.+4      	; 0x14c <GPIO_PinDirection+0x92>
 148:	66 0f       	add	r22, r22
 14a:	77 1f       	adc	r23, r23
 14c:	9a 95       	dec	r25
 14e:	e2 f7       	brpl	.-8      	; 0x148 <GPIO_PinDirection+0x8e>
 150:	cb 01       	movw	r24, r22
 152:	84 2b       	or	r24, r20
 154:	09 c0       	rjmp	.+18     	; 0x168 <GPIO_PinDirection+0xae>
 156:	b9 01       	movw	r22, r18
 158:	02 c0       	rjmp	.+4      	; 0x15e <GPIO_PinDirection+0xa4>
 15a:	66 0f       	add	r22, r22
 15c:	77 1f       	adc	r23, r23
 15e:	9a 95       	dec	r25
 160:	e2 f7       	brpl	.-8      	; 0x15a <GPIO_PinDirection+0xa0>
 162:	cb 01       	movw	r24, r22
 164:	80 95       	com	r24
 166:	84 23       	and	r24, r20
 168:	84 bb       	out	0x14, r24	; 20
 16a:	08 95       	ret
#endif 

        
#ifdef DDRD        
    case 3:
        util_UpdateBit(DDRD,enm_pinNumber,v_pinDirn_u8);
 16c:	41 b3       	in	r20, 0x11	; 17
 16e:	21 e0       	ldi	r18, 0x01	; 1
 170:	30 e0       	ldi	r19, 0x00	; 0
 172:	66 23       	and	r22, r22
 174:	49 f0       	breq	.+18     	; 0x188 <GPIO_PinDirection+0xce>
 176:	b9 01       	movw	r22, r18
 178:	02 c0       	rjmp	.+4      	; 0x17e <GPIO_PinDirection+0xc4>
 17a:	66 0f       	add	r22, r22
 17c:	77 1f       	adc	r23, r23
 17e:	9a 95       	dec	r25
 180:	e2 f7       	brpl	.-8      	; 0x17a <GPIO_PinDirection+0xc0>
 182:	cb 01       	movw	r24, r22
 184:	84 2b       	or	r24, r20
 186:	09 c0       	rjmp	.+18     	; 0x19a <GPIO_PinDirection+0xe0>
 188:	b9 01       	movw	r22, r18
 18a:	02 c0       	rjmp	.+4      	; 0x190 <GPIO_PinDirection+0xd6>
 18c:	66 0f       	add	r22, r22
 18e:	77 1f       	adc	r23, r23
 190:	9a 95       	dec	r25
 192:	e2 f7       	brpl	.-8      	; 0x18c <GPIO_PinDirection+0xd2>
 194:	cb 01       	movw	r24, r22
 196:	80 95       	com	r24
 198:	84 23       	and	r24, r20
 19a:	81 bb       	out	0x11, r24	; 17
 19c:	08 95       	ret

0000019e <GPIO_PinWrite>:

    uint8_t v_portNumber_u8;


    v_portNumber_u8 =  (enm_pinNumber>>3);  // Divide the pin number by 8 go get the PORT number
    enm_pinNumber  =   enm_pinNumber & 0x07;  // lower 3-bits contains the bit number of a byte 
 19e:	98 2f       	mov	r25, r24
 1a0:	97 70       	andi	r25, 0x07	; 7
{

    uint8_t v_portNumber_u8;


    v_portNumber_u8 =  (enm_pinNumber>>3);  // Divide the pin number by 8 go get the PORT number
 1a2:	86 95       	lsr	r24
 1a4:	86 95       	lsr	r24
 1a6:	86 95       	lsr	r24
    enm_pinNumber  =   enm_pinNumber & 0x07;  // lower 3-bits contains the bit number of a byte 

    /* Go to particular port after decoding from the pin number and 
        update the value of the specified pin*/
    switch(v_portNumber_u8)
 1a8:	81 30       	cpi	r24, 0x01	; 1
 1aa:	01 f1       	breq	.+64     	; 0x1ec <GPIO_PinWrite+0x4e>
 1ac:	30 f0       	brcs	.+12     	; 0x1ba <GPIO_PinWrite+0x1c>
 1ae:	82 30       	cpi	r24, 0x02	; 2
 1b0:	b1 f1       	breq	.+108    	; 0x21e <GPIO_PinWrite+0x80>
 1b2:	83 30       	cpi	r24, 0x03	; 3
 1b4:	09 f4       	brne	.+2      	; 0x1b8 <GPIO_PinWrite+0x1a>
 1b6:	4c c0       	rjmp	.+152    	; 0x250 <GPIO_PinWrite+0xb2>
 1b8:	08 95       	ret
    {
#ifdef PORTA        
    case 0:
        util_UpdateBit(PORTA,enm_pinNumber,v_pinValue_u8);
 1ba:	4b b3       	in	r20, 0x1b	; 27
 1bc:	21 e0       	ldi	r18, 0x01	; 1
 1be:	30 e0       	ldi	r19, 0x00	; 0
 1c0:	66 23       	and	r22, r22
 1c2:	49 f0       	breq	.+18     	; 0x1d6 <GPIO_PinWrite+0x38>
 1c4:	b9 01       	movw	r22, r18
 1c6:	02 c0       	rjmp	.+4      	; 0x1cc <GPIO_PinWrite+0x2e>
 1c8:	66 0f       	add	r22, r22
 1ca:	77 1f       	adc	r23, r23
 1cc:	9a 95       	dec	r25
 1ce:	e2 f7       	brpl	.-8      	; 0x1c8 <GPIO_PinWrite+0x2a>
 1d0:	cb 01       	movw	r24, r22
 1d2:	84 2b       	or	r24, r20
 1d4:	09 c0       	rjmp	.+18     	; 0x1e8 <GPIO_PinWrite+0x4a>
 1d6:	b9 01       	movw	r22, r18
 1d8:	02 c0       	rjmp	.+4      	; 0x1de <GPIO_PinWrite+0x40>
 1da:	66 0f       	add	r22, r22
 1dc:	77 1f       	adc	r23, r23
 1de:	9a 95       	dec	r25
 1e0:	e2 f7       	brpl	.-8      	; 0x1da <GPIO_PinWrite+0x3c>
 1e2:	cb 01       	movw	r24, r22
 1e4:	80 95       	com	r24
 1e6:	84 23       	and	r24, r20
 1e8:	8b bb       	out	0x1b, r24	; 27
 1ea:	08 95       	ret
#endif        

        
#ifdef PORTB
    case 1:
        util_UpdateBit(PORTB,enm_pinNumber,v_pinValue_u8);
 1ec:	48 b3       	in	r20, 0x18	; 24
 1ee:	21 e0       	ldi	r18, 0x01	; 1
 1f0:	30 e0       	ldi	r19, 0x00	; 0
 1f2:	66 23       	and	r22, r22
 1f4:	49 f0       	breq	.+18     	; 0x208 <GPIO_PinWrite+0x6a>
 1f6:	b9 01       	movw	r22, r18
 1f8:	02 c0       	rjmp	.+4      	; 0x1fe <GPIO_PinWrite+0x60>
 1fa:	66 0f       	add	r22, r22
 1fc:	77 1f       	adc	r23, r23
 1fe:	9a 95       	dec	r25
 200:	e2 f7       	brpl	.-8      	; 0x1fa <GPIO_PinWrite+0x5c>
 202:	cb 01       	movw	r24, r22
 204:	84 2b       	or	r24, r20
 206:	09 c0       	rjmp	.+18     	; 0x21a <GPIO_PinWrite+0x7c>
 208:	b9 01       	movw	r22, r18
 20a:	02 c0       	rjmp	.+4      	; 0x210 <GPIO_PinWrite+0x72>
 20c:	66 0f       	add	r22, r22
 20e:	77 1f       	adc	r23, r23
 210:	9a 95       	dec	r25
 212:	e2 f7       	brpl	.-8      	; 0x20c <GPIO_PinWrite+0x6e>
 214:	cb 01       	movw	r24, r22
 216:	80 95       	com	r24
 218:	84 23       	and	r24, r20
 21a:	88 bb       	out	0x18, r24	; 24
 21c:	08 95       	ret
#endif        

        
#ifdef PORTC        
    case 2:
        util_UpdateBit(PORTC,enm_pinNumber,v_pinValue_u8);
 21e:	45 b3       	in	r20, 0x15	; 21
 220:	21 e0       	ldi	r18, 0x01	; 1
 222:	30 e0       	ldi	r19, 0x00	; 0
 224:	66 23       	and	r22, r22
 226:	49 f0       	breq	.+18     	; 0x23a <GPIO_PinWrite+0x9c>
 228:	b9 01       	movw	r22, r18
 22a:	02 c0       	rjmp	.+4      	; 0x230 <GPIO_PinWrite+0x92>
 22c:	66 0f       	add	r22, r22
 22e:	77 1f       	adc	r23, r23
 230:	9a 95       	dec	r25
 232:	e2 f7       	brpl	.-8      	; 0x22c <GPIO_PinWrite+0x8e>
 234:	cb 01       	movw	r24, r22
 236:	84 2b       	or	r24, r20
 238:	09 c0       	rjmp	.+18     	; 0x24c <GPIO_PinWrite+0xae>
 23a:	b9 01       	movw	r22, r18
 23c:	02 c0       	rjmp	.+4      	; 0x242 <GPIO_PinWrite+0xa4>
 23e:	66 0f       	add	r22, r22
 240:	77 1f       	adc	r23, r23
 242:	9a 95       	dec	r25
 244:	e2 f7       	brpl	.-8      	; 0x23e <GPIO_PinWrite+0xa0>
 246:	cb 01       	movw	r24, r22
 248:	80 95       	com	r24
 24a:	84 23       	and	r24, r20
 24c:	85 bb       	out	0x15, r24	; 21
 24e:	08 95       	ret
#endif        

        
#ifdef PORTD        
    case 3:
        util_UpdateBit(PORTD,enm_pinNumber,v_pinValue_u8);
 250:	42 b3       	in	r20, 0x12	; 18
 252:	21 e0       	ldi	r18, 0x01	; 1
 254:	30 e0       	ldi	r19, 0x00	; 0
 256:	66 23       	and	r22, r22
 258:	49 f0       	breq	.+18     	; 0x26c <GPIO_PinWrite+0xce>
 25a:	b9 01       	movw	r22, r18
 25c:	02 c0       	rjmp	.+4      	; 0x262 <GPIO_PinWrite+0xc4>
 25e:	66 0f       	add	r22, r22
 260:	77 1f       	adc	r23, r23
 262:	9a 95       	dec	r25
 264:	e2 f7       	brpl	.-8      	; 0x25e <GPIO_PinWrite+0xc0>
 266:	cb 01       	movw	r24, r22
 268:	84 2b       	or	r24, r20
 26a:	09 c0       	rjmp	.+18     	; 0x27e <GPIO_PinWrite+0xe0>
 26c:	b9 01       	movw	r22, r18
 26e:	02 c0       	rjmp	.+4      	; 0x274 <GPIO_PinWrite+0xd6>
 270:	66 0f       	add	r22, r22
 272:	77 1f       	adc	r23, r23
 274:	9a 95       	dec	r25
 276:	e2 f7       	brpl	.-8      	; 0x270 <GPIO_PinWrite+0xd2>
 278:	cb 01       	movw	r24, r22
 27a:	80 95       	com	r24
 27c:	84 23       	and	r24, r20
 27e:	82 bb       	out	0x12, r24	; 18
 280:	08 95       	ret

00000282 <GPIO_PinRead>:
{
    uint8_t v_portNumber_u8;
    uint8_t returnStatus = 0;

    v_portNumber_u8 =  (enm_pinNumber>>3); // Divide the pin number by 8 go get the PORT number
    enm_pinNumber  =     enm_pinNumber & 0x07; // lower 3-bits contains the bit number of a byte 
 282:	28 2f       	mov	r18, r24
 284:	27 70       	andi	r18, 0x07	; 7
uint8_t GPIO_PinRead(gpioPins_et enm_pinNumber)
{
    uint8_t v_portNumber_u8;
    uint8_t returnStatus = 0;

    v_portNumber_u8 =  (enm_pinNumber>>3); // Divide the pin number by 8 go get the PORT number
 286:	86 95       	lsr	r24
 288:	86 95       	lsr	r24
 28a:	86 95       	lsr	r24
    enm_pinNumber  =     enm_pinNumber & 0x07; // lower 3-bits contains the bit number of a byte 

    /* Go to particular port after decoding from the pin number and read the pins status */
    switch(v_portNumber_u8)     
 28c:	81 30       	cpi	r24, 0x01	; 1
 28e:	49 f0       	breq	.+18     	; 0x2a2 <GPIO_PinRead+0x20>
 290:	30 f0       	brcs	.+12     	; 0x29e <GPIO_PinRead+0x1c>
 292:	82 30       	cpi	r24, 0x02	; 2
 294:	41 f0       	breq	.+16     	; 0x2a6 <GPIO_PinRead+0x24>
 296:	83 30       	cpi	r24, 0x03	; 3
 298:	79 f4       	brne	.+30     	; 0x2b8 <GPIO_PinRead+0x36>
#endif        
        
        
#ifdef PIND
    case 3:
        returnStatus = util_IsBitSet(PIND,enm_pinNumber);
 29a:	80 b3       	in	r24, 0x10	; 16
 29c:	05 c0       	rjmp	.+10     	; 0x2a8 <GPIO_PinRead+0x26>
    /* Go to particular port after decoding from the pin number and read the pins status */
    switch(v_portNumber_u8)     
    { 
#ifdef PINA    
    case 0: 
        returnStatus = util_IsBitSet(PINA,enm_pinNumber);
 29e:	89 b3       	in	r24, 0x19	; 25
 2a0:	03 c0       	rjmp	.+6      	; 0x2a8 <GPIO_PinRead+0x26>
        break;
#endif        

#ifdef PINB
    case 1:
        returnStatus = util_IsBitSet(PINB,enm_pinNumber);
 2a2:	86 b3       	in	r24, 0x16	; 22
 2a4:	01 c0       	rjmp	.+2      	; 0x2a8 <GPIO_PinRead+0x26>
        break;
#endif          

#ifdef PINC
    case 2:
        returnStatus = util_IsBitSet(PINC,enm_pinNumber);
 2a6:	83 b3       	in	r24, 0x13	; 19
#endif        
        
        
#ifdef PIND
    case 3:
        returnStatus = util_IsBitSet(PIND,enm_pinNumber);
 2a8:	90 e0       	ldi	r25, 0x00	; 0
 2aa:	02 c0       	rjmp	.+4      	; 0x2b0 <GPIO_PinRead+0x2e>
 2ac:	95 95       	asr	r25
 2ae:	87 95       	ror	r24
 2b0:	2a 95       	dec	r18
 2b2:	e2 f7       	brpl	.-8      	; 0x2ac <GPIO_PinRead+0x2a>
 2b4:	81 70       	andi	r24, 0x01	; 1
        break;
 2b6:	08 95       	ret
                Before reading the pins status, the pin should be configured as INPUT 
 ***************************************************************************************************/
uint8_t GPIO_PinRead(gpioPins_et enm_pinNumber)
{
    uint8_t v_portNumber_u8;
    uint8_t returnStatus = 0;
 2b8:	80 e0       	ldi	r24, 0x00	; 0
        returnStatus = util_IsBitSet(PING,enm_pinNumber);
        break;
#endif             
    }                         
    return returnStatus;
}
 2ba:	08 95       	ret

000002bc <lcd_SendHigherNibble>:
 * Return value    : none

 * description : This functions is used to send the higher nibble of the data to LCD in 4-bit mode
**************************************************************************************************/
static void lcd_SendHigherNibble(uint8_t dataByte)
{
 2bc:	0f 93       	push	r16
 2be:	1f 93       	push	r17
 2c0:	cf 93       	push	r28
 2c2:	c8 2f       	mov	r28, r24
    GPIO_PinWrite(LCDConfig.D4,util_IsBitSet(dataByte,4));
 2c4:	84 fb       	bst	r24, 4
 2c6:	66 27       	eor	r22, r22
 2c8:	60 f9       	bld	r22, 0
 2ca:	06 e7       	ldi	r16, 0x76	; 118
 2cc:	10 e0       	ldi	r17, 0x00	; 0
 2ce:	f8 01       	movw	r30, r16
 2d0:	82 85       	ldd	r24, Z+10	; 0x0a
 2d2:	0e 94 cf 00 	call	0x19e	; 0x19e <GPIO_PinWrite>
    GPIO_PinWrite(LCDConfig.D5,util_IsBitSet(dataByte,5));
 2d6:	c5 fb       	bst	r28, 5
 2d8:	66 27       	eor	r22, r22
 2da:	60 f9       	bld	r22, 0
 2dc:	f8 01       	movw	r30, r16
 2de:	83 85       	ldd	r24, Z+11	; 0x0b
 2e0:	0e 94 cf 00 	call	0x19e	; 0x19e <GPIO_PinWrite>
    GPIO_PinWrite(LCDConfig.D6,util_IsBitSet(dataByte,6));
 2e4:	c6 fb       	bst	r28, 6
 2e6:	66 27       	eor	r22, r22
 2e8:	60 f9       	bld	r22, 0
 2ea:	f8 01       	movw	r30, r16
 2ec:	84 85       	ldd	r24, Z+12	; 0x0c
 2ee:	0e 94 cf 00 	call	0x19e	; 0x19e <GPIO_PinWrite>
    GPIO_PinWrite(LCDConfig.D7,util_IsBitSet(dataByte,7));
 2f2:	6c 2f       	mov	r22, r28
 2f4:	66 1f       	adc	r22, r22
 2f6:	66 27       	eor	r22, r22
 2f8:	66 1f       	adc	r22, r22
 2fa:	f8 01       	movw	r30, r16
 2fc:	85 85       	ldd	r24, Z+13	; 0x0d
}
 2fe:	cf 91       	pop	r28
 300:	1f 91       	pop	r17
 302:	0f 91       	pop	r16
static void lcd_SendHigherNibble(uint8_t dataByte)
{
    GPIO_PinWrite(LCDConfig.D4,util_IsBitSet(dataByte,4));
    GPIO_PinWrite(LCDConfig.D5,util_IsBitSet(dataByte,5));
    GPIO_PinWrite(LCDConfig.D6,util_IsBitSet(dataByte,6));
    GPIO_PinWrite(LCDConfig.D7,util_IsBitSet(dataByte,7));
 304:	0c 94 cf 00 	jmp	0x19e	; 0x19e <GPIO_PinWrite>

00000308 <lcd_SendCmdSignals>:
 * Return value    : none

 * description : This functions generates the signals for sending the v_lcdCmd_u8 to LCD
**************************************************************************************************/
static void lcd_SendCmdSignals(void)
{
 308:	cf 93       	push	r28
 30a:	df 93       	push	r29
     GPIO_PinWrite(LCDConfig.RS,0);
 30c:	c6 e7       	ldi	r28, 0x76	; 118
 30e:	d0 e0       	ldi	r29, 0x00	; 0
 310:	60 e0       	ldi	r22, 0x00	; 0
 312:	8b 81       	ldd	r24, Y+3	; 0x03
 314:	0e 94 cf 00 	call	0x19e	; 0x19e <GPIO_PinWrite>
     GPIO_PinWrite(LCDConfig.RW,0);
 318:	60 e0       	ldi	r22, 0x00	; 0
 31a:	8c 81       	ldd	r24, Y+4	; 0x04
 31c:	0e 94 cf 00 	call	0x19e	; 0x19e <GPIO_PinWrite>
     GPIO_PinWrite(LCDConfig.EN,1);
 320:	61 e0       	ldi	r22, 0x01	; 1
 322:	8d 81       	ldd	r24, Y+5	; 0x05
 324:	0e 94 cf 00 	call	0x19e	; 0x19e <GPIO_PinWrite>
     DELAY_us(10);
 328:	8a e0       	ldi	r24, 0x0A	; 10
 32a:	90 e0       	ldi	r25, 0x00	; 0
 32c:	0e 94 49 00 	call	0x92	; 0x92 <DELAY_us>
     GPIO_PinWrite(LCDConfig.EN,0);
 330:	60 e0       	ldi	r22, 0x00	; 0
 332:	8d 81       	ldd	r24, Y+5	; 0x05
  
}
 334:	df 91       	pop	r29
 336:	cf 91       	pop	r28
{
     GPIO_PinWrite(LCDConfig.RS,0);
     GPIO_PinWrite(LCDConfig.RW,0);
     GPIO_PinWrite(LCDConfig.EN,1);
     DELAY_us(10);
     GPIO_PinWrite(LCDConfig.EN,0);
 338:	0c 94 cf 00 	jmp	0x19e	; 0x19e <GPIO_PinWrite>

0000033c <lcd_SendLowerNibble>:
 * Return value    : none

 * description : This functions is used to send the lower nibble of the data to LCD
**************************************************************************************************/
static void lcd_SendLowerNibble(uint8_t dataByte)
{
 33c:	0f 93       	push	r16
 33e:	1f 93       	push	r17
 340:	cf 93       	push	r28
 342:	c8 2f       	mov	r28, r24
    GPIO_PinWrite(LCDConfig.D0,util_IsBitSet(dataByte,0));
 344:	68 2f       	mov	r22, r24
 346:	61 70       	andi	r22, 0x01	; 1
 348:	06 e7       	ldi	r16, 0x76	; 118
 34a:	10 e0       	ldi	r17, 0x00	; 0
 34c:	f8 01       	movw	r30, r16
 34e:	86 81       	ldd	r24, Z+6	; 0x06
 350:	0e 94 cf 00 	call	0x19e	; 0x19e <GPIO_PinWrite>
    GPIO_PinWrite(LCDConfig.D1,util_IsBitSet(dataByte,1));
 354:	c1 fb       	bst	r28, 1
 356:	66 27       	eor	r22, r22
 358:	60 f9       	bld	r22, 0
 35a:	f8 01       	movw	r30, r16
 35c:	87 81       	ldd	r24, Z+7	; 0x07
 35e:	0e 94 cf 00 	call	0x19e	; 0x19e <GPIO_PinWrite>
    GPIO_PinWrite(LCDConfig.D2,util_IsBitSet(dataByte,2));
 362:	c2 fb       	bst	r28, 2
 364:	66 27       	eor	r22, r22
 366:	60 f9       	bld	r22, 0
 368:	f8 01       	movw	r30, r16
 36a:	80 85       	ldd	r24, Z+8	; 0x08
 36c:	0e 94 cf 00 	call	0x19e	; 0x19e <GPIO_PinWrite>
    GPIO_PinWrite(LCDConfig.D3,util_IsBitSet(dataByte,3));
 370:	c3 fb       	bst	r28, 3
 372:	66 27       	eor	r22, r22
 374:	60 f9       	bld	r22, 0
 376:	f8 01       	movw	r30, r16
 378:	81 85       	ldd	r24, Z+9	; 0x09
}
 37a:	cf 91       	pop	r28
 37c:	1f 91       	pop	r17
 37e:	0f 91       	pop	r16
static void lcd_SendLowerNibble(uint8_t dataByte)
{
    GPIO_PinWrite(LCDConfig.D0,util_IsBitSet(dataByte,0));
    GPIO_PinWrite(LCDConfig.D1,util_IsBitSet(dataByte,1));
    GPIO_PinWrite(LCDConfig.D2,util_IsBitSet(dataByte,2));
    GPIO_PinWrite(LCDConfig.D3,util_IsBitSet(dataByte,3));
 380:	0c 94 cf 00 	jmp	0x19e	; 0x19e <GPIO_PinWrite>

00000384 <lcd_SendDataSignals>:
 * Return value    : none

 * description : This functions generates the signals for sending the Data to LCD
**************************************************************************************************/
static void lcd_SendDataSignals(void)
{
 384:	cf 93       	push	r28
 386:	df 93       	push	r29
     GPIO_PinWrite(LCDConfig.RS,1);
 388:	c6 e7       	ldi	r28, 0x76	; 118
 38a:	d0 e0       	ldi	r29, 0x00	; 0
 38c:	61 e0       	ldi	r22, 0x01	; 1
 38e:	8b 81       	ldd	r24, Y+3	; 0x03
 390:	0e 94 cf 00 	call	0x19e	; 0x19e <GPIO_PinWrite>
     GPIO_PinWrite(LCDConfig.RW,0);
 394:	60 e0       	ldi	r22, 0x00	; 0
 396:	8c 81       	ldd	r24, Y+4	; 0x04
 398:	0e 94 cf 00 	call	0x19e	; 0x19e <GPIO_PinWrite>
     GPIO_PinWrite(LCDConfig.EN,1);
 39c:	61 e0       	ldi	r22, 0x01	; 1
 39e:	8d 81       	ldd	r24, Y+5	; 0x05
 3a0:	0e 94 cf 00 	call	0x19e	; 0x19e <GPIO_PinWrite>
     DELAY_us(10);
 3a4:	8a e0       	ldi	r24, 0x0A	; 10
 3a6:	90 e0       	ldi	r25, 0x00	; 0
 3a8:	0e 94 49 00 	call	0x92	; 0x92 <DELAY_us>
     GPIO_PinWrite(LCDConfig.EN,0);
 3ac:	60 e0       	ldi	r22, 0x00	; 0
 3ae:	8d 81       	ldd	r24, Y+5	; 0x05
}
 3b0:	df 91       	pop	r29
 3b2:	cf 91       	pop	r28
{
     GPIO_PinWrite(LCDConfig.RS,1);
     GPIO_PinWrite(LCDConfig.RW,0);
     GPIO_PinWrite(LCDConfig.EN,1);
     DELAY_us(10);
     GPIO_PinWrite(LCDConfig.EN,0);
 3b4:	0c 94 cf 00 	jmp	0x19e	; 0x19e <GPIO_PinWrite>

000003b8 <lcd_BusyCheck>:
 * description : This functions is used check whether LCD is busy.
                 It waits till the LCD is busy by polling the LCD busy flag.
                 After completing the previous operation, LCDs clears its internal busy flag.
**************************************************************************************************/
static void lcd_BusyCheck(void)
{
 3b8:	cf 93       	push	r28
    uint8_t busyflag;
 
  if(LCDConfig.RW != P_NC)                         //Perform Busy check if RW pin is used
 3ba:	80 91 7a 00 	lds	r24, 0x007A
 3be:	8f 3f       	cpi	r24, 0xFF	; 255
 3c0:	09 f4       	brne	.+2      	; 0x3c4 <lcd_BusyCheck+0xc>
 3c2:	44 c0       	rjmp	.+136    	; 0x44c <lcd_BusyCheck+0x94>
   {
    GPIO_PinDirection(LCDConfig.D7,INPUT); // Configure busy pin as input
 3c4:	60 e0       	ldi	r22, 0x00	; 0
 3c6:	80 91 83 00 	lds	r24, 0x0083
 3ca:	0e 94 5d 00 	call	0xba	; 0xba <GPIO_PinDirection>
    GPIO_PinWrite(LCDConfig.RS,0);           // Select the Command Register by pulling RS LOW
 3ce:	60 e0       	ldi	r22, 0x00	; 0
 3d0:	80 91 79 00 	lds	r24, 0x0079
 3d4:	0e 94 cf 00 	call	0x19e	; 0x19e <GPIO_PinWrite>
    GPIO_PinWrite(LCDConfig.RW,1);           // Select the Read Operation for busy flag by setting RW
 3d8:	61 e0       	ldi	r22, 0x01	; 1
 3da:	80 91 7a 00 	lds	r24, 0x007A
 3de:	0e 94 cf 00 	call	0x19e	; 0x19e <GPIO_PinWrite>
    do
    {

        GPIO_PinWrite(LCDConfig.EN,0);
 3e2:	60 e0       	ldi	r22, 0x00	; 0
 3e4:	80 91 7b 00 	lds	r24, 0x007B
 3e8:	0e 94 cf 00 	call	0x19e	; 0x19e <GPIO_PinWrite>
        DELAY_us(10);
 3ec:	8a e0       	ldi	r24, 0x0A	; 10
 3ee:	90 e0       	ldi	r25, 0x00	; 0
 3f0:	0e 94 49 00 	call	0x92	; 0x92 <DELAY_us>
        GPIO_PinWrite(LCDConfig.EN,1); 
 3f4:	61 e0       	ldi	r22, 0x01	; 1
 3f6:	80 91 7b 00 	lds	r24, 0x007B
 3fa:	0e 94 cf 00 	call	0x19e	; 0x19e <GPIO_PinWrite>
        DELAY_us(10);
 3fe:	8a e0       	ldi	r24, 0x0A	; 10
 400:	90 e0       	ldi	r25, 0x00	; 0
 402:	0e 94 49 00 	call	0x92	; 0x92 <DELAY_us>
        busyflag = GPIO_PinRead(LCDConfig.D7);
 406:	80 91 83 00 	lds	r24, 0x0083
 40a:	0e 94 41 01 	call	0x282	; 0x282 <GPIO_PinRead>
 40e:	c8 2f       	mov	r28, r24


        if(LCDConfig.v_LcdMode_U8 == 4)
 410:	80 91 78 00 	lds	r24, 0x0078
 414:	84 30       	cpi	r24, 0x04	; 4
 416:	91 f4       	brne	.+36     	; 0x43c <lcd_BusyCheck+0x84>
        {
            /* Perform extra dummy read for 4-bit */            
            GPIO_PinWrite(LCDConfig.EN,0);
 418:	60 e0       	ldi	r22, 0x00	; 0
 41a:	80 91 7b 00 	lds	r24, 0x007B
 41e:	0e 94 cf 00 	call	0x19e	; 0x19e <GPIO_PinWrite>
            DELAY_us(10);
 422:	8a e0       	ldi	r24, 0x0A	; 10
 424:	90 e0       	ldi	r25, 0x00	; 0
 426:	0e 94 49 00 	call	0x92	; 0x92 <DELAY_us>
            GPIO_PinWrite(LCDConfig.EN,1); 
 42a:	61 e0       	ldi	r22, 0x01	; 1
 42c:	80 91 7b 00 	lds	r24, 0x007B
 430:	0e 94 cf 00 	call	0x19e	; 0x19e <GPIO_PinWrite>
            DELAY_us(10);
 434:	8a e0       	ldi	r24, 0x0A	; 10
 436:	90 e0       	ldi	r25, 0x00	; 0
 438:	0e 94 49 00 	call	0x92	; 0x92 <DELAY_us>
        }    
    }while(busyflag!=0);
 43c:	c1 11       	cpse	r28, r1
 43e:	d1 cf       	rjmp	.-94     	; 0x3e2 <lcd_BusyCheck+0x2a>

    GPIO_PinDirection(LCDConfig.D7,OUTPUT); // Configure busy pin as Output
 440:	61 e0       	ldi	r22, 0x01	; 1
 442:	80 91 83 00 	lds	r24, 0x0083
 {
    /* Busy flag cannot be read as RW is not available hence Extra delay of 1ms is added 
      to ensure the LCD completes previous operation and ready to receive new commands/data */
    DELAY_ms(1);  
 }
}
 446:	cf 91       	pop	r28
            GPIO_PinWrite(LCDConfig.EN,1); 
            DELAY_us(10);
        }    
    }while(busyflag!=0);

    GPIO_PinDirection(LCDConfig.D7,OUTPUT); // Configure busy pin as Output
 448:	0c 94 5d 00 	jmp	0xba	; 0xba <GPIO_PinDirection>
  }
else
 {
    /* Busy flag cannot be read as RW is not available hence Extra delay of 1ms is added 
      to ensure the LCD completes previous operation and ready to receive new commands/data */
    DELAY_ms(1);  
 44c:	81 e0       	ldi	r24, 0x01	; 1
 44e:	90 e0       	ldi	r25, 0x00	; 0
 }
}
 450:	cf 91       	pop	r28
  }
else
 {
    /* Busy flag cannot be read as RW is not available hence Extra delay of 1ms is added 
      to ensure the LCD completes previous operation and ready to receive new commands/data */
    DELAY_ms(1);  
 452:	0c 94 52 00 	jmp	0xa4	; 0xa4 <DELAY_ms>

00000456 <LCD_SetUp>:
               gpioPins_et D3,
               gpioPins_et D4,
               gpioPins_et D5,
               gpioPins_et D6,
               gpioPins_et D7 )
{
 456:	8f 92       	push	r8
 458:	9f 92       	push	r9
 45a:	af 92       	push	r10
 45c:	bf 92       	push	r11
 45e:	cf 92       	push	r12
 460:	df 92       	push	r13
 462:	ef 92       	push	r14
 464:	ff 92       	push	r15
 466:	0f 93       	push	r16
 468:	1f 93       	push	r17
 46a:	cf 93       	push	r28
 46c:	df 93       	push	r29
 46e:	cd b7       	in	r28, 0x3d	; 61
 470:	de b7       	in	r29, 0x3e	; 62
 472:	98 2e       	mov	r9, r24
 474:	b6 2e       	mov	r11, r22
 476:	d4 2e       	mov	r13, r20
 478:	ff 84       	ldd	r15, Y+15	; 0x0f
 47a:	18 89       	ldd	r17, Y+16	; 0x10
  /* Copy the PIN numbers where the LCD is connected */
    LCDConfig.RS = RS;
 47c:	80 93 79 00 	sts	0x0079, r24
    LCDConfig.RW = RW;
 480:	60 93 7a 00 	sts	0x007A, r22
    LCDConfig.EN = EN;
 484:	40 93 7b 00 	sts	0x007B, r20

    LCDConfig.D0 = D0;
 488:	20 93 7c 00 	sts	0x007C, r18
    LCDConfig.D1 = D1;
 48c:	00 93 7d 00 	sts	0x007D, r16
    LCDConfig.D2 = D2;
 490:	e0 92 7e 00 	sts	0x007E, r14
    LCDConfig.D3 = D3;
 494:	c0 92 7f 00 	sts	0x007F, r12
    LCDConfig.D4 = D4;
 498:	a0 92 80 00 	sts	0x0080, r10
    LCDConfig.D5 = D5;
 49c:	80 92 81 00 	sts	0x0081, r8
    LCDConfig.D6 = D6;
 4a0:	f0 92 82 00 	sts	0x0082, r15
    LCDConfig.D7 = D7;
 4a4:	10 93 83 00 	sts	0x0083, r17


    if((D0 == P_NC) || (D1 == P_NC) || (D2 == P_NC) || (D3 == P_NC))
 4a8:	2f 3f       	cpi	r18, 0xFF	; 255
 4aa:	39 f0       	breq	.+14     	; 0x4ba <LCD_SetUp+0x64>
 4ac:	0f 3f       	cpi	r16, 0xFF	; 255
 4ae:	29 f0       	breq	.+10     	; 0x4ba <LCD_SetUp+0x64>
 4b0:	8f ef       	ldi	r24, 0xFF	; 255
 4b2:	e8 16       	cp	r14, r24
 4b4:	11 f0       	breq	.+4      	; 0x4ba <LCD_SetUp+0x64>
 4b6:	c8 12       	cpse	r12, r24
 4b8:	04 c0       	rjmp	.+8      	; 0x4c2 <LCD_SetUp+0x6c>
    {
        LCDConfig.v_LcdMode_U8 = 4; // Select 4-bit mode as D0-D3 are not used(P_NC)
 4ba:	84 e0       	ldi	r24, 0x04	; 4
 4bc:	80 93 78 00 	sts	0x0078, r24
 4c0:	13 c0       	rjmp	.+38     	; 0x4e8 <LCD_SetUp+0x92>
    }
    else
    {
        LCDConfig.v_LcdMode_U8 = 8; // 8-bit mode configure D0-D3 as output.      
 4c2:	88 e0       	ldi	r24, 0x08	; 8
 4c4:	80 93 78 00 	sts	0x0078, r24
        GPIO_PinDirection(D0,OUTPUT);
 4c8:	61 e0       	ldi	r22, 0x01	; 1
 4ca:	82 2f       	mov	r24, r18
 4cc:	0e 94 5d 00 	call	0xba	; 0xba <GPIO_PinDirection>
        GPIO_PinDirection(D1,OUTPUT);
 4d0:	61 e0       	ldi	r22, 0x01	; 1
 4d2:	80 2f       	mov	r24, r16
 4d4:	0e 94 5d 00 	call	0xba	; 0xba <GPIO_PinDirection>
        GPIO_PinDirection(D2,OUTPUT);
 4d8:	61 e0       	ldi	r22, 0x01	; 1
 4da:	8e 2d       	mov	r24, r14
 4dc:	0e 94 5d 00 	call	0xba	; 0xba <GPIO_PinDirection>
        GPIO_PinDirection(D3,OUTPUT);
 4e0:	61 e0       	ldi	r22, 0x01	; 1
 4e2:	8c 2d       	mov	r24, r12
 4e4:	0e 94 5d 00 	call	0xba	; 0xba <GPIO_PinDirection>
    }

    /* Configure RS,RW,EN, D4-D7 as Output for both 4/8-bit mode.*/
    GPIO_PinDirection(RS,OUTPUT);
 4e8:	61 e0       	ldi	r22, 0x01	; 1
 4ea:	89 2d       	mov	r24, r9
 4ec:	0e 94 5d 00 	call	0xba	; 0xba <GPIO_PinDirection>
    GPIO_PinDirection(RW,OUTPUT);
 4f0:	61 e0       	ldi	r22, 0x01	; 1
 4f2:	8b 2d       	mov	r24, r11
 4f4:	0e 94 5d 00 	call	0xba	; 0xba <GPIO_PinDirection>
    GPIO_PinDirection(EN,OUTPUT);
 4f8:	61 e0       	ldi	r22, 0x01	; 1
 4fa:	8d 2d       	mov	r24, r13
 4fc:	0e 94 5d 00 	call	0xba	; 0xba <GPIO_PinDirection>

    GPIO_PinDirection(D4,OUTPUT);
 500:	61 e0       	ldi	r22, 0x01	; 1
 502:	8a 2d       	mov	r24, r10
 504:	0e 94 5d 00 	call	0xba	; 0xba <GPIO_PinDirection>
    GPIO_PinDirection(D5,OUTPUT);
 508:	61 e0       	ldi	r22, 0x01	; 1
 50a:	88 2d       	mov	r24, r8
 50c:	0e 94 5d 00 	call	0xba	; 0xba <GPIO_PinDirection>
    GPIO_PinDirection(D6,OUTPUT);
 510:	61 e0       	ldi	r22, 0x01	; 1
 512:	8f 2d       	mov	r24, r15
 514:	0e 94 5d 00 	call	0xba	; 0xba <GPIO_PinDirection>
    GPIO_PinDirection(D7,OUTPUT);  
 518:	61 e0       	ldi	r22, 0x01	; 1
 51a:	81 2f       	mov	r24, r17
}
 51c:	df 91       	pop	r29
 51e:	cf 91       	pop	r28
 520:	1f 91       	pop	r17
 522:	0f 91       	pop	r16
 524:	ff 90       	pop	r15
 526:	ef 90       	pop	r14
 528:	df 90       	pop	r13
 52a:	cf 90       	pop	r12
 52c:	bf 90       	pop	r11
 52e:	af 90       	pop	r10
 530:	9f 90       	pop	r9
 532:	8f 90       	pop	r8
    GPIO_PinDirection(EN,OUTPUT);

    GPIO_PinDirection(D4,OUTPUT);
    GPIO_PinDirection(D5,OUTPUT);
    GPIO_PinDirection(D6,OUTPUT);
    GPIO_PinDirection(D7,OUTPUT);  
 534:	0c 94 5d 00 	jmp	0xba	; 0xba <GPIO_PinDirection>

00000538 <LCD_CmdWrite>:
                Some of the commonly used commands are defined in lcd.h.
                For more commands refer the data sheet and send the supported command.                
                The behaviour is undefined if unsupported commands are sent.    
****************************************************************************************************/
void LCD_CmdWrite( uint8_t v_lcdCmd_u8)
{
 538:	cf 93       	push	r28
 53a:	c8 2f       	mov	r28, r24
    lcd_BusyCheck();
 53c:	0e 94 dc 01 	call	0x3b8	; 0x3b8 <lcd_BusyCheck>
    if(LCDConfig.v_LcdMode_U8 == C_EightBitMode_U8)
 540:	80 91 78 00 	lds	r24, 0x0078
 544:	88 30       	cpi	r24, 0x08	; 8
 546:	21 f4       	brne	.+8      	; 0x550 <LCD_CmdWrite+0x18>
     {
         lcd_SendLowerNibble(v_lcdCmd_u8);
 548:	8c 2f       	mov	r24, r28
 54a:	0e 94 9e 01 	call	0x33c	; 0x33c <lcd_SendLowerNibble>
 54e:	07 c0       	rjmp	.+14     	; 0x55e <LCD_CmdWrite+0x26>
     }
     else
     {
         lcd_SendHigherNibble(v_lcdCmd_u8);
 550:	8c 2f       	mov	r24, r28
 552:	0e 94 5e 01 	call	0x2bc	; 0x2bc <lcd_SendHigherNibble>
         lcd_SendCmdSignals();
 556:	0e 94 84 01 	call	0x308	; 0x308 <lcd_SendCmdSignals>
         v_lcdCmd_u8 = v_lcdCmd_u8 << 4;
 55a:	c2 95       	swap	r28
 55c:	c0 7f       	andi	r28, 0xF0	; 240
     }

     lcd_SendHigherNibble(v_lcdCmd_u8);
 55e:	8c 2f       	mov	r24, r28
 560:	0e 94 5e 01 	call	0x2bc	; 0x2bc <lcd_SendHigherNibble>
     lcd_SendCmdSignals();
}
 564:	cf 91       	pop	r28
         lcd_SendCmdSignals();
         v_lcdCmd_u8 = v_lcdCmd_u8 << 4;
     }

     lcd_SendHigherNibble(v_lcdCmd_u8);
     lcd_SendCmdSignals();
 566:	0c 94 84 01 	jmp	0x308	; 0x308 <lcd_SendCmdSignals>

0000056a <LCD_GoToLine>:
           C_LcdLineThree,

****************************************************************************************************/
void LCD_GoToLine(uint8_t v_lineNumber_u8)
{
    if(v_lineNumber_u8 < LCDConfig.v_MaxSupportedLines_U8)
 56a:	90 91 76 00 	lds	r25, 0x0076
 56e:	89 17       	cp	r24, r25
 570:	58 f4       	brcc	.+22     	; 0x588 <LCD_GoToLine+0x1e>
    {
        /* If the line number is within range then
           Move the Cursor to beginning of the specified line */
        v_LcdTrackCursorPos_U8 = 0x00;
 572:	10 92 84 00 	sts	0x0084, r1
        v_LcdTrackLineNum_U8 = v_lineNumber_u8;
 576:	80 93 85 00 	sts	0x0085, r24
        LCD_CmdWrite(ARR_LcdLineNumAddress_U8[v_lineNumber_u8]);
 57a:	e8 2f       	mov	r30, r24
 57c:	f0 e0       	ldi	r31, 0x00	; 0
 57e:	e0 5a       	subi	r30, 0xA0	; 160
 580:	ff 4f       	sbci	r31, 0xFF	; 255
 582:	80 81       	ld	r24, Z
 584:	0c 94 9c 02 	jmp	0x538	; 0x538 <LCD_CmdWrite>
 588:	08 95       	ret

0000058a <LCD_Clear>:

 * description  :This function clears the LCD and moves the cursor to beginning of first line
****************************************************************************************************/
void LCD_Clear()
{
    LCD_CmdWrite(CMD_LCD_CLEAR);    // Clear the LCD and go to First line First Position
 58a:	81 e0       	ldi	r24, 0x01	; 1
 58c:	0e 94 9c 02 	call	0x538	; 0x538 <LCD_CmdWrite>
    LCD_GoToLine(C_LcdLineZero);
 590:	80 e0       	ldi	r24, 0x00	; 0
 592:	0c 94 b5 02 	jmp	0x56a	; 0x56a <LCD_GoToLine>

00000596 <LCD_Init>:
**************************************************************************************************/
void LCD_Init(uint8_t v_lcdNoOfLines_u8, uint8_t v_MaxCharsPerLine_u8)
{


    LCDConfig.v_MaxSupportedChars_U8 = v_MaxCharsPerLine_u8; //Maintaian the LCD type
 596:	60 93 77 00 	sts	0x0077, r22
    LCDConfig.v_MaxSupportedLines_U8 = v_lcdNoOfLines_u8;
 59a:	80 93 76 00 	sts	0x0076, r24
    if(v_lcdNoOfLines_u8 > C_LcdLineTwo)
 59e:	83 30       	cpi	r24, 0x03	; 3
 5a0:	40 f0       	brcs	.+16     	; 0x5b2 <LCD_Init+0x1c>
    {
        ARR_LcdLineNumAddress_U8[C_LcdLineTwo] =  0x90 + (v_MaxCharsPerLine_u8 & 0x0fu);
 5a2:	6f 70       	andi	r22, 0x0F	; 15
 5a4:	80 e9       	ldi	r24, 0x90	; 144
 5a6:	86 0f       	add	r24, r22
 5a8:	80 93 62 00 	sts	0x0062, r24
        ARR_LcdLineNumAddress_U8[C_LcdLineThree] =  0xd0 + (v_MaxCharsPerLine_u8 & 0x0fu);
 5ac:	60 53       	subi	r22, 0x30	; 48
 5ae:	60 93 63 00 	sts	0x0063, r22
    }

    DELAY_ms(100);
 5b2:	84 e6       	ldi	r24, 0x64	; 100
 5b4:	90 e0       	ldi	r25, 0x00	; 0
 5b6:	0e 94 52 00 	call	0xa4	; 0xa4 <DELAY_ms>

    if(LCDConfig.v_LcdMode_U8 == C_EightBitMode_U8)
 5ba:	80 91 78 00 	lds	r24, 0x0078
 5be:	88 30       	cpi	r24, 0x08	; 8
 5c0:	11 f4       	brne	.+4      	; 0x5c6 <LCD_Init+0x30>
    {
        LCD_CmdWrite(CMD_LCD_EIGHT_BIT_MODE); // Initialize the LCD for 8-bit 5x7 matrix type
 5c2:	88 e3       	ldi	r24, 0x38	; 56
 5c4:	27 c0       	rjmp	.+78     	; 0x614 <LCD_Init+0x7e>
    }
    else if(LCDConfig.v_LcdMode_U8 == C_FourBitMode_U8)
 5c6:	84 30       	cpi	r24, 0x04	; 4
 5c8:	39 f5       	brne	.+78     	; 0x618 <LCD_Init+0x82>
                 This is used only in 4-bit mode as the LCD by default boots in 8-Bit mode.
----------------------------------------------------------------------------------*/
static void lcd_Reset(void)
{
    /* LCD reset sequence for 4-bit mode, refer data sheet for more info */
    lcd_SendHigherNibble(0x30);
 5ca:	80 e3       	ldi	r24, 0x30	; 48
 5cc:	0e 94 5e 01 	call	0x2bc	; 0x2bc <lcd_SendHigherNibble>
    lcd_SendCmdSignals();
 5d0:	0e 94 84 01 	call	0x308	; 0x308 <lcd_SendCmdSignals>
    DELAY_ms(100);
 5d4:	84 e6       	ldi	r24, 0x64	; 100
 5d6:	90 e0       	ldi	r25, 0x00	; 0
 5d8:	0e 94 52 00 	call	0xa4	; 0xa4 <DELAY_ms>
    lcd_SendHigherNibble(0x30);
 5dc:	80 e3       	ldi	r24, 0x30	; 48
 5de:	0e 94 5e 01 	call	0x2bc	; 0x2bc <lcd_SendHigherNibble>
    lcd_SendCmdSignals();
 5e2:	0e 94 84 01 	call	0x308	; 0x308 <lcd_SendCmdSignals>
    DELAY_us(200);
 5e6:	88 ec       	ldi	r24, 0xC8	; 200
 5e8:	90 e0       	ldi	r25, 0x00	; 0
 5ea:	0e 94 49 00 	call	0x92	; 0x92 <DELAY_us>
    lcd_SendHigherNibble(0x30);
 5ee:	80 e3       	ldi	r24, 0x30	; 48
 5f0:	0e 94 5e 01 	call	0x2bc	; 0x2bc <lcd_SendHigherNibble>
    lcd_SendCmdSignals();
 5f4:	0e 94 84 01 	call	0x308	; 0x308 <lcd_SendCmdSignals>
    DELAY_us(200);
 5f8:	88 ec       	ldi	r24, 0xC8	; 200
 5fa:	90 e0       	ldi	r25, 0x00	; 0
 5fc:	0e 94 49 00 	call	0x92	; 0x92 <DELAY_us>
    lcd_SendHigherNibble(0x20);
 600:	80 e2       	ldi	r24, 0x20	; 32
 602:	0e 94 5e 01 	call	0x2bc	; 0x2bc <lcd_SendHigherNibble>
    lcd_SendCmdSignals();
 606:	0e 94 84 01 	call	0x308	; 0x308 <lcd_SendCmdSignals>
    DELAY_us(200);
 60a:	88 ec       	ldi	r24, 0xC8	; 200
 60c:	90 e0       	ldi	r25, 0x00	; 0
 60e:	0e 94 49 00 	call	0x92	; 0x92 <DELAY_us>
        LCD_CmdWrite(CMD_LCD_EIGHT_BIT_MODE); // Initialize the LCD for 8-bit 5x7 matrix type
    }
    else if(LCDConfig.v_LcdMode_U8 == C_FourBitMode_U8)
    {
        lcd_Reset();
        LCD_CmdWrite(CMD_LCD_FOUR_BIT_MODE); // Initialize the LCD for 4-bit 5x7 matrix type 
 612:	88 e2       	ldi	r24, 0x28	; 40
 614:	0e 94 9c 02 	call	0x538	; 0x538 <LCD_CmdWrite>
    }

    LCD_CmdWrite(CMD_DISPLAY_ON_CURSOR_ON);     // Display ON cursor ON
 618:	8e e0       	ldi	r24, 0x0E	; 14
 61a:	0e 94 9c 02 	call	0x538	; 0x538 <LCD_CmdWrite>
    LCD_Clear();                             // Clear the LCD and go to First line First Position
 61e:	0c 94 c5 02 	jmp	0x58a	; 0x58a <LCD_Clear>

00000622 <LCD_GoToNextLine>:
****************************************************************************************************/
void  LCD_GoToNextLine(void)
{
    /*Increment the current line number.
      In case it exceeds the limit, rool it back to first line */
    v_LcdTrackLineNum_U8++;
 622:	80 91 85 00 	lds	r24, 0x0085
 626:	8f 5f       	subi	r24, 0xFF	; 255
 628:	80 93 85 00 	sts	0x0085, r24
    v_LcdTrackCursorPos_U8 = 0x00;
 62c:	10 92 84 00 	sts	0x0084, r1
    if(v_LcdTrackLineNum_U8 >= LCDConfig.v_MaxSupportedLines_U8)
 630:	90 91 76 00 	lds	r25, 0x0076
 634:	89 17       	cp	r24, r25
 636:	10 f0       	brcs	.+4      	; 0x63c <LCD_GoToNextLine+0x1a>
        v_LcdTrackLineNum_U8 = C_LcdLineZero;
 638:	10 92 85 00 	sts	0x0085, r1
    LCD_CmdWrite(ARR_LcdLineNumAddress_U8[v_LcdTrackLineNum_U8]);
 63c:	e0 91 85 00 	lds	r30, 0x0085
 640:	f0 e0       	ldi	r31, 0x00	; 0
 642:	e0 5a       	subi	r30, 0xA0	; 160
 644:	ff 4f       	sbci	r31, 0xFF	; 255
 646:	80 81       	ld	r24, Z
 648:	0c 94 9c 02 	jmp	0x538	; 0x538 <LCD_CmdWrite>

0000064c <LCD_DisplayChar>:
 * description  : This function sends a character to be displayed on LCD.
                  Any valid ascii value can be passed to display respective character

****************************************************************************************************/
void LCD_DisplayChar(char v_lcdData_u8)
{
 64c:	cf 93       	push	r28
 64e:	c8 2f       	mov	r28, r24
    if((v_LcdTrackCursorPos_U8>=LCDConfig.v_MaxSupportedChars_U8) || (v_lcdData_u8=='\n'))
 650:	90 91 84 00 	lds	r25, 0x0084
 654:	80 91 77 00 	lds	r24, 0x0077
 658:	98 17       	cp	r25, r24
 65a:	60 f4       	brcc	.+24     	; 0x674 <LCD_DisplayChar+0x28>
 65c:	ca 30       	cpi	r28, 0x0A	; 10
 65e:	51 f0       	breq	.+20     	; 0x674 <LCD_DisplayChar+0x28>

 * description : This functions is used to send a byte of data to LCD.                 .    
**************************************************************************************************/
static void lcd_DataWrite( uint8_t dataByte)
{
    lcd_BusyCheck();
 660:	0e 94 dc 01 	call	0x3b8	; 0x3b8 <lcd_BusyCheck>
    if(LCDConfig.v_LcdMode_U8 == C_EightBitMode_U8)
 664:	80 91 78 00 	lds	r24, 0x0078
 668:	88 30       	cpi	r24, 0x08	; 8
 66a:	49 f4       	brne	.+18     	; 0x67e <LCD_DisplayChar+0x32>
     {
         lcd_SendLowerNibble(dataByte);
 66c:	8c 2f       	mov	r24, r28
 66e:	0e 94 9e 01 	call	0x33c	; 0x33c <lcd_SendLowerNibble>
 672:	0c c0       	rjmp	.+24     	; 0x68c <LCD_DisplayChar+0x40>
{
    if((v_LcdTrackCursorPos_U8>=LCDConfig.v_MaxSupportedChars_U8) || (v_lcdData_u8=='\n'))
    {
        /* If the cursor has reached to end of line on page1
        OR NewLine command is issued Then Move the cursor to next line */
        LCD_GoToNextLine();
 674:	0e 94 11 03 	call	0x622	; 0x622 <LCD_GoToNextLine>
    }
    if(v_lcdData_u8!='\n') /* Display the character if its not newLine Char */
 678:	ca 30       	cpi	r28, 0x0A	; 10
 67a:	91 f0       	breq	.+36     	; 0x6a0 <LCD_DisplayChar+0x54>
 67c:	f1 cf       	rjmp	.-30     	; 0x660 <LCD_DisplayChar+0x14>
     {
         lcd_SendLowerNibble(dataByte);
     }
     else
     {
         lcd_SendHigherNibble(dataByte);
 67e:	8c 2f       	mov	r24, r28
 680:	0e 94 5e 01 	call	0x2bc	; 0x2bc <lcd_SendHigherNibble>
         lcd_SendDataSignals();
 684:	0e 94 c2 01 	call	0x384	; 0x384 <lcd_SendDataSignals>
         dataByte = dataByte << 4;
 688:	c2 95       	swap	r28
 68a:	c0 7f       	andi	r28, 0xF0	; 240
     }

     lcd_SendHigherNibble(dataByte);
 68c:	8c 2f       	mov	r24, r28
 68e:	0e 94 5e 01 	call	0x2bc	; 0x2bc <lcd_SendHigherNibble>
     lcd_SendDataSignals();
 692:	0e 94 c2 01 	call	0x384	; 0x384 <lcd_SendDataSignals>
    }
    if(v_lcdData_u8!='\n') /* Display the character if its not newLine Char */
    {

        lcd_DataWrite(v_lcdData_u8); /* Display the data and keep track of cursor */
        v_LcdTrackCursorPos_U8++;
 696:	80 91 84 00 	lds	r24, 0x0084
 69a:	8f 5f       	subi	r24, 0xFF	; 255
 69c:	80 93 84 00 	sts	0x0084, r24
    }
}
 6a0:	cf 91       	pop	r28
 6a2:	08 95       	ret

000006a4 <LCD_DisplayNumber.part.3>:
    Hex:        7.(16,0x12AB,3) then 3-digits ie. 2AB will be displayed
                8.(C_HEX_U8,0x12AB,6) then 6-digits ie. 0012AB will be displayed
                9.(C_HEX_U8,0x12AB,C_DisplayDefaultDigits_U8) then 12AB will be displayed.                
****************************************************************************************************/
#if ((Enable_LCD_DisplayNumber == 1) || (Enable_LCD_DisplayFloatNumber == 1) || (Enable_LCD_Printf==1))
void LCD_DisplayNumber(uint8_t v_numericSystem_u8, uint32_t v_number_u32, uint8_t v_numOfDigitsToDisplay_u8)
 6a4:	af 92       	push	r10
 6a6:	bf 92       	push	r11
 6a8:	cf 92       	push	r12
 6aa:	df 92       	push	r13
 6ac:	ef 92       	push	r14
 6ae:	ff 92       	push	r15
 6b0:	0f 93       	push	r16
 6b2:	1f 93       	push	r17
 6b4:	cf 93       	push	r28
 6b6:	df 93       	push	r29
 6b8:	1f 92       	push	r1
 6ba:	cd b7       	in	r28, 0x3d	; 61
 6bc:	de b7       	in	r29, 0x3e	; 62
 6be:	6b 01       	movw	r12, r22
 6c0:	7c 01       	movw	r14, r24
    {
        while(v_numOfDigitsToDisplay_u8!=0)
        {
          /* Start Extracting the bits from the specified bit positions.
          Get the Acsii values of the bits and display */
          i = util_GetBitStatus(v_number_u32,(v_numOfDigitsToDisplay_u8-1));
 6c2:	aa 24       	eor	r10, r10
 6c4:	a3 94       	inc	r10
 6c6:	b1 2c       	mov	r11, r1
{
    uint8_t i=0,a[10];
    
    if(C_BINARY_U8 == v_numericSystem_u8)
    {
        while(v_numOfDigitsToDisplay_u8!=0)
 6c8:	44 23       	and	r20, r20
 6ca:	e9 f0       	breq	.+58     	; 0x706 <LCD_DisplayNumber.part.3+0x62>
        {
          /* Start Extracting the bits from the specified bit positions.
          Get the Acsii values of the bits and display */
          i = util_GetBitStatus(v_number_u32,(v_numOfDigitsToDisplay_u8-1));
 6cc:	8f ef       	ldi	r24, 0xFF	; 255
 6ce:	84 0f       	add	r24, r20
 6d0:	85 01       	movw	r16, r10
 6d2:	02 c0       	rjmp	.+4      	; 0x6d8 <LCD_DisplayNumber.part.3+0x34>
 6d4:	00 0f       	add	r16, r16
 6d6:	11 1f       	adc	r17, r17
 6d8:	8a 95       	dec	r24
 6da:	e2 f7       	brpl	.-8      	; 0x6d4 <LCD_DisplayNumber.part.3+0x30>
 6dc:	01 2e       	mov	r0, r17
 6de:	00 0c       	add	r0, r0
 6e0:	22 0b       	sbc	r18, r18
 6e2:	33 0b       	sbc	r19, r19
 6e4:	0c 21       	and	r16, r12
 6e6:	1d 21       	and	r17, r13
 6e8:	2e 21       	and	r18, r14
 6ea:	3f 21       	and	r19, r15
 6ec:	81 e0       	ldi	r24, 0x01	; 1
 6ee:	01 2b       	or	r16, r17
 6f0:	02 2b       	or	r16, r18
 6f2:	03 2b       	or	r16, r19
 6f4:	09 f4       	brne	.+2      	; 0x6f8 <LCD_DisplayNumber.part.3+0x54>
 6f6:	80 e0       	ldi	r24, 0x00	; 0
          LCD_DisplayChar(util_Dec2Ascii(i));
 6f8:	80 5d       	subi	r24, 0xD0	; 208
 6fa:	49 83       	std	Y+1, r20	; 0x01
 6fc:	0e 94 26 03 	call	0x64c	; 0x64c <LCD_DisplayChar>
          v_numOfDigitsToDisplay_u8--;
 700:	49 81       	ldd	r20, Y+1	; 0x01
 702:	41 50       	subi	r20, 0x01	; 1
 704:	e1 cf       	rjmp	.-62     	; 0x6c8 <LCD_DisplayNumber.part.3+0x24>
          /* Finally get the ascii values of the digits and display*/
          LCD_DisplayChar(util_Hex2Ascii(a[i-1]));
          i--;
        }
    }
}
 706:	0f 90       	pop	r0
 708:	df 91       	pop	r29
 70a:	cf 91       	pop	r28
 70c:	1f 91       	pop	r17
 70e:	0f 91       	pop	r16
 710:	ff 90       	pop	r15
 712:	ef 90       	pop	r14
 714:	df 90       	pop	r13
 716:	cf 90       	pop	r12
 718:	bf 90       	pop	r11
 71a:	af 90       	pop	r10
 71c:	08 95       	ret

0000071e <LCD_DisplayString>:
                    and traverses till the end(NULL CHAR)and displays a char each time.

****************************************************************************************************/
#if (Enable_LCD_DisplayString==1)
void LCD_DisplayString(const char *ptr_stringPointer_u8)
{
 71e:	cf 93       	push	r28
 720:	df 93       	push	r29
 722:	ec 01       	movw	r28, r24
    while((*ptr_stringPointer_u8)!=0)
 724:	89 91       	ld	r24, Y+
 726:	88 23       	and	r24, r24
 728:	19 f0       	breq	.+6      	; 0x730 <LCD_DisplayString+0x12>
        LCD_DisplayChar(*ptr_stringPointer_u8++); // Loop through the string and display char by char
 72a:	0e 94 26 03 	call	0x64c	; 0x64c <LCD_DisplayChar>
 72e:	fa cf       	rjmp	.-12     	; 0x724 <LCD_DisplayString+0x6>
}
 730:	df 91       	pop	r29
 732:	cf 91       	pop	r28
 734:	08 95       	ret

00000736 <LCD_DisplayNumber>:
                8.(C_HEX_U8,0x12AB,6) then 6-digits ie. 0012AB will be displayed
                9.(C_HEX_U8,0x12AB,C_DisplayDefaultDigits_U8) then 12AB will be displayed.                
****************************************************************************************************/
#if ((Enable_LCD_DisplayNumber == 1) || (Enable_LCD_DisplayFloatNumber == 1) || (Enable_LCD_Printf==1))
void LCD_DisplayNumber(uint8_t v_numericSystem_u8, uint32_t v_number_u32, uint8_t v_numOfDigitsToDisplay_u8)
{
 736:	4f 92       	push	r4
 738:	5f 92       	push	r5
 73a:	6f 92       	push	r6
 73c:	7f 92       	push	r7
 73e:	bf 92       	push	r11
 740:	cf 92       	push	r12
 742:	df 92       	push	r13
 744:	ef 92       	push	r14
 746:	ff 92       	push	r15
 748:	0f 93       	push	r16
 74a:	1f 93       	push	r17
 74c:	cf 93       	push	r28
 74e:	df 93       	push	r29
 750:	cd b7       	in	r28, 0x3d	; 61
 752:	de b7       	in	r29, 0x3e	; 62
 754:	2a 97       	sbiw	r28, 0x0a	; 10
 756:	0f b6       	in	r0, 0x3f	; 63
 758:	f8 94       	cli
 75a:	de bf       	out	0x3e, r29	; 62
 75c:	0f be       	out	0x3f, r0	; 63
 75e:	cd bf       	out	0x3d, r28	; 61
 760:	b8 2e       	mov	r11, r24
 762:	cb 01       	movw	r24, r22
 764:	ba 01       	movw	r22, r20
 766:	02 2f       	mov	r16, r18
    uint8_t i=0,a[10];
    
    if(C_BINARY_U8 == v_numericSystem_u8)
 768:	22 e0       	ldi	r18, 0x02	; 2
 76a:	b2 12       	cpse	r11, r18
 76c:	16 c0       	rjmp	.+44     	; 0x79a <LCD_DisplayNumber+0x64>
 76e:	40 2f       	mov	r20, r16
          /* Finally get the ascii values of the digits and display*/
          LCD_DisplayChar(util_Hex2Ascii(a[i-1]));
          i--;
        }
    }
}
 770:	2a 96       	adiw	r28, 0x0a	; 10
 772:	0f b6       	in	r0, 0x3f	; 63
 774:	f8 94       	cli
 776:	de bf       	out	0x3e, r29	; 62
 778:	0f be       	out	0x3f, r0	; 63
 77a:	cd bf       	out	0x3d, r28	; 61
 77c:	df 91       	pop	r29
 77e:	cf 91       	pop	r28
 780:	1f 91       	pop	r17
 782:	0f 91       	pop	r16
 784:	ff 90       	pop	r15
 786:	ef 90       	pop	r14
 788:	df 90       	pop	r13
 78a:	cf 90       	pop	r12
 78c:	bf 90       	pop	r11
 78e:	7f 90       	pop	r7
 790:	6f 90       	pop	r6
 792:	5f 90       	pop	r5
 794:	4f 90       	pop	r4
 796:	0c 94 52 03 	jmp	0x6a4	; 0x6a4 <LCD_DisplayNumber.part.3>
          i = util_GetBitStatus(v_number_u32,(v_numOfDigitsToDisplay_u8-1));
          LCD_DisplayChar(util_Dec2Ascii(i));
          v_numOfDigitsToDisplay_u8--;
        }        
    }    
    else if(v_number_u32==0)
 79a:	61 15       	cp	r22, r1
 79c:	71 05       	cpc	r23, r1
 79e:	81 05       	cpc	r24, r1
 7a0:	91 05       	cpc	r25, r1
 7a2:	49 f0       	breq	.+18     	; 0x7b6 <LCD_DisplayNumber+0x80>
 7a4:	fe 01       	movw	r30, r28
 7a6:	31 96       	adiw	r30, 0x01	; 1
 7a8:	6f 01       	movw	r12, r30
 7aa:	7f 01       	movw	r14, r30
                First get the remainder and divide the number by TypeOfNum(10-Dec, 16-Hex) each time.
                
                example for Decimal number: 
                If v_number_u32 = 123 then extracted remainder will be 3 and number will be 12.
                The process continues till it becomes zero or max digits reached*/
                a[i]=util_GetMod32(v_number_u32,v_numericSystem_u8);
 7ac:	4b 2c       	mov	r4, r11
 7ae:	51 2c       	mov	r5, r1
 7b0:	61 2c       	mov	r6, r1
 7b2:	71 2c       	mov	r7, r1
 7b4:	2a c0       	rjmp	.+84     	; 0x80a <LCD_DisplayNumber+0xd4>
    else if(v_number_u32==0)
    {
        /* If the number is zero then display Specified number of zeros*/
        /*TODO: Display single zero or multiple. Currently single zero is displayed*/
        //for(i=0;((i<v_numOfDigitsToDisplay_u8) && (i<C_MaxDigitsToDisplay_U8));i++)
            LCD_DisplayChar('0');
 7b6:	80 e3       	ldi	r24, 0x30	; 48
          /* Finally get the ascii values of the digits and display*/
          LCD_DisplayChar(util_Hex2Ascii(a[i-1]));
          i--;
        }
    }
}
 7b8:	2a 96       	adiw	r28, 0x0a	; 10
 7ba:	0f b6       	in	r0, 0x3f	; 63
 7bc:	f8 94       	cli
 7be:	de bf       	out	0x3e, r29	; 62
 7c0:	0f be       	out	0x3f, r0	; 63
 7c2:	cd bf       	out	0x3d, r28	; 61
 7c4:	df 91       	pop	r29
 7c6:	cf 91       	pop	r28
 7c8:	1f 91       	pop	r17
 7ca:	0f 91       	pop	r16
 7cc:	ff 90       	pop	r15
 7ce:	ef 90       	pop	r14
 7d0:	df 90       	pop	r13
 7d2:	cf 90       	pop	r12
 7d4:	bf 90       	pop	r11
 7d6:	7f 90       	pop	r7
 7d8:	6f 90       	pop	r6
 7da:	5f 90       	pop	r5
 7dc:	4f 90       	pop	r4
    else if(v_number_u32==0)
    {
        /* If the number is zero then display Specified number of zeros*/
        /*TODO: Display single zero or multiple. Currently single zero is displayed*/
        //for(i=0;((i<v_numOfDigitsToDisplay_u8) && (i<C_MaxDigitsToDisplay_U8));i++)
            LCD_DisplayChar('0');
 7de:	0c 94 26 03 	jmp	0x64c	; 0x64c <LCD_DisplayChar>
    {
        for(i=0;i<v_numOfDigitsToDisplay_u8;i++)
        {
            /* Continue extracting the digits from right side
               till the Specified v_numOfDigitsToDisplay_u8 */
            if(v_number_u32!=0)
 7e2:	61 15       	cp	r22, r1
 7e4:	71 05       	cpc	r23, r1
 7e6:	81 05       	cpc	r24, r1
 7e8:	91 05       	cpc	r25, r1
 7ea:	a1 f0       	breq	.+40     	; 0x814 <LCD_DisplayNumber+0xde>
                First get the remainder and divide the number by TypeOfNum(10-Dec, 16-Hex) each time.
                
                example for Decimal number: 
                If v_number_u32 = 123 then extracted remainder will be 3 and number will be 12.
                The process continues till it becomes zero or max digits reached*/
                a[i]=util_GetMod32(v_number_u32,v_numericSystem_u8);
 7ec:	16 2f       	mov	r17, r22
 7ee:	a3 01       	movw	r20, r6
 7f0:	92 01       	movw	r18, r4
 7f2:	0e 94 85 07 	call	0xf0a	; 0xf0a <__udivmodsi4>
 7f6:	ca 01       	movw	r24, r20
 7f8:	b9 01       	movw	r22, r18
 7fa:	b2 9e       	mul	r11, r18
 7fc:	10 19       	sub	r17, r0
 7fe:	11 24       	eor	r1, r1
 800:	f7 01       	movw	r30, r14
 802:	10 83       	st	Z, r17
 804:	ff ef       	ldi	r31, 0xFF	; 255
 806:	ef 1a       	sub	r14, r31
 808:	ff 0a       	sbc	r15, r31
 80a:	1e 2d       	mov	r17, r14
 80c:	1c 19       	sub	r17, r12
        //for(i=0;((i<v_numOfDigitsToDisplay_u8) && (i<C_MaxDigitsToDisplay_U8));i++)
            LCD_DisplayChar('0');
    }
    else
    {
        for(i=0;i<v_numOfDigitsToDisplay_u8;i++)
 80e:	10 17       	cp	r17, r16
 810:	40 f3       	brcs	.-48     	; 0x7e2 <LCD_DisplayNumber+0xac>
 812:	0f c0       	rjmp	.+30     	; 0x832 <LCD_DisplayNumber+0xfc>
                If v_number_u32 = 123 then extracted remainder will be 3 and number will be 12.
                The process continues till it becomes zero or max digits reached*/
                a[i]=util_GetMod32(v_number_u32,v_numericSystem_u8);
                v_number_u32=v_number_u32/v_numericSystem_u8;
            }
            else if( (v_numOfDigitsToDisplay_u8 == C_DisplayDefaultDigits_U8) ||
 814:	0b 30       	cpi	r16, 0x0B	; 11
 816:	68 f4       	brcc	.+26     	; 0x832 <LCD_DisplayNumber+0xfc>
            else
            {
                /* In case user expects more digits to be displayed than the actual digits in number,
                  then update the remaining digits with zero.
               Ex: v_num_u32 is 123 and user wants five digits then 00123 has to be displayed */
                a[i]=0;
 818:	f7 01       	movw	r30, r14
 81a:	10 82       	st	Z, r1
 81c:	f3 cf       	rjmp	.-26     	; 0x804 <LCD_DisplayNumber+0xce>
        }
        
         while(i!=0)
        { 
          /* Finally get the ascii values of the digits and display*/
          LCD_DisplayChar(util_Hex2Ascii(a[i-1]));
 81e:	fe 01       	movw	r30, r28
 820:	e1 0f       	add	r30, r17
 822:	f1 1d       	adc	r31, r1
 824:	80 81       	ld	r24, Z
 826:	8a 30       	cpi	r24, 0x0A	; 10
 828:	38 f0       	brcs	.+14     	; 0x838 <LCD_DisplayNumber+0x102>
 82a:	89 5c       	subi	r24, 0xC9	; 201
 82c:	0e 94 26 03 	call	0x64c	; 0x64c <LCD_DisplayChar>
          i--;
 830:	11 50       	subi	r17, 0x01	; 1
               Ex: v_num_u32 is 123 and user wants five digits then 00123 has to be displayed */
                a[i]=0;
            }
        }
        
         while(i!=0)
 832:	11 11       	cpse	r17, r1
 834:	f4 cf       	rjmp	.-24     	; 0x81e <LCD_DisplayNumber+0xe8>
 836:	02 c0       	rjmp	.+4      	; 0x83c <LCD_DisplayNumber+0x106>
        { 
          /* Finally get the ascii values of the digits and display*/
          LCD_DisplayChar(util_Hex2Ascii(a[i-1]));
 838:	80 5d       	subi	r24, 0xD0	; 208
 83a:	f8 cf       	rjmp	.-16     	; 0x82c <LCD_DisplayNumber+0xf6>
          i--;
        }
    }
}
 83c:	2a 96       	adiw	r28, 0x0a	; 10
 83e:	0f b6       	in	r0, 0x3f	; 63
 840:	f8 94       	cli
 842:	de bf       	out	0x3e, r29	; 62
 844:	0f be       	out	0x3f, r0	; 63
 846:	cd bf       	out	0x3d, r28	; 61
 848:	df 91       	pop	r29
 84a:	cf 91       	pop	r28
 84c:	1f 91       	pop	r17
 84e:	0f 91       	pop	r16
 850:	ff 90       	pop	r15
 852:	ef 90       	pop	r14
 854:	df 90       	pop	r13
 856:	cf 90       	pop	r12
 858:	bf 90       	pop	r11
 85a:	7f 90       	pop	r7
 85c:	6f 90       	pop	r6
 85e:	5f 90       	pop	r5
 860:	4f 90       	pop	r4
 862:	08 95       	ret

00000864 <LCD_DisplayFloatNumber>:
    Note: Float will be disabled by default as it takes huge controller resources
         It can be enabled by changing value of Enable_LCD_DisplayFloatNumber to 1 in lcd.h
***************************************************************************************************/
#if (Enable_LCD_DisplayFloatNumber == 1)  
void LCD_DisplayFloatNumber(double v_floatNum_f32)
{
 864:	8f 92       	push	r8
 866:	9f 92       	push	r9
 868:	af 92       	push	r10
 86a:	bf 92       	push	r11
 86c:	cf 92       	push	r12
 86e:	df 92       	push	r13
 870:	ef 92       	push	r14
 872:	ff 92       	push	r15
 874:	6b 01       	movw	r12, r22
 876:	7c 01       	movw	r14, r24
      1.Type cast the number to int to get the integer part.
      2.Display the extracted integer part followed by a decimal point(.)
      3.Later the integer part is made zero by subtracting with the extracted integer value.
      4.Finally the fractional part is multiplied by 100000 to support 6-digit precision */

    v_decNumber_u32 = (uint32_t) v_floatNum_f32;
 878:	0e 94 5b 06 	call	0xcb6	; 0xcb6 <__fixunssfsi>
 87c:	4b 01       	movw	r8, r22
 87e:	5c 01       	movw	r10, r24
    LCD_DisplayNumber(C_DECIMAL_U8,v_decNumber_u32,C_DisplayDefaultDigits_U8);
 880:	2f ef       	ldi	r18, 0xFF	; 255
 882:	ab 01       	movw	r20, r22
 884:	bc 01       	movw	r22, r24
 886:	8a e0       	ldi	r24, 0x0A	; 10
 888:	0e 94 9b 03 	call	0x736	; 0x736 <LCD_DisplayNumber>

    LCD_DisplayChar('.');
 88c:	8e e2       	ldi	r24, 0x2E	; 46
 88e:	0e 94 26 03 	call	0x64c	; 0x64c <LCD_DisplayChar>

    v_floatNum_f32 = v_floatNum_f32 - v_decNumber_u32;
 892:	c5 01       	movw	r24, r10
 894:	b4 01       	movw	r22, r8
 896:	0e 94 8a 06 	call	0xd14	; 0xd14 <__floatunsisf>
 89a:	9b 01       	movw	r18, r22
 89c:	ac 01       	movw	r20, r24
 89e:	c7 01       	movw	r24, r14
 8a0:	b6 01       	movw	r22, r12
 8a2:	0e 94 ee 05 	call	0xbdc	; 0xbdc <__subsf3>
    v_decNumber_u32 = v_floatNum_f32 * 1000000;
 8a6:	20 e0       	ldi	r18, 0x00	; 0
 8a8:	34 e2       	ldi	r19, 0x24	; 36
 8aa:	44 e7       	ldi	r20, 0x74	; 116
 8ac:	59 e4       	ldi	r21, 0x49	; 73
 8ae:	0e 94 18 07 	call	0xe30	; 0xe30 <__mulsf3>
 8b2:	0e 94 5b 06 	call	0xcb6	; 0xcb6 <__fixunssfsi>
 8b6:	ab 01       	movw	r20, r22
 8b8:	bc 01       	movw	r22, r24
    LCD_DisplayNumber(C_DECIMAL_U8,v_decNumber_u32,C_DisplayDefaultDigits_U8);
 8ba:	2f ef       	ldi	r18, 0xFF	; 255
 8bc:	8a e0       	ldi	r24, 0x0A	; 10
}
 8be:	ff 90       	pop	r15
 8c0:	ef 90       	pop	r14
 8c2:	df 90       	pop	r13
 8c4:	cf 90       	pop	r12
 8c6:	bf 90       	pop	r11
 8c8:	af 90       	pop	r10
 8ca:	9f 90       	pop	r9
 8cc:	8f 90       	pop	r8

    LCD_DisplayChar('.');

    v_floatNum_f32 = v_floatNum_f32 - v_decNumber_u32;
    v_decNumber_u32 = v_floatNum_f32 * 1000000;
    LCD_DisplayNumber(C_DECIMAL_U8,v_decNumber_u32,C_DisplayDefaultDigits_U8);
 8ce:	0c 94 9b 03 	jmp	0x736	; 0x736 <LCD_DisplayNumber>

000008d2 <LCD_Printf>:
        uint8_t v_Num_u8;
        LCD_Printf("num1:%u",(uint16_t)v_Num_u8); 
**************************************************************************************************/
#if ( Enable_LCD_Printf   == 1 ) 
void LCD_Printf(const char *argList, ...)
{
 8d2:	cf 92       	push	r12
 8d4:	df 92       	push	r13
 8d6:	ef 92       	push	r14
 8d8:	ff 92       	push	r15
 8da:	0f 93       	push	r16
 8dc:	1f 93       	push	r17
 8de:	cf 93       	push	r28
 8e0:	df 93       	push	r29
 8e2:	00 d0       	rcall	.+0      	; 0x8e4 <LCD_Printf+0x12>
 8e4:	00 d0       	rcall	.+0      	; 0x8e6 <LCD_Printf+0x14>
 8e6:	1f 92       	push	r1
 8e8:	cd b7       	in	r28, 0x3d	; 61
 8ea:	de b7       	in	r29, 0x3e	; 62
 8ec:	fe 01       	movw	r30, r28
 8ee:	70 96       	adiw	r30, 0x10	; 16
 8f0:	c1 90       	ld	r12, Z+
 8f2:	d1 90       	ld	r13, Z+
    uint8_t v_numOfDigitsToDisp_u8;
#if (Enable_LCD_DisplayFloatNumber == 1)  
    double v_floatNum_f32;
#endif

    va_start(argp, argList);
 8f4:	8f 01       	movw	r16, r30

    /* Loop through the list to extract all the input arguments */
    for(ptr = argList; *ptr != '\0'; ptr++)
 8f6:	f6 01       	movw	r30, r12
 8f8:	80 81       	ld	r24, Z
 8fa:	88 23       	and	r24, r24
 8fc:	09 f4       	brne	.+2      	; 0x900 <LCD_Printf+0x2e>
 8fe:	2c c1       	rjmp	.+600    	; 0xb58 <LCD_Printf+0x286>
    {

        ch= *ptr;
        if(ch == '%')         /*Check for '%' as there will be format specifier after it */
 900:	85 32       	cpi	r24, 0x25	; 37
 902:	09 f0       	breq	.+2      	; 0x906 <LCD_Printf+0x34>
 904:	0e c1       	rjmp	.+540    	; 0xb22 <LCD_Printf+0x250>
        {
            ptr++;
 906:	76 01       	movw	r14, r12
 908:	8f ef       	ldi	r24, 0xFF	; 255
 90a:	e8 1a       	sub	r14, r24
 90c:	f8 0a       	sbc	r15, r24
            ch = *ptr;
 90e:	f6 01       	movw	r30, r12
 910:	81 81       	ldd	r24, Z+1	; 0x01
           if((ch>=0x30) && (ch<=0x39))
 912:	90 ed       	ldi	r25, 0xD0	; 208
 914:	98 0f       	add	r25, r24
 916:	9a 30       	cpi	r25, 0x0A	; 10
 918:	08 f0       	brcs	.+2      	; 0x91c <LCD_Printf+0x4a>
 91a:	b7 c0       	rjmp	.+366    	; 0xa8a <LCD_Printf+0x1b8>
 91c:	20 e0       	ldi	r18, 0x00	; 0
            {
               v_numOfDigitsToDisp_u8 = 0;
               while((ch>=0x30) && (ch<=0x39))
 91e:	90 ed       	ldi	r25, 0xD0	; 208
 920:	98 0f       	add	r25, r24
 922:	9a 30       	cpi	r25, 0x0A	; 10
 924:	58 f4       	brcc	.+22     	; 0x93c <LCD_Printf+0x6a>
                {
                   v_numOfDigitsToDisp_u8 = (v_numOfDigitsToDisp_u8 * 10) + (ch-0x30);
 926:	fa e0       	ldi	r31, 0x0A	; 10
 928:	2f 9f       	mul	r18, r31
 92a:	90 0d       	add	r25, r0
 92c:	11 24       	eor	r1, r1
 92e:	29 2f       	mov	r18, r25
                   ptr++;
 930:	8f ef       	ldi	r24, 0xFF	; 255
 932:	e8 1a       	sub	r14, r24
 934:	f8 0a       	sbc	r15, r24
                   ch = *ptr;
 936:	f7 01       	movw	r30, r14
 938:	80 81       	ld	r24, Z
 93a:	f1 cf       	rjmp	.-30     	; 0x91e <LCD_Printf+0x4c>
            {
              v_numOfDigitsToDisp_u8 = C_MaxDigitsToDisplayUsingPrintf_U8;
            }                


            switch(ch)       /* Decode the type of the argument */
 93c:	88 35       	cpi	r24, 0x58	; 88
 93e:	09 f4       	brne	.+2      	; 0x942 <LCD_Printf+0x70>
 940:	a8 c0       	rjmp	.+336    	; 0xa92 <LCD_Printf+0x1c0>
 942:	70 f4       	brcc	.+28     	; 0x960 <LCD_Printf+0x8e>
 944:	84 34       	cpi	r24, 0x44	; 68
 946:	09 f4       	brne	.+2      	; 0x94a <LCD_Printf+0x78>
 948:	50 c0       	rjmp	.+160    	; 0x9ea <LCD_Printf+0x118>
 94a:	18 f4       	brcc	.+6      	; 0x952 <LCD_Printf+0x80>
 94c:	82 34       	cpi	r24, 0x42	; 66
 94e:	d9 f4       	brne	.+54     	; 0x986 <LCD_Printf+0xb4>
 950:	bd c0       	rjmp	.+378    	; 0xacc <LCD_Printf+0x1fa>
 952:	83 35       	cpi	r24, 0x53	; 83
 954:	09 f4       	brne	.+2      	; 0x958 <LCD_Printf+0x86>
 956:	da c0       	rjmp	.+436    	; 0xb0c <LCD_Printf+0x23a>
 958:	85 35       	cpi	r24, 0x55	; 85
 95a:	09 f4       	brne	.+2      	; 0x95e <LCD_Printf+0x8c>
 95c:	7d c0       	rjmp	.+250    	; 0xa58 <LCD_Printf+0x186>
 95e:	c6 c0       	rjmp	.+396    	; 0xaec <LCD_Printf+0x21a>
 960:	86 36       	cpi	r24, 0x66	; 102
 962:	09 f4       	brne	.+2      	; 0x966 <LCD_Printf+0x94>
 964:	c5 c0       	rjmp	.+394    	; 0xaf0 <LCD_Printf+0x21e>
 966:	40 f4       	brcc	.+16     	; 0x978 <LCD_Printf+0xa6>
 968:	83 36       	cpi	r24, 0x63	; 99
 96a:	81 f0       	breq	.+32     	; 0x98c <LCD_Printf+0xba>
 96c:	84 36       	cpi	r24, 0x64	; 100
 96e:	21 f1       	breq	.+72     	; 0x9b8 <LCD_Printf+0xe6>
 970:	82 36       	cpi	r24, 0x62	; 98
 972:	09 f0       	breq	.+2      	; 0x976 <LCD_Printf+0xa4>
 974:	d9 c0       	rjmp	.+434    	; 0xb28 <LCD_Printf+0x256>
 976:	9d c0       	rjmp	.+314    	; 0xab2 <LCD_Printf+0x1e0>
 978:	85 37       	cpi	r24, 0x75	; 117
 97a:	09 f4       	brne	.+2      	; 0x97e <LCD_Printf+0xac>
 97c:	59 c0       	rjmp	.+178    	; 0xa30 <LCD_Printf+0x15e>
 97e:	88 37       	cpi	r24, 0x78	; 120
 980:	09 f4       	brne	.+2      	; 0x984 <LCD_Printf+0xb2>
 982:	79 c0       	rjmp	.+242    	; 0xa76 <LCD_Printf+0x1a4>
 984:	c1 c0       	rjmp	.+386    	; 0xb08 <LCD_Printf+0x236>
 986:	83 34       	cpi	r24, 0x43	; 67
 988:	08 f4       	brcc	.+2      	; 0x98c <LCD_Printf+0xba>
 98a:	e0 c0       	rjmp	.+448    	; 0xb4c <LCD_Printf+0x27a>
            {
            case 'C':
            case 'c':     /* Argument type is of char, hence read char data from the argp */
                ch = va_arg(argp, int);
 98c:	68 01       	movw	r12, r16
 98e:	f2 e0       	ldi	r31, 0x02	; 2
 990:	cf 0e       	add	r12, r31
 992:	d1 1c       	adc	r13, r1
                LCD_DisplayChar(ch);
 994:	f8 01       	movw	r30, r16
 996:	80 81       	ld	r24, Z
 998:	0e 94 26 03 	call	0x64c	; 0x64c <LCD_DisplayChar>
 99c:	c0 c0       	rjmp	.+384    	; 0xb1e <LCD_Printf+0x24c>
            {
              v_numOfDigitsToDisp_u8 = C_MaxDigitsToDisplayUsingPrintf_U8;
            }                


            switch(ch)       /* Decode the type of the argument */
 99e:	89 35       	cpi	r24, 0x59	; 89
 9a0:	08 f1       	brcs	.+66     	; 0x9e4 <LCD_Printf+0x112>
 9a2:	86 36       	cpi	r24, 0x66	; 102
 9a4:	09 f4       	brne	.+2      	; 0x9a8 <LCD_Printf+0xd6>
 9a6:	a4 c0       	rjmp	.+328    	; 0xaf0 <LCD_Printf+0x21e>
 9a8:	08 f0       	brcs	.+2      	; 0x9ac <LCD_Printf+0xda>
 9aa:	3f c0       	rjmp	.+126    	; 0xa2a <LCD_Printf+0x158>
 9ac:	83 36       	cpi	r24, 0x63	; 99
 9ae:	71 f3       	breq	.-36     	; 0x98c <LCD_Printf+0xba>
 9b0:	84 36       	cpi	r24, 0x64	; 100
 9b2:	09 f0       	breq	.+2      	; 0x9b6 <LCD_Printf+0xe4>
 9b4:	7b c0       	rjmp	.+246    	; 0xaac <LCD_Printf+0x1da>
                   ch = *ptr;
                }
            }
            else
            {
              v_numOfDigitsToDisp_u8 = C_MaxDigitsToDisplayUsingPrintf_U8;
 9b6:	2f ef       	ldi	r18, 0xFF	; 255
                ch = va_arg(argp, int);
                LCD_DisplayChar(ch);
                break;

            case 'd':    /* Argument type is of signed integer, hence read 16bit data from the argp */
                v_num_s16 = va_arg(argp, int);
 9b8:	68 01       	movw	r12, r16
 9ba:	f2 e0       	ldi	r31, 0x02	; 2
 9bc:	cf 0e       	add	r12, r31
 9be:	d1 1c       	adc	r13, r1
 9c0:	f8 01       	movw	r30, r16
 9c2:	00 81       	ld	r16, Z
 9c4:	11 81       	ldd	r17, Z+1	; 0x01
                if(v_num_s16<0)
 9c6:	17 ff       	sbrs	r17, 7
 9c8:	08 c0       	rjmp	.+16     	; 0x9da <LCD_Printf+0x108>
                 { /* If the number is -ve then display the 2's complement along with '-' sign */ 
                   v_num_s16 = -v_num_s16;
 9ca:	11 95       	neg	r17
 9cc:	01 95       	neg	r16
 9ce:	11 09       	sbc	r17, r1
                   LCD_DisplayChar('-');
 9d0:	8d e2       	ldi	r24, 0x2D	; 45
 9d2:	2d 83       	std	Y+5, r18	; 0x05
 9d4:	0e 94 26 03 	call	0x64c	; 0x64c <LCD_DisplayChar>
 9d8:	2d 81       	ldd	r18, Y+5	; 0x05
                 }
                LCD_DisplayNumber(C_DECIMAL_U8,v_num_s16,v_numOfDigitsToDisp_u8);
 9da:	a8 01       	movw	r20, r16
 9dc:	11 0f       	add	r17, r17
 9de:	66 0b       	sbc	r22, r22
 9e0:	77 0b       	sbc	r23, r23
 9e2:	43 c0       	rjmp	.+134    	; 0xa6a <LCD_Printf+0x198>
            {
              v_numOfDigitsToDisp_u8 = C_MaxDigitsToDisplayUsingPrintf_U8;
            }                


            switch(ch)       /* Decode the type of the argument */
 9e4:	84 34       	cpi	r24, 0x44	; 68
 9e6:	71 f5       	brne	.+92     	; 0xa44 <LCD_Printf+0x172>
                   ch = *ptr;
                }
            }
            else
            {
              v_numOfDigitsToDisp_u8 = C_MaxDigitsToDisplayUsingPrintf_U8;
 9e8:	2f ef       	ldi	r18, 0xFF	; 255
                 }
                LCD_DisplayNumber(C_DECIMAL_U8,v_num_s16,v_numOfDigitsToDisp_u8);
                break;
                
            case 'D':    /* Argument type is of integer, hence read 16bit data from the argp */
                v_num_s32 = va_arg(argp, sint32_t);
 9ea:	68 01       	movw	r12, r16
 9ec:	f4 e0       	ldi	r31, 0x04	; 4
 9ee:	cf 0e       	add	r12, r31
 9f0:	d1 1c       	adc	r13, r1
 9f2:	f8 01       	movw	r30, r16
 9f4:	40 81       	ld	r20, Z
 9f6:	51 81       	ldd	r21, Z+1	; 0x01
 9f8:	62 81       	ldd	r22, Z+2	; 0x02
 9fa:	73 81       	ldd	r23, Z+3	; 0x03
                if(v_num_s32<0)
 9fc:	77 ff       	sbrs	r23, 7
 9fe:	35 c0       	rjmp	.+106    	; 0xa6a <LCD_Printf+0x198>
                 { /* If the number is -ve then display the 2's complement along with '-' sign */
                   v_num_s32 = -v_num_s32;
 a00:	70 95       	com	r23
 a02:	60 95       	com	r22
 a04:	50 95       	com	r21
 a06:	41 95       	neg	r20
 a08:	5f 4f       	sbci	r21, 0xFF	; 255
 a0a:	6f 4f       	sbci	r22, 0xFF	; 255
 a0c:	7f 4f       	sbci	r23, 0xFF	; 255
                   LCD_DisplayChar('-');
 a0e:	8d e2       	ldi	r24, 0x2D	; 45
 a10:	2d 83       	std	Y+5, r18	; 0x05
 a12:	49 83       	std	Y+1, r20	; 0x01
 a14:	5a 83       	std	Y+2, r21	; 0x02
 a16:	6b 83       	std	Y+3, r22	; 0x03
 a18:	7c 83       	std	Y+4, r23	; 0x04
 a1a:	0e 94 26 03 	call	0x64c	; 0x64c <LCD_DisplayChar>
 a1e:	7c 81       	ldd	r23, Y+4	; 0x04
 a20:	6b 81       	ldd	r22, Y+3	; 0x03
 a22:	5a 81       	ldd	r21, Y+2	; 0x02
 a24:	49 81       	ldd	r20, Y+1	; 0x01
 a26:	2d 81       	ldd	r18, Y+5	; 0x05
 a28:	20 c0       	rjmp	.+64     	; 0xa6a <LCD_Printf+0x198>
            {
              v_numOfDigitsToDisp_u8 = C_MaxDigitsToDisplayUsingPrintf_U8;
            }                


            switch(ch)       /* Decode the type of the argument */
 a2a:	85 37       	cpi	r24, 0x75	; 117
 a2c:	01 f5       	brne	.+64     	; 0xa6e <LCD_Printf+0x19c>
                   ch = *ptr;
                }
            }
            else
            {
              v_numOfDigitsToDisp_u8 = C_MaxDigitsToDisplayUsingPrintf_U8;
 a2e:	2f ef       	ldi	r18, 0xFF	; 255
                 }
                LCD_DisplayNumber(C_DECIMAL_U8,v_num_s32,v_numOfDigitsToDisp_u8);              
                break;    

            case 'u':    /* Argument type is of unsigned integer, hence read 16bit unsigned data */
                v_num_u16 = va_arg(argp, int);
 a30:	68 01       	movw	r12, r16
 a32:	f2 e0       	ldi	r31, 0x02	; 2
 a34:	cf 0e       	add	r12, r31
 a36:	d1 1c       	adc	r13, r1
                LCD_DisplayNumber(C_DECIMAL_U8,v_num_u16,v_numOfDigitsToDisp_u8);
 a38:	f8 01       	movw	r30, r16
 a3a:	40 81       	ld	r20, Z
 a3c:	51 81       	ldd	r21, Z+1	; 0x01
 a3e:	60 e0       	ldi	r22, 0x00	; 0
 a40:	70 e0       	ldi	r23, 0x00	; 0
 a42:	13 c0       	rjmp	.+38     	; 0xa6a <LCD_Printf+0x198>
            {
              v_numOfDigitsToDisp_u8 = C_MaxDigitsToDisplayUsingPrintf_U8;
            }                


            switch(ch)       /* Decode the type of the argument */
 a44:	85 34       	cpi	r24, 0x45	; 69
 a46:	08 f4       	brcc	.+2      	; 0xa4a <LCD_Printf+0x178>
 a48:	74 c0       	rjmp	.+232    	; 0xb32 <LCD_Printf+0x260>
 a4a:	83 35       	cpi	r24, 0x53	; 83
 a4c:	09 f4       	brne	.+2      	; 0xa50 <LCD_Printf+0x17e>
 a4e:	5e c0       	rjmp	.+188    	; 0xb0c <LCD_Printf+0x23a>
 a50:	85 35       	cpi	r24, 0x55	; 85
 a52:	09 f0       	breq	.+2      	; 0xa56 <LCD_Printf+0x184>
 a54:	4b c0       	rjmp	.+150    	; 0xaec <LCD_Printf+0x21a>
                   ch = *ptr;
                }
            }
            else
            {
              v_numOfDigitsToDisp_u8 = C_MaxDigitsToDisplayUsingPrintf_U8;
 a56:	2f ef       	ldi	r18, 0xFF	; 255
                v_num_u16 = va_arg(argp, int);
                LCD_DisplayNumber(C_DECIMAL_U8,v_num_u16,v_numOfDigitsToDisp_u8);
                break;
            
            case 'U':    /* Argument type is of integer, hence read 32bit unsigend data */
                v_num_u32 = va_arg(argp, uint32_t);
 a58:	68 01       	movw	r12, r16
 a5a:	f4 e0       	ldi	r31, 0x04	; 4
 a5c:	cf 0e       	add	r12, r31
 a5e:	d1 1c       	adc	r13, r1
                LCD_DisplayNumber(C_DECIMAL_U8,v_num_u32,v_numOfDigitsToDisp_u8);               
 a60:	f8 01       	movw	r30, r16
 a62:	40 81       	ld	r20, Z
 a64:	51 81       	ldd	r21, Z+1	; 0x01
 a66:	62 81       	ldd	r22, Z+2	; 0x02
 a68:	73 81       	ldd	r23, Z+3	; 0x03
 a6a:	8a e0       	ldi	r24, 0x0A	; 10
 a6c:	1c c0       	rjmp	.+56     	; 0xaa6 <LCD_Printf+0x1d4>
            {
              v_numOfDigitsToDisp_u8 = C_MaxDigitsToDisplayUsingPrintf_U8;
            }                


            switch(ch)       /* Decode the type of the argument */
 a6e:	88 37       	cpi	r24, 0x78	; 120
 a70:	09 f0       	breq	.+2      	; 0xa74 <LCD_Printf+0x1a2>
 a72:	4a c0       	rjmp	.+148    	; 0xb08 <LCD_Printf+0x236>
                   ch = *ptr;
                }
            }
            else
            {
              v_numOfDigitsToDisp_u8 = C_MaxDigitsToDisplayUsingPrintf_U8;
 a74:	2f ef       	ldi	r18, 0xFF	; 255
                v_num_u32 = va_arg(argp, uint32_t);
                LCD_DisplayNumber(C_DECIMAL_U8,v_num_u32,v_numOfDigitsToDisp_u8);               
                break;            

            case 'x':  /* Argument type is of hex, hence hexadecimal data from the argp */
                v_num_u16 = va_arg(argp, int);
 a76:	68 01       	movw	r12, r16
 a78:	f2 e0       	ldi	r31, 0x02	; 2
 a7a:	cf 0e       	add	r12, r31
 a7c:	d1 1c       	adc	r13, r1
                LCD_DisplayNumber(C_HEX_U8,v_num_u16,v_numOfDigitsToDisp_u8);
 a7e:	f8 01       	movw	r30, r16
 a80:	40 81       	ld	r20, Z
 a82:	51 81       	ldd	r21, Z+1	; 0x01
 a84:	60 e0       	ldi	r22, 0x00	; 0
 a86:	70 e0       	ldi	r23, 0x00	; 0
 a88:	0d c0       	rjmp	.+26     	; 0xaa4 <LCD_Printf+0x1d2>
            {
              v_numOfDigitsToDisp_u8 = C_MaxDigitsToDisplayUsingPrintf_U8;
            }                


            switch(ch)       /* Decode the type of the argument */
 a8a:	88 35       	cpi	r24, 0x58	; 88
 a8c:	09 f0       	breq	.+2      	; 0xa90 <LCD_Printf+0x1be>
 a8e:	87 cf       	rjmp	.-242    	; 0x99e <LCD_Printf+0xcc>
                   ch = *ptr;
                }
            }
            else
            {
              v_numOfDigitsToDisp_u8 = C_MaxDigitsToDisplayUsingPrintf_U8;
 a90:	2f ef       	ldi	r18, 0xFF	; 255
                v_num_u16 = va_arg(argp, int);
                LCD_DisplayNumber(C_HEX_U8,v_num_u16,v_numOfDigitsToDisp_u8);
                break;

            case 'X':  /* Argument type is of hex, hence hexadecimal data from the argp */
                v_num_u32 = va_arg(argp, uint32_t);
 a92:	68 01       	movw	r12, r16
 a94:	f4 e0       	ldi	r31, 0x04	; 4
 a96:	cf 0e       	add	r12, r31
 a98:	d1 1c       	adc	r13, r1
                LCD_DisplayNumber(C_HEX_U8,v_num_u32,v_numOfDigitsToDisp_u8);                
 a9a:	f8 01       	movw	r30, r16
 a9c:	40 81       	ld	r20, Z
 a9e:	51 81       	ldd	r21, Z+1	; 0x01
 aa0:	62 81       	ldd	r22, Z+2	; 0x02
 aa2:	73 81       	ldd	r23, Z+3	; 0x03
 aa4:	80 e1       	ldi	r24, 0x10	; 16
 aa6:	0e 94 9b 03 	call	0x736	; 0x736 <LCD_DisplayNumber>
 aaa:	39 c0       	rjmp	.+114    	; 0xb1e <LCD_Printf+0x24c>
            {
              v_numOfDigitsToDisp_u8 = C_MaxDigitsToDisplayUsingPrintf_U8;
            }                


            switch(ch)       /* Decode the type of the argument */
 aac:	82 36       	cpi	r24, 0x62	; 98
 aae:	e1 f5       	brne	.+120    	; 0xb28 <LCD_Printf+0x256>
                   ch = *ptr;
                }
            }
            else
            {
              v_numOfDigitsToDisp_u8 = C_MaxDigitsToDisplayUsingPrintf_U8;
 ab0:	2f ef       	ldi	r18, 0xFF	; 255
                LCD_DisplayNumber(C_HEX_U8,v_num_u32,v_numOfDigitsToDisp_u8);                
                break;

            
            case 'b':  /* Argument type is of binary,Read int and convert to binary */
                v_num_u16 = va_arg(argp, int);
 ab2:	68 01       	movw	r12, r16
 ab4:	f2 e0       	ldi	r31, 0x02	; 2
 ab6:	cf 0e       	add	r12, r31
 ab8:	d1 1c       	adc	r13, r1
 aba:	f8 01       	movw	r30, r16
 abc:	60 81       	ld	r22, Z
 abe:	71 81       	ldd	r23, Z+1	; 0x01
                if(v_numOfDigitsToDisp_u8 == C_MaxDigitsToDisplayUsingPrintf_U8)
 ac0:	2f 3f       	cpi	r18, 0xFF	; 255
 ac2:	09 f4       	brne	.+2      	; 0xac6 <LCD_Printf+0x1f4>
                   v_numOfDigitsToDisp_u8 = 16;
 ac4:	20 e1       	ldi	r18, 0x10	; 16
                LCD_DisplayNumber(C_BINARY_U8,v_num_u16,v_numOfDigitsToDisp_u8);                
 ac6:	80 e0       	ldi	r24, 0x00	; 0
 ac8:	90 e0       	ldi	r25, 0x00	; 0
 aca:	0c c0       	rjmp	.+24     	; 0xae4 <LCD_Printf+0x212>
                break;

            case 'B':  /* Argument type is of binary,Read int and convert to binary */
                v_num_u32 = va_arg(argp, uint32_t);
 acc:	68 01       	movw	r12, r16
 ace:	f4 e0       	ldi	r31, 0x04	; 4
 ad0:	cf 0e       	add	r12, r31
 ad2:	d1 1c       	adc	r13, r1
 ad4:	f8 01       	movw	r30, r16
 ad6:	60 81       	ld	r22, Z
 ad8:	71 81       	ldd	r23, Z+1	; 0x01
 ada:	82 81       	ldd	r24, Z+2	; 0x02
 adc:	93 81       	ldd	r25, Z+3	; 0x03
                if(v_numOfDigitsToDisp_u8 == C_MaxDigitsToDisplayUsingPrintf_U8)
 ade:	2f 3f       	cpi	r18, 0xFF	; 255
 ae0:	09 f4       	brne	.+2      	; 0xae4 <LCD_Printf+0x212>
                   v_numOfDigitsToDisp_u8 = 16;                
 ae2:	20 e1       	ldi	r18, 0x10	; 16
 ae4:	42 2f       	mov	r20, r18
 ae6:	0e 94 52 03 	call	0x6a4	; 0x6a4 <LCD_DisplayNumber.part.3>
 aea:	19 c0       	rjmp	.+50     	; 0xb1e <LCD_Printf+0x24c>
            {
              v_numOfDigitsToDisp_u8 = C_MaxDigitsToDisplayUsingPrintf_U8;
            }                


            switch(ch)       /* Decode the type of the argument */
 aec:	86 34       	cpi	r24, 0x46	; 70
 aee:	e1 f4       	brne	.+56     	; 0xb28 <LCD_Printf+0x256>


            case 'F':
            case 'f': /* Argument type is of float, hence read double data from the argp */
#if (Enable_LCD_DisplayFloatNumber == 1)  
                v_floatNum_f32 = va_arg(argp, double);              
 af0:	68 01       	movw	r12, r16
 af2:	f4 e0       	ldi	r31, 0x04	; 4
 af4:	cf 0e       	add	r12, r31
 af6:	d1 1c       	adc	r13, r1
                LCD_DisplayFloatNumber(v_floatNum_f32);
 af8:	f8 01       	movw	r30, r16
 afa:	60 81       	ld	r22, Z
 afc:	71 81       	ldd	r23, Z+1	; 0x01
 afe:	82 81       	ldd	r24, Z+2	; 0x02
 b00:	93 81       	ldd	r25, Z+3	; 0x03
 b02:	0e 94 32 04 	call	0x864	; 0x864 <LCD_DisplayFloatNumber>
 b06:	0b c0       	rjmp	.+22     	; 0xb1e <LCD_Printf+0x24c>
            {
              v_numOfDigitsToDisp_u8 = C_MaxDigitsToDisplayUsingPrintf_U8;
            }                


            switch(ch)       /* Decode the type of the argument */
 b08:	83 37       	cpi	r24, 0x73	; 115
 b0a:	71 f4       	brne	.+28     	; 0xb28 <LCD_Printf+0x256>
                break;


            case 'S':
            case 's': /* Argument type is of string, hence get the pointer to sting passed */
                str = va_arg(argp, char *);
 b0c:	68 01       	movw	r12, r16
 b0e:	f2 e0       	ldi	r31, 0x02	; 2
 b10:	cf 0e       	add	r12, r31
 b12:	d1 1c       	adc	r13, r1
                LCD_DisplayString(str);                
 b14:	f8 01       	movw	r30, r16
 b16:	80 81       	ld	r24, Z
 b18:	91 81       	ldd	r25, Z+1	; 0x01
 b1a:	0e 94 8f 03 	call	0x71e	; 0x71e <LCD_DisplayString>
                break;


            case 'S':
            case 's': /* Argument type is of string, hence get the pointer to sting passed */
                str = va_arg(argp, char *);
 b1e:	86 01       	movw	r16, r12
                LCD_DisplayString(str);                
                break;
 b20:	03 c0       	rjmp	.+6      	; 0xb28 <LCD_Printf+0x256>
            }
        }
        else
        {
            /* As '%' is not detected display/transmit the char passed */
            LCD_DisplayChar(ch);
 b22:	0e 94 26 03 	call	0x64c	; 0x64c <LCD_DisplayChar>
 b26:	76 01       	movw	r14, r12
#endif

    va_start(argp, argList);

    /* Loop through the list to extract all the input arguments */
    for(ptr = argList; *ptr != '\0'; ptr++)
 b28:	67 01       	movw	r12, r14
 b2a:	ff ef       	ldi	r31, 0xFF	; 255
 b2c:	cf 1a       	sub	r12, r31
 b2e:	df 0a       	sbc	r13, r31
 b30:	e2 ce       	rjmp	.-572    	; 0x8f6 <LCD_Printf+0x24>
            {
              v_numOfDigitsToDisp_u8 = C_MaxDigitsToDisplayUsingPrintf_U8;
            }                


            switch(ch)       /* Decode the type of the argument */
 b32:	82 34       	cpi	r24, 0x42	; 66
 b34:	09 f0       	breq	.+2      	; 0xb38 <LCD_Printf+0x266>
 b36:	27 cf       	rjmp	.-434    	; 0x986 <LCD_Printf+0xb4>
                   v_numOfDigitsToDisp_u8 = 16;
                LCD_DisplayNumber(C_BINARY_U8,v_num_u16,v_numOfDigitsToDisp_u8);                
                break;

            case 'B':  /* Argument type is of binary,Read int and convert to binary */
                v_num_u32 = va_arg(argp, uint32_t);
 b38:	68 01       	movw	r12, r16
 b3a:	f4 e0       	ldi	r31, 0x04	; 4
 b3c:	cf 0e       	add	r12, r31
 b3e:	d1 1c       	adc	r13, r1
 b40:	f8 01       	movw	r30, r16
 b42:	60 81       	ld	r22, Z
 b44:	71 81       	ldd	r23, Z+1	; 0x01
 b46:	82 81       	ldd	r24, Z+2	; 0x02
 b48:	93 81       	ldd	r25, Z+3	; 0x03
 b4a:	cb cf       	rjmp	.-106    	; 0xae2 <LCD_Printf+0x210>
            {
              v_numOfDigitsToDisp_u8 = C_MaxDigitsToDisplayUsingPrintf_U8;
            }                


            switch(ch)       /* Decode the type of the argument */
 b4c:	85 32       	cpi	r24, 0x25	; 37
 b4e:	61 f7       	brne	.-40     	; 0xb28 <LCD_Printf+0x256>
                str = va_arg(argp, char *);
                LCD_DisplayString(str);                
                break;

            case '%':
                LCD_DisplayChar('%');
 b50:	85 e2       	ldi	r24, 0x25	; 37
 b52:	0e 94 26 03 	call	0x64c	; 0x64c <LCD_DisplayChar>
                break;
 b56:	e8 cf       	rjmp	.-48     	; 0xb28 <LCD_Printf+0x256>
            LCD_DisplayChar(ch);
        }
    }

    va_end(argp);
}
 b58:	0f 90       	pop	r0
 b5a:	0f 90       	pop	r0
 b5c:	0f 90       	pop	r0
 b5e:	0f 90       	pop	r0
 b60:	0f 90       	pop	r0
 b62:	df 91       	pop	r29
 b64:	cf 91       	pop	r28
 b66:	1f 91       	pop	r17
 b68:	0f 91       	pop	r16
 b6a:	ff 90       	pop	r15
 b6c:	ef 90       	pop	r14
 b6e:	df 90       	pop	r13
 b70:	cf 90       	pop	r12
 b72:	08 95       	ret

00000b74 <main>:
 */
int main() 
{
    int count = 0;
    /*Connect RS->PB0, RW->PB1, EN->PB2 and data bus to PORTB.4 to PORTB.7*/
    LCD_SetUp(PB_0,PB_1,PB_2,P_NC,P_NC,P_NC,P_NC,PB_4,PB_5,PB_6,PB_7);
 b74:	8f e0       	ldi	r24, 0x0F	; 15
 b76:	8f 93       	push	r24
 b78:	8e e0       	ldi	r24, 0x0E	; 14
 b7a:	8f 93       	push	r24
 b7c:	8d e0       	ldi	r24, 0x0D	; 13
 b7e:	88 2e       	mov	r8, r24
 b80:	9c e0       	ldi	r25, 0x0C	; 12
 b82:	a9 2e       	mov	r10, r25
 b84:	cc 24       	eor	r12, r12
 b86:	ca 94       	dec	r12
 b88:	ee 24       	eor	r14, r14
 b8a:	ea 94       	dec	r14
 b8c:	0f ef       	ldi	r16, 0xFF	; 255
 b8e:	2f ef       	ldi	r18, 0xFF	; 255
 b90:	4a e0       	ldi	r20, 0x0A	; 10
 b92:	69 e0       	ldi	r22, 0x09	; 9
 b94:	88 e0       	ldi	r24, 0x08	; 8
 b96:	0e 94 2b 02 	call	0x456	; 0x456 <LCD_SetUp>
    LCD_Init(2,16);
 b9a:	60 e1       	ldi	r22, 0x10	; 16
 b9c:	82 e0       	ldi	r24, 0x02	; 2
 b9e:	0e 94 cb 02 	call	0x596	; 0x596 <LCD_Init>
    
    LCD_DisplayString("Decimal");
 ba2:	84 e6       	ldi	r24, 0x64	; 100
 ba4:	90 e0       	ldi	r25, 0x00	; 0
 ba6:	0e 94 8f 03 	call	0x71e	; 0x71e <LCD_DisplayString>
 baa:	0f 90       	pop	r0
 bac:	0f 90       	pop	r0
/*
 * 
 */
int main() 
{
    int count = 0;
 bae:	c0 e0       	ldi	r28, 0x00	; 0
 bb0:	d0 e0       	ldi	r29, 0x00	; 0
    LCD_DisplayString("Decimal");

    while(1)
    {
        LCD_GoToLine(1);
        LCD_Printf("Count=%4d",count);
 bb2:	0c e6       	ldi	r16, 0x6C	; 108
 bb4:	10 e0       	ldi	r17, 0x00	; 0
    
    LCD_DisplayString("Decimal");

    while(1)
    {
        LCD_GoToLine(1);
 bb6:	81 e0       	ldi	r24, 0x01	; 1
 bb8:	0e 94 b5 02 	call	0x56a	; 0x56a <LCD_GoToLine>
        LCD_Printf("Count=%4d",count);
 bbc:	df 93       	push	r29
 bbe:	cf 93       	push	r28
 bc0:	1f 93       	push	r17
 bc2:	0f 93       	push	r16
 bc4:	0e 94 69 04 	call	0x8d2	; 0x8d2 <LCD_Printf>
        DELAY_ms(500);
 bc8:	84 ef       	ldi	r24, 0xF4	; 244
 bca:	91 e0       	ldi	r25, 0x01	; 1
 bcc:	0e 94 52 00 	call	0xa4	; 0xa4 <DELAY_ms>
        count++;
 bd0:	21 96       	adiw	r28, 0x01	; 1
    }
 bd2:	0f 90       	pop	r0
 bd4:	0f 90       	pop	r0
 bd6:	0f 90       	pop	r0
 bd8:	0f 90       	pop	r0
 bda:	ed cf       	rjmp	.-38     	; 0xbb6 <main+0x42>

00000bdc <__subsf3>:
 bdc:	50 58       	subi	r21, 0x80	; 128

00000bde <__addsf3>:
 bde:	bb 27       	eor	r27, r27
 be0:	aa 27       	eor	r26, r26
 be2:	0e 94 06 06 	call	0xc0c	; 0xc0c <__addsf3x>
 be6:	0c 94 de 06 	jmp	0xdbc	; 0xdbc <__fp_round>
 bea:	0e 94 d0 06 	call	0xda0	; 0xda0 <__fp_pscA>
 bee:	38 f0       	brcs	.+14     	; 0xbfe <__addsf3+0x20>
 bf0:	0e 94 d7 06 	call	0xdae	; 0xdae <__fp_pscB>
 bf4:	20 f0       	brcs	.+8      	; 0xbfe <__addsf3+0x20>
 bf6:	39 f4       	brne	.+14     	; 0xc06 <__addsf3+0x28>
 bf8:	9f 3f       	cpi	r25, 0xFF	; 255
 bfa:	19 f4       	brne	.+6      	; 0xc02 <__addsf3+0x24>
 bfc:	26 f4       	brtc	.+8      	; 0xc06 <__addsf3+0x28>
 bfe:	0c 94 cd 06 	jmp	0xd9a	; 0xd9a <__fp_nan>
 c02:	0e f4       	brtc	.+2      	; 0xc06 <__addsf3+0x28>
 c04:	e0 95       	com	r30
 c06:	e7 fb       	bst	r30, 7
 c08:	0c 94 c7 06 	jmp	0xd8e	; 0xd8e <__fp_inf>

00000c0c <__addsf3x>:
 c0c:	e9 2f       	mov	r30, r25
 c0e:	0e 94 ef 06 	call	0xdde	; 0xdde <__fp_split3>
 c12:	58 f3       	brcs	.-42     	; 0xbea <__addsf3+0xc>
 c14:	ba 17       	cp	r27, r26
 c16:	62 07       	cpc	r22, r18
 c18:	73 07       	cpc	r23, r19
 c1a:	84 07       	cpc	r24, r20
 c1c:	95 07       	cpc	r25, r21
 c1e:	20 f0       	brcs	.+8      	; 0xc28 <__addsf3x+0x1c>
 c20:	79 f4       	brne	.+30     	; 0xc40 <__addsf3x+0x34>
 c22:	a6 f5       	brtc	.+104    	; 0xc8c <__addsf3x+0x80>
 c24:	0c 94 11 07 	jmp	0xe22	; 0xe22 <__fp_zero>
 c28:	0e f4       	brtc	.+2      	; 0xc2c <__addsf3x+0x20>
 c2a:	e0 95       	com	r30
 c2c:	0b 2e       	mov	r0, r27
 c2e:	ba 2f       	mov	r27, r26
 c30:	a0 2d       	mov	r26, r0
 c32:	0b 01       	movw	r0, r22
 c34:	b9 01       	movw	r22, r18
 c36:	90 01       	movw	r18, r0
 c38:	0c 01       	movw	r0, r24
 c3a:	ca 01       	movw	r24, r20
 c3c:	a0 01       	movw	r20, r0
 c3e:	11 24       	eor	r1, r1
 c40:	ff 27       	eor	r31, r31
 c42:	59 1b       	sub	r21, r25
 c44:	99 f0       	breq	.+38     	; 0xc6c <__addsf3x+0x60>
 c46:	59 3f       	cpi	r21, 0xF9	; 249
 c48:	50 f4       	brcc	.+20     	; 0xc5e <__addsf3x+0x52>
 c4a:	50 3e       	cpi	r21, 0xE0	; 224
 c4c:	68 f1       	brcs	.+90     	; 0xca8 <__addsf3x+0x9c>
 c4e:	1a 16       	cp	r1, r26
 c50:	f0 40       	sbci	r31, 0x00	; 0
 c52:	a2 2f       	mov	r26, r18
 c54:	23 2f       	mov	r18, r19
 c56:	34 2f       	mov	r19, r20
 c58:	44 27       	eor	r20, r20
 c5a:	58 5f       	subi	r21, 0xF8	; 248
 c5c:	f3 cf       	rjmp	.-26     	; 0xc44 <__addsf3x+0x38>
 c5e:	46 95       	lsr	r20
 c60:	37 95       	ror	r19
 c62:	27 95       	ror	r18
 c64:	a7 95       	ror	r26
 c66:	f0 40       	sbci	r31, 0x00	; 0
 c68:	53 95       	inc	r21
 c6a:	c9 f7       	brne	.-14     	; 0xc5e <__addsf3x+0x52>
 c6c:	7e f4       	brtc	.+30     	; 0xc8c <__addsf3x+0x80>
 c6e:	1f 16       	cp	r1, r31
 c70:	ba 0b       	sbc	r27, r26
 c72:	62 0b       	sbc	r22, r18
 c74:	73 0b       	sbc	r23, r19
 c76:	84 0b       	sbc	r24, r20
 c78:	ba f0       	brmi	.+46     	; 0xca8 <__addsf3x+0x9c>
 c7a:	91 50       	subi	r25, 0x01	; 1
 c7c:	a1 f0       	breq	.+40     	; 0xca6 <__addsf3x+0x9a>
 c7e:	ff 0f       	add	r31, r31
 c80:	bb 1f       	adc	r27, r27
 c82:	66 1f       	adc	r22, r22
 c84:	77 1f       	adc	r23, r23
 c86:	88 1f       	adc	r24, r24
 c88:	c2 f7       	brpl	.-16     	; 0xc7a <__addsf3x+0x6e>
 c8a:	0e c0       	rjmp	.+28     	; 0xca8 <__addsf3x+0x9c>
 c8c:	ba 0f       	add	r27, r26
 c8e:	62 1f       	adc	r22, r18
 c90:	73 1f       	adc	r23, r19
 c92:	84 1f       	adc	r24, r20
 c94:	48 f4       	brcc	.+18     	; 0xca8 <__addsf3x+0x9c>
 c96:	87 95       	ror	r24
 c98:	77 95       	ror	r23
 c9a:	67 95       	ror	r22
 c9c:	b7 95       	ror	r27
 c9e:	f7 95       	ror	r31
 ca0:	9e 3f       	cpi	r25, 0xFE	; 254
 ca2:	08 f0       	brcs	.+2      	; 0xca6 <__addsf3x+0x9a>
 ca4:	b0 cf       	rjmp	.-160    	; 0xc06 <__addsf3+0x28>
 ca6:	93 95       	inc	r25
 ca8:	88 0f       	add	r24, r24
 caa:	08 f0       	brcs	.+2      	; 0xcae <__addsf3x+0xa2>
 cac:	99 27       	eor	r25, r25
 cae:	ee 0f       	add	r30, r30
 cb0:	97 95       	ror	r25
 cb2:	87 95       	ror	r24
 cb4:	08 95       	ret

00000cb6 <__fixunssfsi>:
 cb6:	0e 94 f7 06 	call	0xdee	; 0xdee <__fp_splitA>
 cba:	88 f0       	brcs	.+34     	; 0xcde <__fixunssfsi+0x28>
 cbc:	9f 57       	subi	r25, 0x7F	; 127
 cbe:	98 f0       	brcs	.+38     	; 0xce6 <__fixunssfsi+0x30>
 cc0:	b9 2f       	mov	r27, r25
 cc2:	99 27       	eor	r25, r25
 cc4:	b7 51       	subi	r27, 0x17	; 23
 cc6:	b0 f0       	brcs	.+44     	; 0xcf4 <__fixunssfsi+0x3e>
 cc8:	e1 f0       	breq	.+56     	; 0xd02 <__fixunssfsi+0x4c>
 cca:	66 0f       	add	r22, r22
 ccc:	77 1f       	adc	r23, r23
 cce:	88 1f       	adc	r24, r24
 cd0:	99 1f       	adc	r25, r25
 cd2:	1a f0       	brmi	.+6      	; 0xcda <__fixunssfsi+0x24>
 cd4:	ba 95       	dec	r27
 cd6:	c9 f7       	brne	.-14     	; 0xcca <__fixunssfsi+0x14>
 cd8:	14 c0       	rjmp	.+40     	; 0xd02 <__fixunssfsi+0x4c>
 cda:	b1 30       	cpi	r27, 0x01	; 1
 cdc:	91 f0       	breq	.+36     	; 0xd02 <__fixunssfsi+0x4c>
 cde:	0e 94 11 07 	call	0xe22	; 0xe22 <__fp_zero>
 ce2:	b1 e0       	ldi	r27, 0x01	; 1
 ce4:	08 95       	ret
 ce6:	0c 94 11 07 	jmp	0xe22	; 0xe22 <__fp_zero>
 cea:	67 2f       	mov	r22, r23
 cec:	78 2f       	mov	r23, r24
 cee:	88 27       	eor	r24, r24
 cf0:	b8 5f       	subi	r27, 0xF8	; 248
 cf2:	39 f0       	breq	.+14     	; 0xd02 <__fixunssfsi+0x4c>
 cf4:	b9 3f       	cpi	r27, 0xF9	; 249
 cf6:	cc f3       	brlt	.-14     	; 0xcea <__fixunssfsi+0x34>
 cf8:	86 95       	lsr	r24
 cfa:	77 95       	ror	r23
 cfc:	67 95       	ror	r22
 cfe:	b3 95       	inc	r27
 d00:	d9 f7       	brne	.-10     	; 0xcf8 <__fixunssfsi+0x42>
 d02:	3e f4       	brtc	.+14     	; 0xd12 <__fixunssfsi+0x5c>
 d04:	90 95       	com	r25
 d06:	80 95       	com	r24
 d08:	70 95       	com	r23
 d0a:	61 95       	neg	r22
 d0c:	7f 4f       	sbci	r23, 0xFF	; 255
 d0e:	8f 4f       	sbci	r24, 0xFF	; 255
 d10:	9f 4f       	sbci	r25, 0xFF	; 255
 d12:	08 95       	ret

00000d14 <__floatunsisf>:
 d14:	e8 94       	clt
 d16:	09 c0       	rjmp	.+18     	; 0xd2a <__floatsisf+0x12>

00000d18 <__floatsisf>:
 d18:	97 fb       	bst	r25, 7
 d1a:	3e f4       	brtc	.+14     	; 0xd2a <__floatsisf+0x12>
 d1c:	90 95       	com	r25
 d1e:	80 95       	com	r24
 d20:	70 95       	com	r23
 d22:	61 95       	neg	r22
 d24:	7f 4f       	sbci	r23, 0xFF	; 255
 d26:	8f 4f       	sbci	r24, 0xFF	; 255
 d28:	9f 4f       	sbci	r25, 0xFF	; 255
 d2a:	99 23       	and	r25, r25
 d2c:	a9 f0       	breq	.+42     	; 0xd58 <__floatsisf+0x40>
 d2e:	f9 2f       	mov	r31, r25
 d30:	96 e9       	ldi	r25, 0x96	; 150
 d32:	bb 27       	eor	r27, r27
 d34:	93 95       	inc	r25
 d36:	f6 95       	lsr	r31
 d38:	87 95       	ror	r24
 d3a:	77 95       	ror	r23
 d3c:	67 95       	ror	r22
 d3e:	b7 95       	ror	r27
 d40:	f1 11       	cpse	r31, r1
 d42:	f8 cf       	rjmp	.-16     	; 0xd34 <__floatsisf+0x1c>
 d44:	fa f4       	brpl	.+62     	; 0xd84 <__floatsisf+0x6c>
 d46:	bb 0f       	add	r27, r27
 d48:	11 f4       	brne	.+4      	; 0xd4e <__floatsisf+0x36>
 d4a:	60 ff       	sbrs	r22, 0
 d4c:	1b c0       	rjmp	.+54     	; 0xd84 <__floatsisf+0x6c>
 d4e:	6f 5f       	subi	r22, 0xFF	; 255
 d50:	7f 4f       	sbci	r23, 0xFF	; 255
 d52:	8f 4f       	sbci	r24, 0xFF	; 255
 d54:	9f 4f       	sbci	r25, 0xFF	; 255
 d56:	16 c0       	rjmp	.+44     	; 0xd84 <__floatsisf+0x6c>
 d58:	88 23       	and	r24, r24
 d5a:	11 f0       	breq	.+4      	; 0xd60 <__floatsisf+0x48>
 d5c:	96 e9       	ldi	r25, 0x96	; 150
 d5e:	11 c0       	rjmp	.+34     	; 0xd82 <__floatsisf+0x6a>
 d60:	77 23       	and	r23, r23
 d62:	21 f0       	breq	.+8      	; 0xd6c <__floatsisf+0x54>
 d64:	9e e8       	ldi	r25, 0x8E	; 142
 d66:	87 2f       	mov	r24, r23
 d68:	76 2f       	mov	r23, r22
 d6a:	05 c0       	rjmp	.+10     	; 0xd76 <__floatsisf+0x5e>
 d6c:	66 23       	and	r22, r22
 d6e:	71 f0       	breq	.+28     	; 0xd8c <__floatsisf+0x74>
 d70:	96 e8       	ldi	r25, 0x86	; 134
 d72:	86 2f       	mov	r24, r22
 d74:	70 e0       	ldi	r23, 0x00	; 0
 d76:	60 e0       	ldi	r22, 0x00	; 0
 d78:	2a f0       	brmi	.+10     	; 0xd84 <__floatsisf+0x6c>
 d7a:	9a 95       	dec	r25
 d7c:	66 0f       	add	r22, r22
 d7e:	77 1f       	adc	r23, r23
 d80:	88 1f       	adc	r24, r24
 d82:	da f7       	brpl	.-10     	; 0xd7a <__floatsisf+0x62>
 d84:	88 0f       	add	r24, r24
 d86:	96 95       	lsr	r25
 d88:	87 95       	ror	r24
 d8a:	97 f9       	bld	r25, 7
 d8c:	08 95       	ret

00000d8e <__fp_inf>:
 d8e:	97 f9       	bld	r25, 7
 d90:	9f 67       	ori	r25, 0x7F	; 127
 d92:	80 e8       	ldi	r24, 0x80	; 128
 d94:	70 e0       	ldi	r23, 0x00	; 0
 d96:	60 e0       	ldi	r22, 0x00	; 0
 d98:	08 95       	ret

00000d9a <__fp_nan>:
 d9a:	9f ef       	ldi	r25, 0xFF	; 255
 d9c:	80 ec       	ldi	r24, 0xC0	; 192
 d9e:	08 95       	ret

00000da0 <__fp_pscA>:
 da0:	00 24       	eor	r0, r0
 da2:	0a 94       	dec	r0
 da4:	16 16       	cp	r1, r22
 da6:	17 06       	cpc	r1, r23
 da8:	18 06       	cpc	r1, r24
 daa:	09 06       	cpc	r0, r25
 dac:	08 95       	ret

00000dae <__fp_pscB>:
 dae:	00 24       	eor	r0, r0
 db0:	0a 94       	dec	r0
 db2:	12 16       	cp	r1, r18
 db4:	13 06       	cpc	r1, r19
 db6:	14 06       	cpc	r1, r20
 db8:	05 06       	cpc	r0, r21
 dba:	08 95       	ret

00000dbc <__fp_round>:
 dbc:	09 2e       	mov	r0, r25
 dbe:	03 94       	inc	r0
 dc0:	00 0c       	add	r0, r0
 dc2:	11 f4       	brne	.+4      	; 0xdc8 <__fp_round+0xc>
 dc4:	88 23       	and	r24, r24
 dc6:	52 f0       	brmi	.+20     	; 0xddc <__fp_round+0x20>
 dc8:	bb 0f       	add	r27, r27
 dca:	40 f4       	brcc	.+16     	; 0xddc <__fp_round+0x20>
 dcc:	bf 2b       	or	r27, r31
 dce:	11 f4       	brne	.+4      	; 0xdd4 <__fp_round+0x18>
 dd0:	60 ff       	sbrs	r22, 0
 dd2:	04 c0       	rjmp	.+8      	; 0xddc <__fp_round+0x20>
 dd4:	6f 5f       	subi	r22, 0xFF	; 255
 dd6:	7f 4f       	sbci	r23, 0xFF	; 255
 dd8:	8f 4f       	sbci	r24, 0xFF	; 255
 dda:	9f 4f       	sbci	r25, 0xFF	; 255
 ddc:	08 95       	ret

00000dde <__fp_split3>:
 dde:	57 fd       	sbrc	r21, 7
 de0:	90 58       	subi	r25, 0x80	; 128
 de2:	44 0f       	add	r20, r20
 de4:	55 1f       	adc	r21, r21
 de6:	59 f0       	breq	.+22     	; 0xdfe <__fp_splitA+0x10>
 de8:	5f 3f       	cpi	r21, 0xFF	; 255
 dea:	71 f0       	breq	.+28     	; 0xe08 <__fp_splitA+0x1a>
 dec:	47 95       	ror	r20

00000dee <__fp_splitA>:
 dee:	88 0f       	add	r24, r24
 df0:	97 fb       	bst	r25, 7
 df2:	99 1f       	adc	r25, r25
 df4:	61 f0       	breq	.+24     	; 0xe0e <__fp_splitA+0x20>
 df6:	9f 3f       	cpi	r25, 0xFF	; 255
 df8:	79 f0       	breq	.+30     	; 0xe18 <__fp_splitA+0x2a>
 dfa:	87 95       	ror	r24
 dfc:	08 95       	ret
 dfe:	12 16       	cp	r1, r18
 e00:	13 06       	cpc	r1, r19
 e02:	14 06       	cpc	r1, r20
 e04:	55 1f       	adc	r21, r21
 e06:	f2 cf       	rjmp	.-28     	; 0xdec <__fp_split3+0xe>
 e08:	46 95       	lsr	r20
 e0a:	f1 df       	rcall	.-30     	; 0xdee <__fp_splitA>
 e0c:	08 c0       	rjmp	.+16     	; 0xe1e <__fp_splitA+0x30>
 e0e:	16 16       	cp	r1, r22
 e10:	17 06       	cpc	r1, r23
 e12:	18 06       	cpc	r1, r24
 e14:	99 1f       	adc	r25, r25
 e16:	f1 cf       	rjmp	.-30     	; 0xdfa <__fp_splitA+0xc>
 e18:	86 95       	lsr	r24
 e1a:	71 05       	cpc	r23, r1
 e1c:	61 05       	cpc	r22, r1
 e1e:	08 94       	sec
 e20:	08 95       	ret

00000e22 <__fp_zero>:
 e22:	e8 94       	clt

00000e24 <__fp_szero>:
 e24:	bb 27       	eor	r27, r27
 e26:	66 27       	eor	r22, r22
 e28:	77 27       	eor	r23, r23
 e2a:	cb 01       	movw	r24, r22
 e2c:	97 f9       	bld	r25, 7
 e2e:	08 95       	ret

00000e30 <__mulsf3>:
 e30:	0e 94 2b 07 	call	0xe56	; 0xe56 <__mulsf3x>
 e34:	0c 94 de 06 	jmp	0xdbc	; 0xdbc <__fp_round>
 e38:	0e 94 d0 06 	call	0xda0	; 0xda0 <__fp_pscA>
 e3c:	38 f0       	brcs	.+14     	; 0xe4c <__mulsf3+0x1c>
 e3e:	0e 94 d7 06 	call	0xdae	; 0xdae <__fp_pscB>
 e42:	20 f0       	brcs	.+8      	; 0xe4c <__mulsf3+0x1c>
 e44:	95 23       	and	r25, r21
 e46:	11 f0       	breq	.+4      	; 0xe4c <__mulsf3+0x1c>
 e48:	0c 94 c7 06 	jmp	0xd8e	; 0xd8e <__fp_inf>
 e4c:	0c 94 cd 06 	jmp	0xd9a	; 0xd9a <__fp_nan>
 e50:	11 24       	eor	r1, r1
 e52:	0c 94 12 07 	jmp	0xe24	; 0xe24 <__fp_szero>

00000e56 <__mulsf3x>:
 e56:	0e 94 ef 06 	call	0xdde	; 0xdde <__fp_split3>
 e5a:	70 f3       	brcs	.-36     	; 0xe38 <__mulsf3+0x8>

00000e5c <__mulsf3_pse>:
 e5c:	95 9f       	mul	r25, r21
 e5e:	c1 f3       	breq	.-16     	; 0xe50 <__mulsf3+0x20>
 e60:	95 0f       	add	r25, r21
 e62:	50 e0       	ldi	r21, 0x00	; 0
 e64:	55 1f       	adc	r21, r21
 e66:	62 9f       	mul	r22, r18
 e68:	f0 01       	movw	r30, r0
 e6a:	72 9f       	mul	r23, r18
 e6c:	bb 27       	eor	r27, r27
 e6e:	f0 0d       	add	r31, r0
 e70:	b1 1d       	adc	r27, r1
 e72:	63 9f       	mul	r22, r19
 e74:	aa 27       	eor	r26, r26
 e76:	f0 0d       	add	r31, r0
 e78:	b1 1d       	adc	r27, r1
 e7a:	aa 1f       	adc	r26, r26
 e7c:	64 9f       	mul	r22, r20
 e7e:	66 27       	eor	r22, r22
 e80:	b0 0d       	add	r27, r0
 e82:	a1 1d       	adc	r26, r1
 e84:	66 1f       	adc	r22, r22
 e86:	82 9f       	mul	r24, r18
 e88:	22 27       	eor	r18, r18
 e8a:	b0 0d       	add	r27, r0
 e8c:	a1 1d       	adc	r26, r1
 e8e:	62 1f       	adc	r22, r18
 e90:	73 9f       	mul	r23, r19
 e92:	b0 0d       	add	r27, r0
 e94:	a1 1d       	adc	r26, r1
 e96:	62 1f       	adc	r22, r18
 e98:	83 9f       	mul	r24, r19
 e9a:	a0 0d       	add	r26, r0
 e9c:	61 1d       	adc	r22, r1
 e9e:	22 1f       	adc	r18, r18
 ea0:	74 9f       	mul	r23, r20
 ea2:	33 27       	eor	r19, r19
 ea4:	a0 0d       	add	r26, r0
 ea6:	61 1d       	adc	r22, r1
 ea8:	23 1f       	adc	r18, r19
 eaa:	84 9f       	mul	r24, r20
 eac:	60 0d       	add	r22, r0
 eae:	21 1d       	adc	r18, r1
 eb0:	82 2f       	mov	r24, r18
 eb2:	76 2f       	mov	r23, r22
 eb4:	6a 2f       	mov	r22, r26
 eb6:	11 24       	eor	r1, r1
 eb8:	9f 57       	subi	r25, 0x7F	; 127
 eba:	50 40       	sbci	r21, 0x00	; 0
 ebc:	9a f0       	brmi	.+38     	; 0xee4 <__mulsf3_pse+0x88>
 ebe:	f1 f0       	breq	.+60     	; 0xefc <__mulsf3_pse+0xa0>
 ec0:	88 23       	and	r24, r24
 ec2:	4a f0       	brmi	.+18     	; 0xed6 <__mulsf3_pse+0x7a>
 ec4:	ee 0f       	add	r30, r30
 ec6:	ff 1f       	adc	r31, r31
 ec8:	bb 1f       	adc	r27, r27
 eca:	66 1f       	adc	r22, r22
 ecc:	77 1f       	adc	r23, r23
 ece:	88 1f       	adc	r24, r24
 ed0:	91 50       	subi	r25, 0x01	; 1
 ed2:	50 40       	sbci	r21, 0x00	; 0
 ed4:	a9 f7       	brne	.-22     	; 0xec0 <__mulsf3_pse+0x64>
 ed6:	9e 3f       	cpi	r25, 0xFE	; 254
 ed8:	51 05       	cpc	r21, r1
 eda:	80 f0       	brcs	.+32     	; 0xefc <__mulsf3_pse+0xa0>
 edc:	0c 94 c7 06 	jmp	0xd8e	; 0xd8e <__fp_inf>
 ee0:	0c 94 12 07 	jmp	0xe24	; 0xe24 <__fp_szero>
 ee4:	5f 3f       	cpi	r21, 0xFF	; 255
 ee6:	e4 f3       	brlt	.-8      	; 0xee0 <__mulsf3_pse+0x84>
 ee8:	98 3e       	cpi	r25, 0xE8	; 232
 eea:	d4 f3       	brlt	.-12     	; 0xee0 <__mulsf3_pse+0x84>
 eec:	86 95       	lsr	r24
 eee:	77 95       	ror	r23
 ef0:	67 95       	ror	r22
 ef2:	b7 95       	ror	r27
 ef4:	f7 95       	ror	r31
 ef6:	e7 95       	ror	r30
 ef8:	9f 5f       	subi	r25, 0xFF	; 255
 efa:	c1 f7       	brne	.-16     	; 0xeec <__mulsf3_pse+0x90>
 efc:	fe 2b       	or	r31, r30
 efe:	88 0f       	add	r24, r24
 f00:	91 1d       	adc	r25, r1
 f02:	96 95       	lsr	r25
 f04:	87 95       	ror	r24
 f06:	97 f9       	bld	r25, 7
 f08:	08 95       	ret

00000f0a <__udivmodsi4>:
 f0a:	a1 e2       	ldi	r26, 0x21	; 33
 f0c:	1a 2e       	mov	r1, r26
 f0e:	aa 1b       	sub	r26, r26
 f10:	bb 1b       	sub	r27, r27
 f12:	fd 01       	movw	r30, r26
 f14:	0d c0       	rjmp	.+26     	; 0xf30 <__udivmodsi4_ep>

00000f16 <__udivmodsi4_loop>:
 f16:	aa 1f       	adc	r26, r26
 f18:	bb 1f       	adc	r27, r27
 f1a:	ee 1f       	adc	r30, r30
 f1c:	ff 1f       	adc	r31, r31
 f1e:	a2 17       	cp	r26, r18
 f20:	b3 07       	cpc	r27, r19
 f22:	e4 07       	cpc	r30, r20
 f24:	f5 07       	cpc	r31, r21
 f26:	20 f0       	brcs	.+8      	; 0xf30 <__udivmodsi4_ep>
 f28:	a2 1b       	sub	r26, r18
 f2a:	b3 0b       	sbc	r27, r19
 f2c:	e4 0b       	sbc	r30, r20
 f2e:	f5 0b       	sbc	r31, r21

00000f30 <__udivmodsi4_ep>:
 f30:	66 1f       	adc	r22, r22
 f32:	77 1f       	adc	r23, r23
 f34:	88 1f       	adc	r24, r24
 f36:	99 1f       	adc	r25, r25
 f38:	1a 94       	dec	r1
 f3a:	69 f7       	brne	.-38     	; 0xf16 <__udivmodsi4_loop>
 f3c:	60 95       	com	r22
 f3e:	70 95       	com	r23
 f40:	80 95       	com	r24
 f42:	90 95       	com	r25
 f44:	9b 01       	movw	r18, r22
 f46:	ac 01       	movw	r20, r24
 f48:	bd 01       	movw	r22, r26
 f4a:	cf 01       	movw	r24, r30
 f4c:	08 95       	ret

00000f4e <_exit>:
 f4e:	f8 94       	cli

00000f50 <__stop_program>:
 f50:	ff cf       	rjmp	.-2      	; 0xf50 <__stop_program>
